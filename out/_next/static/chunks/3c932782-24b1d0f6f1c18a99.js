"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[711],{4277:function(h,g,te){te.d(g,{B10:function(){return r7},BHj:function(){return aC},CnO:function(){return ok},Fp7:function(){return oO},Gg6:function(){return nL},HHK:function(){return nV},IHx:function(){return rw},OI3:function(){return ol},Qqt:function(){return eG},RRF:function(){return Mn},Tek:function(){return r4},UYe:function(){return oz},U_I:function(){return or},W76:function(){return eY},XAC:function(){return nU},XD2:function(){return e0},XLQ:function(){return n_},XeE:function(){return Fn},Xhn:function(){return a0},_sB:function(){return oy},_wD:function(){return tI},dC7:function(){return rB},dt4:function(){return nC},esB:function(){return tx},hiC:function(){return rk},hlL:function(){return Hn},iD$:function(){return On},iUl:function(){return eV},io:function(){return aZ},knu:function(){return nP},lls:function(){return Gn},luU:function(){return rU},lub:function(){return Ze},odF:function(){return Bn},p4s:function(){return oq},tPi:function(){return oE},tgs:function(){return rf},vku:function(){return nI},wOQ:function(){return Pn},wS1:function(){return ox},yXz:function(){return Ln},zoF:function(){return t1}});var tr,to=te(2601),tu=te(263).Buffer,t=function(h,g){return(t=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(h,g){h.__proto__=g}||function(h,g){for(var te in g)g.hasOwnProperty(te)&&(h[te]=g[te])})(h,g)};function e(h,g){function r(){this.constructor=h}t(h,g),h.prototype=null===g?Object.create(g):(r.prototype=g.prototype,new r)}function n(h,g,te,tr){return new(te||(te=Promise))(function(to,tu){function i(h){try{u(tr.next(h))}catch(h){tu(h)}}function s(h){try{u(tr.throw(h))}catch(h){tu(h)}}function u(h){h.done?to(h.value):new te(function(g){g(h.value)}).then(i,s)}u((tr=tr.apply(h,g||[])).next())})}function r(h,g){var te,tr,to,tu,tc={label:0,sent:function(){if(1&to[0])throw to[1];return to[1]},trys:[],ops:[]};return tu={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(tu[Symbol.iterator]=function(){return this}),tu;function s(tu){return function(tl){return function(tu){if(te)throw TypeError("Generator is already executing.");for(;tc;)try{if(te=1,tr&&(to=2&tu[0]?tr.return:tu[0]?tr.throw||((to=tr.return)&&to.call(tr),0):tr.next)&&!(to=to.call(tr,tu[1])).done)return to;switch(tr=0,to&&(tu=[2&tu[0],to.value]),tu[0]){case 0:case 1:to=tu;break;case 4:return tc.label++,{value:tu[1],done:!1};case 5:tc.label++,tr=tu[1],tu=[0];continue;case 7:tu=tc.ops.pop(),tc.trys.pop();continue;default:if(!(to=(to=tc.trys).length>0&&to[to.length-1])&&(6===tu[0]||2===tu[0])){tc=0;continue}if(3===tu[0]&&(!to||tu[1]>to[0]&&tu[1]<to[3])){tc.label=tu[1];break}if(6===tu[0]&&tc.label<to[1]){tc.label=to[1],to=tu;break}if(to&&tc.label<to[2]){tc.label=to[2],tc.ops.push(tu);break}to[2]&&tc.ops.pop(),tc.trys.pop();continue}tu=g.call(h,tc)}catch(h){tu=[6,h],tr=0}finally{te=to=0}if(5&tu[0])throw tu[1];return{value:tu[0]?tu[1]:void 0,done:!0}}([tu,tl])}}}var tc=function(){function t(h){this.global=h,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}return t.prototype.setPlatform=function(h,g){null!=this.platform&&console.warn("Platform "+this.platformName+" has already been set. Overwriting the platform with "+g+"."),this.platformName=h,this.platform=g},t.prototype.registerFlag=function(h,g,te){if(this.flagRegistry[h]={evaluationFn:g,setHook:te},null!=this.urlFlags[h]){var tr=this.urlFlags[h];console.warn("Setting feature override from URL "+h+": "+tr+"."),this.set(h,tr)}},t.prototype.get=function(h){return h in this.flags||(this.flags[h]=this.evaluateFlag(h)),this.flags[h]},t.prototype.getNumber=function(h){return this.get(h)},t.prototype.getBool=function(h){return this.get(h)},t.prototype.getFlags=function(){return this.flags},Object.defineProperty(t.prototype,"features",{get:function(){return this.flags},enumerable:!0,configurable:!0}),t.prototype.set=function(h,g){if(null==this.flagRegistry[h])throw Error("Cannot set flag "+h+" as it has not been registered.");this.flags[h]=g,null!=this.flagRegistry[h].setHook&&this.flagRegistry[h].setHook(g)},t.prototype.evaluateFlag=function(h){if(null==this.flagRegistry[h])throw Error("Cannot evaluate flag '"+h+"': no evaluation function found.");return this.flagRegistry[h].evaluationFn()},t.prototype.setFlags=function(h){this.flags=Object.assign({},h)},t.prototype.reset=function(){this.flags={},this.urlFlags={},this.populateURLFlags()},t.prototype.populateURLFlags=function(){var h=this;if(void 0!==this.global&&void 0!==this.global.location&&void 0!==this.global.location.search){var g,te,tr=(g=this.global.location.search,te={},g.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,function(h){for(var g,tr,to=[],tu=1;tu<arguments.length;tu++)to[tu-1]=arguments[tu];return g=to[0],tr=to[1],te[decodeURIComponent(g)]=decodeURIComponent(tr||""),to.join("=")}),te);"tfjsflags"in tr&&tr.tfjsflags.split(",").forEach(function(g){var te=g.split(":"),tr=te[0],to=te[1];h.urlFlags[tr]=function(h,g){if("true"===(g=g.toLowerCase())||"false"===g)return"true"===g;if(""+ +g===g)return+g;throw Error("Could not parse value flag value "+g+" for flag "+h+".")}(tr,to)})}},t}(),tl=null,th=new Map,td=new Map;function l(h,g){var te=g+"_"+h;return th.get(te)}function f(h){for(var g=th.entries(),te=[];;){var tr=g.next(),to=tr.done,tu=tr.value;if(to)break;var tc=tu[0],tl=tu[1];tc.split("_")[0]===h&&te.push(tl)}return te}function d(h){var g=h.kernelName,te=h.backendName,tr=te+"_"+g;if(th.has(tr))throw Error("The kernel '"+g+"' for backend '"+te+"' is already registered");th.set(tr,h)}function y(h){for(var g=h.length,te=0,tr=0;g>0;)tr=Math.random()*g|0,te=h[--g],h[g]=h[tr],h[tr]=te}function x(h,g,te){return Math.max(h,Math.min(g,te))}function b(h){return h%2==0?h:h+1}function w(h){for(var g=0,te=0;te<h.length;te++)g+=h[te];return g}function C(h,g){if(!h)throw Error("string"==typeof g?g:g())}function E(h,g,te){void 0===te&&(te=""),C(S(h,g),function(){return te+" Shapes "+h+" and "+g+" must match"})}function R(h){C(null!=h,function(){return"The input to the tensor constructor must be a non-null value."})}function I(h,g,te){if(void 0===g&&(g=[]),void 0===te&&(te=!1),null==g&&(g=[]),Array.isArray(h)||V(h)&&!te)for(var tr=0;tr<h.length;++tr)I(h[tr],g,te);else g.push(h);return g}function k(h){if(0===h.length)return 1;for(var g=h[0],te=1;te<h.length;te++)g*=h[te];return g}function S(h,g){if(h===g)return!0;if(null==h||null==g||h.length!==g.length)return!1;for(var te=0;te<h.length;te++)if(h[te]!==g[te])return!1;return!0}function A(h){return h%1==0}function D(h){if(null!=Math.tanh)return Math.tanh(h);if(h===1/0)return 1;if(h===-1/0)return -1;var g=Math.exp(2*h);return(g-1)/(g+1)}function T(h){var g=Math.ceil(Math.sqrt(h));return[g,Math.ceil(h/g)]}function N(h,g){return g<=h.length?h:h+" ".repeat(g-h.length)}function F(h,g,te){return void 0===g&&(g=function(h){return 0}),new Promise(function(tr,to){var tu=0,i=function(){if(h())tr();else{tu++;var tc=g(tu);null!=te&&tu>=te?to():setTimeout(i,tc)}};i()})}function _(h,g){for(var te=1,tr=-1,to=0;to<h.length;++to)if(h[to]>=0)te*=h[to];else if(-1===h[to]){if(-1!==tr)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+tr+" and dim "+to);tr=to}else if(h[to]<0)throw Error("Shapes can not be < 0. Found "+h[to]+" at dim "+to);if(-1===tr){if(g>0&&g!==te)throw Error("Size("+g+") must match the product of shape "+h);return h}if(0===te)throw Error("Cannot infer the missing size in ["+h+"] when there are 0 elements");if(g%te!=0)throw Error("The implicit shape can't be a fractional number. Got "+g+" / "+te);var tu=h.slice();return tu[tr]=g/te,tu}function O(h,g){var te=g.length;return C((h=null==h?g.map(function(h,g){return g}):[].concat(h)).every(function(h){return h>=-te&&h<te}),function(){return"All values in axis param must be in range [-"+te+", "+te+") but got axis "+h}),C(h.every(function(h){return A(h)}),function(){return"All values in axis param must be integers but got axis "+h}),h.map(function(h){return h<0?te+h:h})}function M(h,g){for(var te=[],tr=[],to=null!=g&&Array.isArray(g)&&0===g.length,tu=null==g||to?null:O(g,h).sort(),tc=0,tl=0;tl<h.length;++tl){if(null!=tu){if(tu[tc]===tl&&1!==h[tl])throw Error("Can't squeeze axis "+tl+" since its dim '"+h[tl]+"' is not 1");(null==tu[tc]||tu[tc]>tl)&&1===h[tl]&&(te.push(h[tl]),tr.push(tl)),tu[tc]<=tl&&tc++}1!==h[tl]&&(te.push(h[tl]),tr.push(tl))}return{newShape:te,keptDims:tr}}function B(h,g){var te=null;if(null==h||"float32"===h)te=new Float32Array(g);else if("int32"===h)te=new Int32Array(g);else{if("bool"!==h)throw Error("Unknown data type "+h);te=new Uint8Array(g)}return te}function P(h,g){var te=null;if(null==h||"float32"===h)te=new Float32Array(g);else if("int32"===h)te=new Int32Array(g);else if("bool"===h)te=new Uint8Array(g);else{if("string"!==h)throw Error("Unknown data type "+h);te=Array(g)}return te}function L(h,g){for(var te=0;te<h.length;te++){var tr=h[te];if(isNaN(tr)||!isFinite(tr))throw Error("A tensor of type "+g+" being uploaded contains "+tr+".")}}function W(h){return"bool"===h||"complex64"===h||"float32"===h||"int32"===h||"string"===h}function U(h,g){return"complex64"!==g&&("float32"!==g||"complex64"===h)&&("int32"!==g||"float32"===h||"complex64"===h)&&("bool"!==g||"bool"!==h)}function V(h){return h instanceof Float32Array||h instanceof Int32Array||h instanceof Uint8Array}function z(h){if("float32"===h||"int32"===h)return 4;if("complex64"===h)return 8;if("bool"===h)return 1;throw Error("Unknown dtype "+h)}function G(h){if(null==h)return 0;var g=0;return h.forEach(function(h){return g+=h.length}),g}function H(h){return"string"==typeof h||h instanceof String}function q(h){return"boolean"==typeof h}function K(h){return"number"==typeof h}function j(h){return Array.isArray(h)?j(h[0]):h instanceof Float32Array?"float32":h instanceof Int32Array||h instanceof Uint8Array?"int32":K(h)?"float32":H(h)?"string":q(h)?"bool":"float32"}function X(h){return!!(h&&h.constructor&&h.call&&h.apply)}function Y(h,g){for(var te=g;te<h;++te)if(h%te==0)return te;return h}function $(h){var g=h.length;if(g<2)return[];var te=Array(g-1);te[g-2]=h[g-1];for(var tr=g-3;tr>=0;--tr)te[tr]=te[tr+1]*h[tr+1];return te}function Q(h,g,te){if("string"===g)throw Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(h)&&(h=I(h)),te&&L(h,g),(tr=h)instanceof Float32Array&&"float32"===g||tr instanceof Int32Array&&"int32"===g||tr instanceof Uint8Array&&"bool"===g)return h;if(null==g||"float32"===g||"complex64"===g)return new Float32Array(h);if("int32"===g)return new Int32Array(h);if("bool"===g){for(var tr,to=new Uint8Array(h.length),tu=0;tu<to.length;++tu)0!==Math.round(h[tu])&&(to[tu]=1);return to}throw Error("Unknown data type "+g)}function J(h,g){if(0===h.length)return g[0];var te=h.reduce(function(h,g){return h*g});if(0===te)return[];if(te!==g.length)throw Error("["+h+"] does not match the input size.");return function t(h,g,te){var tr=[];if(1===g.length)for(var to=g[0],tu=0;tu<to;tu++)tr[tu]=te[h+tu];else{to=g[0];var tc=g.slice(1),tl=tc.reduce(function(h,g){return h*g});for(tu=0;tu<to;tu++)tr[tu]=t(h+tu*tl,tc,te)}return tr}(0,h,g)}function Z(h,g){for(var te=tt(h,g),tr=0;tr<te.length;tr++)te[tr]=1;return te}function tt(h,g){if(null==g||"float32"===g||"complex64"===g)return new Float32Array(h);if("int32"===g)return new Int32Array(h);if("bool"===g)return new Uint8Array(h);throw Error("Unknown data type "+g)}function et(){return tl.platform.now()}function nt(h){h.forEach(function(g){C(Number.isInteger(g)&&g>=0,function(){return"Tensor must have a shape comprised of positive integers but got shape ["+h+"]."})})}function rt(h,g){return void 0===g&&(g="utf-8"),g=g||"utf-8",tl.platform.encode(h,g)}function ot(h,g){return void 0===g&&(g="utf-8"),g=g||"utf-8",tl.platform.decode(h,g)}function at(h,g,te){if(0===g)return 0;if(1===g)return h[0];for(var tr=h[h.length-1],to=0;to<h.length-1;++to)tr+=te[to]*h[to];return tr}function it(h,g,te){if(0===g)return[];if(1===g)return[h];for(var tr=Array(g),to=0;to<tr.length-1;++to)tr[to]=Math.floor(h/te[to]),h-=tr[to]*te[to];return tr[tr.length-1]=h,tr}Object.freeze({shuffle:y,clamp:x,nearestLargerEven:b,sum:w,randUniform:function(h,g){var te=Math.random();return g*te+(1-te)*h},distSquared:function(h,g){for(var te=0,tr=0;tr<h.length;tr++){var to=Number(h[tr])-Number(g[tr]);te+=to*to}return te},assert:C,assertShapesMatch:E,assertNonNull:R,flatten:I,sizeFromShape:k,isScalarShape:function(h){return 0===h.length},arraysEqual:S,isInt:A,tanh:D,sizeToSquarishShape:T,createShuffledIndices:function(h){for(var g=new Uint32Array(h),te=0;te<h;++te)g[te]=te;return y(g),g},rightPad:N,repeatedTry:F,inferFromImplicitShape:_,parseAxisParam:O,squeezeShape:M,getTypedArrayFromDType:B,getArrayFromDType:P,checkConversionForErrors:L,isValidDtype:W,hasEncodingLoss:U,isTypedArray:V,bytesPerElement:z,bytesFromStringArray:G,isString:H,isBoolean:q,isNumber:K,inferDtype:j,isFunction:X,nearestDivisor:Y,computeStrides:$,toTypedArray:Q,toNestedArray:J,makeOnesTypedArray:Z,makeZerosTypedArray:tt,now:et,assertNonNegativeIntegerDimensions:nt,fetch:function(h,g){return tl.platform.fetch(h,g)},encodeString:rt,decodeString:ot,locToIndex:at,indexToLoc:it});var tf=function(){function t(h,g){this.backendTimer=h,this.logger=g,null==g&&(this.logger=new tp)}return t.prototype.profileKernel=function(h,g,te){var tr,to=this,tu=this.backendTimer.time(function(){tr=te()});return tr.forEach(function(te){te.data().then(function(tr){(function(h,g,te){if("float32"===g)for(var tr=0;tr<h.length;tr++){var to=h[tr];if(isNaN(to)||!isFinite(to))return console.warn("Found "+to+" in the result of '"+te+"'"),!0}})(tr,te.dtype,h),tu.then(function(tu){var tc="";null!=tu.getExtraProfileInfo&&(tc=tu.getExtraProfileInfo()),to.logger.logKernelProfile(h,te,tr,tu.kernelMs,g,tc)})})}),tr},t}(),tp=function(){function t(){}return t.prototype.logKernelProfile=function(h,g,te,tr,to,tu){var tc="number"==typeof tr?N(tr+"ms",9):tr.error,tl=N(h,25),th=g.rank,td=g.size,tf=N(g.shape.toString(),14),tp="";for(var tv in to){var tm=to[tv].shape||g.shape,tg=tm.length;tp+=tv+": "+tg+"D "+(tg>0?tm:"")+" "}console.log("%c"+tl+"	%c"+tc+"	%c"+th+"D "+tf+"	%c"+td+"	%c"+tp+"	%c"+tu,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")},t}();function pt(h,g,te){return N(Array.isArray(h)?parseFloat(h[0].toFixed(7))+" + "+parseFloat(h[1].toFixed(7))+"j":H(h)?"'"+h+"'":"bool"===te?vt(h):parseFloat(h.toFixed(7)).toString(),g)}function vt(h){return 0===h?"false":"true"}function mt(h){for(var g=[],te=0;te<h.length;te+=2)g.push([h[te],h[te+1]]);return g}var tv=function(){function t(h,g,te){var tr=this;if(this.dtype=g,this.shape=h.slice(),this.size=k(h),null!=te){var to=te.length;C(to===this.size,function(){return"Length of values '"+to+"' does not match the size inferred by the shape '"+tr.size+"'."})}if("complex64"===g)throw Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=te||P(g,this.size),this.strides=$(h)}return t.prototype.set=function(h){for(var g=this,te=[],tr=1;tr<arguments.length;tr++)te[tr-1]=arguments[tr];0===te.length&&(te=[0]),C(te.length===this.rank,function(){return"The number of provided coordinates ("+te.length+") must match the rank ("+g.rank+")"});var to=this.locToIndex(te);this.values[to]=h},t.prototype.get=function(){for(var h=[],g=0;g<arguments.length;g++)h[g]=arguments[g];0===h.length&&(h=[0]);for(var te=0,tr=0,to=h;tr<to.length;tr++){var tu=to[tr];if(tu<0||tu>=this.shape[te])throw Error("Requested out of range element at "+h+".   Buffer shape="+this.shape);te++}for(var tc=h[h.length-1],tl=0;tl<h.length-1;++tl)tc+=this.strides[tl]*h[tl];return this.values[tc]},t.prototype.locToIndex=function(h){if(0===this.rank)return 0;if(1===this.rank)return h[0];for(var g=h[h.length-1],te=0;te<h.length-1;++te)g+=this.strides[te]*h[te];return g},t.prototype.indexToLoc=function(h){if(0===this.rank)return[];if(1===this.rank)return[h];for(var g=Array(this.shape.length),te=0;te<g.length-1;++te)g[te]=Math.floor(h/this.strides[te]),h-=g[te]*this.strides[te];return g[g.length-1]=h,g},Object.defineProperty(t.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),t.prototype.toTensor=function(){return tm().makeTensor(this.values,this.shape,this.dtype)},t}(),tm=null,tg=null,ty=null,tx=function(){function t(h,g,te,tr){this.kept=!1,this.isDisposedInternal=!1,this.shape=h.slice(),this.dtype=g||"float32",this.size=k(h),this.strides=$(h),this.dataId=te,this.id=tr,this.rankType=this.rank<5?this.rank.toString():"higher"}return t.prototype.flatten=function(){return this.throwIfDisposed(),this.as1D()},t.prototype.asScalar=function(){return this.throwIfDisposed(),C(1===this.size,function(){return"The array must have only 1 element."}),this.reshape([])},t.prototype.as1D=function(){return this.throwIfDisposed(),this.reshape([this.size])},t.prototype.as2D=function(h,g){return this.throwIfDisposed(),this.reshape([h,g])},t.prototype.as3D=function(h,g,te){return this.throwIfDisposed(),this.reshape([h,g,te])},t.prototype.as4D=function(h,g,te,tr){return this.throwIfDisposed(),this.reshape([h,g,te,tr])},t.prototype.as5D=function(h,g,te,tr,to){return this.throwIfDisposed(),this.reshape([h,g,te,tr,to])},t.prototype.asType=function(h){return this.throwIfDisposed(),tg.cast(this,h)},Object.defineProperty(t.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),t.prototype.buffer=function(){return n(this,void 0,void 0,function(){var h;return r(this,function(g){switch(g.label){case 0:return[4,this.data()];case 1:return h=g.sent(),[2,tg.buffer(this.shape,this.dtype,h)]}})})},t.prototype.bufferSync=function(){return tg.buffer(this.shape,this.dtype,this.dataSync())},t.prototype.array=function(){return n(this,void 0,void 0,function(){var h;return r(this,function(g){switch(g.label){case 0:return[4,this.data()];case 1:return h=g.sent(),[2,J(this.shape,h)]}})})},t.prototype.arraySync=function(){return J(this.shape,this.dataSync())},t.prototype.data=function(){return n(this,void 0,void 0,function(){var h,g;return r(this,function(te){switch(te.label){case 0:return this.throwIfDisposed(),h=tm().read(this.dataId),"string"!==this.dtype?[3,2]:[4,h];case 1:g=te.sent();try{return[2,g.map(function(h){return ot(h)})]}catch(h){throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}te.label=2;case 2:return[2,h]}})})},t.prototype.dataSync=function(){this.throwIfDisposed();var h=tm().readSync(this.dataId);if("string"===this.dtype)try{return h.map(function(h){return ot(h)})}catch(h){throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return h},t.prototype.bytes=function(){return n(this,void 0,void 0,function(){var h;return r(this,function(g){switch(g.label){case 0:return this.throwIfDisposed(),[4,tm().read(this.dataId)];case 1:return h=g.sent(),"string"===this.dtype?[2,h]:[2,new Uint8Array(h.buffer)]}})})},t.prototype.dispose=function(){this.isDisposed||(tm().disposeTensor(this),this.isDisposedInternal=!0)},Object.defineProperty(t.prototype,"isDisposed",{get:function(){return this.isDisposedInternal},enumerable:!0,configurable:!0}),t.prototype.throwIfDisposed=function(){if(this.isDisposed)throw Error("Tensor is disposed.")},t.prototype.toFloat=function(){return this.asType("float32")},t.prototype.toInt=function(){return this.asType("int32")},t.prototype.toBool=function(){return this.asType("bool")},t.prototype.print=function(h){return void 0===h&&(h=!1),tg.print(this,h)},t.prototype.reshape=function(h){return this.throwIfDisposed(),tg.reshape(this,h)},t.prototype.reshapeAs=function(h){return this.throwIfDisposed(),this.reshape(h.shape)},t.prototype.expandDims=function(h){return void 0===h&&(h=0),tg.expandDims(this,h)},t.prototype.cumsum=function(h,g,te){return void 0===h&&(h=0),void 0===g&&(g=!1),void 0===te&&(te=!1),tg.cumsum(this,h,g,te)},t.prototype.squeeze=function(h){return this.throwIfDisposed(),tg.squeeze(this,h)},t.prototype.clone=function(){return this.throwIfDisposed(),tg.clone(this)},t.prototype.oneHot=function(h,g,te){return this.throwIfDisposed(),tg.oneHot(this,h,g,te)},t.prototype.toString=function(h){var g,te,tr,to,tu,tc,tl,th,td;return void 0===h&&(h=!1),g=this.dataSync(),te=this.shape,tr=this.dtype,to=h,tu=$(te),tc=function(h,g,te,tr){var to=k(g),tu=tr[tr.length-1],tc=Array(tu).fill(0),tl=g.length,th="complex64"===te?mt(h):h;if(tl>1)for(var td=0;td<to/tu;td++)for(var tf=td*tu,tp=0;tp<tu;tp++)tc[tp]=Math.max(tc[tp],pt(th[tf+tp],0,te).length);return tc}(g,te,tr,tu),tl=te.length,th=function t(h,g,te,tr,to,tu){void 0===tu&&(tu=!0);var tc,tl="complex64"===te?2:1,th=g[0],td=g.length;if(0===td)return"complex64"===te?[pt(mt(h)[0],0,te)]:"bool"===te?[vt(h[0])]:[h[0].toString()];if(1===td){if(th>20){var tf=3*tl,tp=Array.from(h.slice(0,tf)),tv=Array.from(h.slice((th-3)*tl,th*tl));return"complex64"===te&&(tp=mt(tp),tv=mt(tv)),["["+tp.map(function(h,g){return pt(h,to[g],te)}).join(", ")+", ..., "+tv.map(function(h,g){return pt(h,to[th-3+g],te)}).join(", ")+"]"]}return["["+("complex64"===te?mt(h):Array.from(h)).map(function(h,g){return pt(h,to[g],te)}).join(", ")+"]"]}var tm=g.slice(1),tg=tr.slice(1),ty=tr[0]*tl,tx=[];if(th>20){for(var tb=0;tb<3;tb++){var tC=(tc=tb*ty)+ty;tx.push.apply(tx,t(h.slice(tc,tC),tm,te,tg,to,!1))}for(tx.push("..."),tb=th-3;tb<th;tb++)tC=(tc=tb*ty)+ty,tx.push.apply(tx,t(h.slice(tc,tC),tm,te,tg,to,tb===th-1))}else for(tb=0;tb<th;tb++)tC=(tc=tb*ty)+ty,tx.push.apply(tx,t(h.slice(tc,tC),tm,te,tg,to,tb===th-1));var tw=2===td?",":"";for(tb=1,tx[0]="["+tx[0]+tw;tb<tx.length-1;tb++)tx[tb]=" "+tx[tb]+tw;var tE=",\n";for(tb=2;tb<td;tb++)tE+="\n";return tx[tx.length-1]=" "+tx[tx.length-1]+"]"+(tu?"":tE),tx}(g,te,tr,tu,tc),td=["Tensor"],to&&(td.push("  dtype: "+tr),td.push("  rank: "+tl),td.push("  shape: ["+te+"]"),td.push("  values:")),td.push(th.map(function(h){return"    "+h}).join("\n")),td.join("\n")},t.prototype.tile=function(h){return this.throwIfDisposed(),tg.tile(this,h)},t.prototype.gather=function(h,g){return void 0===g&&(g=0),this.throwIfDisposed(),tg.gather(this,h,g)},t.prototype.matMul=function(h,g,te){return void 0===g&&(g=!1),void 0===te&&(te=!1),this.throwIfDisposed(),tg.matMul(this,h,g,te)},t.prototype.dot=function(h){return this.throwIfDisposed(),tg.dot(this,h)},t.prototype.norm=function(h,g,te){return void 0===h&&(h="euclidean"),void 0===g&&(g=null),void 0===te&&(te=!1),this.throwIfDisposed(),tg.norm(this,h,g,te)},t.prototype.slice=function(h,g){return this.throwIfDisposed(),tg.slice(this,h,g)},t.prototype.reverse=function(h){return this.throwIfDisposed(),tg.reverse(this,h)},t.prototype.concat=function(h,g){return void 0===g&&(g=0),this.throwIfDisposed(),h instanceof t&&(h=[h]),tg.concat([this].concat(h),g)},t.prototype.split=function(h,g){return void 0===g&&(g=0),this.throwIfDisposed(),tg.split(this,h,g)},t.prototype.stack=function(h,g){return void 0===g&&(g=0),tg.stack([this,h],g)},t.prototype.unstack=function(h){return void 0===h&&(h=0),tg.unstack(this,h)},t.prototype.pad=function(h,g){return void 0===g&&(g=0),tg.pad(this,h,g)},t.prototype.batchNormalization=function(h,g,te,tr,to){return void 0===te&&(te=.001),ty("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"),this.batchNorm(h,g,to,tr,te)},t.prototype.batchNorm=function(h,g,te,tr,to){return void 0===to&&(to=.001),this.throwIfDisposed(),tg.batchNorm(this,h,g,te,tr,to)},t.prototype.all=function(h,g){return void 0===h&&(h=null),void 0===g&&(g=!1),this.throwIfDisposed(),tg.all(this,h,g)},t.prototype.any=function(h,g){return void 0===h&&(h=null),void 0===g&&(g=!1),this.throwIfDisposed(),tg.any(this,h,g)},t.prototype.logSumExp=function(h,g){return void 0===h&&(h=null),void 0===g&&(g=!1),this.throwIfDisposed(),tg.logSumExp(this,h,g)},t.prototype.sum=function(h,g){return void 0===h&&(h=null),void 0===g&&(g=!1),this.throwIfDisposed(),tg.sum(this,h,g)},t.prototype.prod=function(h,g){return void 0===h&&(h=null),void 0===g&&(g=!1),this.throwIfDisposed(),tg.prod(this,h,g)},t.prototype.mean=function(h,g){return void 0===h&&(h=null),void 0===g&&(g=!1),this.throwIfDisposed(),tg.mean(this,h,g)},t.prototype.min=function(h,g){return void 0===h&&(h=null),void 0===g&&(g=!1),this.throwIfDisposed(),tg.min(this,h,g)},t.prototype.max=function(h,g){return void 0===h&&(h=null),void 0===g&&(g=!1),this.throwIfDisposed(),tg.max(this,h,g)},t.prototype.argMin=function(h){return void 0===h&&(h=null),this.throwIfDisposed(),tg.argMin(this,h)},t.prototype.argMax=function(h){return void 0===h&&(h=null),this.throwIfDisposed(),tg.argMax(this,h)},t.prototype.cast=function(h){return this.throwIfDisposed(),tg.cast(this,h)},t.prototype.add=function(h){return this.throwIfDisposed(),tg.add(this,h)},t.prototype.addStrict=function(h){return this.throwIfDisposed(),tg.addStrict(this,h)},t.prototype.atan2=function(h){return this.throwIfDisposed(),tg.atan2(this,h)},t.prototype.sub=function(h){return this.throwIfDisposed(),tg.sub(this,h)},t.prototype.subStrict=function(h){return this.throwIfDisposed(),tg.subStrict(this,h)},t.prototype.pow=function(h){return this.throwIfDisposed(),tg.pow(this,h)},t.prototype.powStrict=function(h){return this.throwIfDisposed(),tg.powStrict(this,h)},t.prototype.mul=function(h){return this.throwIfDisposed(),tg.mul(this,h)},t.prototype.mulStrict=function(h){return this.throwIfDisposed(),tg.mulStrict(this,h)},t.prototype.div=function(h){return this.throwIfDisposed(),tg.div(this,h)},t.prototype.divNoNan=function(h){return this.throwIfDisposed(),tg.divNoNan(this,h)},t.prototype.floorDiv=function(h){return this.throwIfDisposed(),tg.floorDiv(this,h)},t.prototype.divStrict=function(h){return this.throwIfDisposed(),tg.divStrict(this,h)},t.prototype.minimum=function(h){return this.throwIfDisposed(),tg.minimum(this,h)},t.prototype.minimumStrict=function(h){return this.throwIfDisposed(),tg.minimumStrict(this,h)},t.prototype.maximum=function(h){return this.throwIfDisposed(),tg.maximum(this,h)},t.prototype.maximumStrict=function(h){return this.throwIfDisposed(),tg.maximumStrict(this,h)},t.prototype.mod=function(h){return this.throwIfDisposed(),tg.mod(this,h)},t.prototype.modStrict=function(h){return this.throwIfDisposed(),tg.modStrict(this,h)},t.prototype.squaredDifferenceStrict=function(h){return this.throwIfDisposed(),tg.squaredDifferenceStrict(this,h)},t.prototype.transpose=function(h){return this.throwIfDisposed(),tg.transpose(this,h)},t.prototype.notEqual=function(h){return this.throwIfDisposed(),tg.notEqual(this,h)},t.prototype.notEqualStrict=function(h){return this.throwIfDisposed(),tg.notEqualStrict(this,h)},t.prototype.less=function(h){return this.throwIfDisposed(),tg.less(this,h)},t.prototype.lessStrict=function(h){return this.throwIfDisposed(),tg.lessStrict(this,h)},t.prototype.equal=function(h){return this.throwIfDisposed(),tg.equal(this,h)},t.prototype.equalStrict=function(h){return this.throwIfDisposed(),tg.equalStrict(this,h)},t.prototype.lessEqual=function(h){return this.throwIfDisposed(),tg.lessEqual(this,h)},t.prototype.lessEqualStrict=function(h){return this.throwIfDisposed(),tg.lessEqualStrict(this,h)},t.prototype.greater=function(h){return this.throwIfDisposed(),tg.greater(this,h)},t.prototype.greaterStrict=function(h){return this.throwIfDisposed(),tg.greaterStrict(this,h)},t.prototype.greaterEqual=function(h){return this.throwIfDisposed(),tg.greaterEqual(this,h)},t.prototype.greaterEqualStrict=function(h){return this.throwIfDisposed(),tg.greaterEqualStrict(this,h)},t.prototype.logicalAnd=function(h){return this.throwIfDisposed(),tg.logicalAnd(this,h)},t.prototype.logicalOr=function(h){return this.throwIfDisposed(),tg.logicalOr(this,h)},t.prototype.logicalNot=function(){return this.throwIfDisposed(),tg.logicalNot(this)},t.prototype.logicalXor=function(h){return this.throwIfDisposed(),tg.logicalXor(this,h)},t.prototype.where=function(h,g){return this.throwIfDisposed(),tg.where(h,this,g)},t.prototype.neg=function(){return this.throwIfDisposed(),tg.neg(this)},t.prototype.ceil=function(){return this.throwIfDisposed(),tg.ceil(this)},t.prototype.floor=function(){return this.throwIfDisposed(),tg.floor(this)},t.prototype.sign=function(){return this.throwIfDisposed(),tg.sign(this)},t.prototype.isNaN=function(){return this.throwIfDisposed(),tg.isNaN(this)},t.prototype.isInf=function(){return this.throwIfDisposed(),tg.isInf(this)},t.prototype.isFinite=function(){return this.throwIfDisposed(),tg.isFinite(this)},t.prototype.exp=function(){return this.throwIfDisposed(),tg.exp(this)},t.prototype.expm1=function(){return this.throwIfDisposed(),tg.expm1(this)},t.prototype.log=function(){return this.throwIfDisposed(),tg.log(this)},t.prototype.log1p=function(){return this.throwIfDisposed(),tg.log1p(this)},t.prototype.sqrt=function(){return this.throwIfDisposed(),tg.sqrt(this)},t.prototype.rsqrt=function(){return this.throwIfDisposed(),tg.rsqrt(this)},t.prototype.square=function(){return this.throwIfDisposed(),tg.square(this)},t.prototype.reciprocal=function(){return this.throwIfDisposed(),tg.reciprocal(this)},t.prototype.abs=function(){return this.throwIfDisposed(),tg.abs(this)},t.prototype.clipByValue=function(h,g){return this.throwIfDisposed(),tg.clipByValue(this,h,g)},t.prototype.relu=function(){return this.throwIfDisposed(),tg.relu(this)},t.prototype.relu6=function(){return this.throwIfDisposed(),tg.relu6(this)},t.prototype.elu=function(){return this.throwIfDisposed(),tg.elu(this)},t.prototype.selu=function(){return this.throwIfDisposed(),tg.selu(this)},t.prototype.leakyRelu=function(h){return void 0===h&&(h=.2),this.throwIfDisposed(),tg.leakyRelu(this,h)},t.prototype.prelu=function(h){return this.throwIfDisposed(),tg.prelu(this,h)},t.prototype.sigmoid=function(){return this.throwIfDisposed(),tg.sigmoid(this)},t.prototype.logSigmoid=function(){return this.throwIfDisposed(),tg.logSigmoid(this)},t.prototype.softplus=function(){return this.throwIfDisposed(),tg.softplus(this)},t.prototype.zerosLike=function(){return this.throwIfDisposed(),tg.zerosLike(this)},t.prototype.onesLike=function(){return this.throwIfDisposed(),tg.onesLike(this)},t.prototype.sin=function(){return this.throwIfDisposed(),tg.sin(this)},t.prototype.cos=function(){return this.throwIfDisposed(),tg.cos(this)},t.prototype.tan=function(){return this.throwIfDisposed(),tg.tan(this)},t.prototype.asin=function(){return this.throwIfDisposed(),tg.asin(this)},t.prototype.acos=function(){return this.throwIfDisposed(),tg.acos(this)},t.prototype.atan=function(){return this.throwIfDisposed(),tg.atan(this)},t.prototype.sinh=function(){return this.throwIfDisposed(),tg.sinh(this)},t.prototype.cosh=function(){return this.throwIfDisposed(),tg.cosh(this)},t.prototype.tanh=function(){return this.throwIfDisposed(),tg.tanh(this)},t.prototype.asinh=function(){return this.throwIfDisposed(),tg.asinh(this)},t.prototype.acosh=function(){return this.throwIfDisposed(),tg.acosh(this)},t.prototype.atanh=function(){return this.throwIfDisposed(),tg.atanh(this)},t.prototype.erf=function(){return this.throwIfDisposed(),tg.erf(this)},t.prototype.round=function(){return this.throwIfDisposed(),tg.round(this)},t.prototype.step=function(h){return void 0===h&&(h=0),this.throwIfDisposed(),tg.step(this,h)},t.prototype.softmax=function(h){return void 0===h&&(h=-1),this.throwIfDisposed(),tg.softmax(this,h)},t.prototype.logSoftmax=function(h){return void 0===h&&(h=-1),this.throwIfDisposed(),tg.logSoftmax(this,h)},t.prototype.resizeBilinear=function(h,g){return void 0===g&&(g=!1),this.throwIfDisposed(),tg.image.resizeBilinear(this,h,g)},t.prototype.resizeNearestNeighbor=function(h,g){return void 0===g&&(g=!1),this.throwIfDisposed(),tg.image.resizeNearestNeighbor(this,h,g)},t.prototype.conv1d=function(h,g,te,tr,to,tu){return void 0===tr&&(tr="NWC"),void 0===to&&(to=1),this.throwIfDisposed(),tg.conv1d(this,h,g,te,tr,to,tu)},t.prototype.conv2d=function(h,g,te,tr,to,tu){return void 0===tr&&(tr="NHWC"),void 0===to&&(to=[1,1]),this.throwIfDisposed(),tg.conv2d(this,h,g,te,tr,to,tu)},t.prototype.conv2dTranspose=function(h,g,te,tr,to){return this.throwIfDisposed(),tg.conv2dTranspose(this,h,g,te,tr,to)},t.prototype.depthwiseConv2D=function(h,g,te,tr,to,tu){return void 0===tr&&(tr="NHWC"),void 0===to&&(to=[1,1]),this.throwIfDisposed(),tg.depthwiseConv2d(this,h,g,te,tr,to,tu)},t.prototype.separableConv2d=function(h,g,te,tr,to,tu){return void 0===to&&(to=[1,1]),void 0===tu&&(tu="NHWC"),this.throwIfDisposed(),tg.separableConv2d(this,h,g,te,tr,to,tu)},t.prototype.avgPool=function(h,g,te,tr){return this.throwIfDisposed(),tg.avgPool(this,h,g,te,tr)},t.prototype.maxPool=function(h,g,te,tr){return this.throwIfDisposed(),tg.maxPool(this,h,g,te,tr)},t.prototype.localResponseNormalization=function(h,g,te,tr){return void 0===h&&(h=5),void 0===g&&(g=1),void 0===te&&(te=1),void 0===tr&&(tr=.5),tg.localResponseNormalization(this,h,g,te,tr)},t.prototype.pool=function(h,g,te,tr,to){return this.throwIfDisposed(),tg.pool(this,h,g,te,tr,to)},t.prototype.variable=function(h,g,te){return void 0===h&&(h=!0),this.throwIfDisposed(),tm().makeVariable(this,h,g,te)},t.prototype.unsortedSegmentSum=function(h,g){return this.throwIfDisposed(),tg.unsortedSegmentSum(this,h,g)},t.prototype.batchToSpaceND=function(h,g){return this.throwIfDisposed(),tg.batchToSpaceND(this,h,g)},t.prototype.spaceToBatchND=function(h,g){return this.throwIfDisposed(),tg.spaceToBatchND(this,h,g)},t.prototype.topk=function(h,g){return void 0===h&&(h=1),void 0===g&&(g=!0),this.throwIfDisposed(),tg.topk(this,h,g)},t.prototype.stridedSlice=function(h,g,te,tr,to,tu,tc,tl){return void 0===tr&&(tr=0),void 0===to&&(to=0),void 0===tu&&(tu=0),void 0===tc&&(tc=0),void 0===tl&&(tl=0),this.throwIfDisposed(),tg.stridedSlice(this,h,g,te,tr,to,tu,tc,tl)},t.prototype.depthToSpace=function(h,g){return this.throwIfDisposed(),tg.depthToSpace(this,h,g)},t.prototype.fft=function(){return this.throwIfDisposed(),tg.spectral.fft(this)},t.prototype.ifft=function(){return this.throwIfDisposed(),tg.spectral.ifft(this)},t.prototype.rfft=function(){return this.throwIfDisposed(),tg.spectral.rfft(this)},t.prototype.irfft=function(){return this.throwIfDisposed(),tg.spectral.irfft(this)},t}();Object.defineProperty(tx,Symbol.hasInstance,{value:function(h){return!!h&&null!=h.dataId&&null!=h.shape&&null!=h.dtype}});var tb,tC,tw,tE,tR,tI=function(h){function n(g,te,tr,to){var tu=h.call(this,g.shape,g.dtype,g.dataId,to)||this;return tu.trainable=te,tu.name=tr,tu}return e(n,h),n.prototype.assign=function(h){if(h.dtype!==this.dtype)throw Error("dtype of the new value ("+h.dtype+") and previous value ("+this.dtype+") must match");if(!S(h.shape,this.shape))throw Error("shape of the new value ("+h.shape+") and previous value ("+this.shape+") must match");tm().disposeTensor(this),this.dataId=h.dataId,tm().incRef(this,null)},n.prototype.dispose=function(){tm().disposeVariable(this),this.isDisposedInternal=!0},n}(tx);Object.defineProperty(tI,Symbol.hasInstance,{value:function(h){return h instanceof tx&&null!=h.assign&&h.assign instanceof Function}}),(tA=tb||(tb={})).R0="R0",tA.R1="R1",tA.R2="R2",tA.R3="R3",tA.R4="R4",tA.R5="R5",tA.R6="R6",(tS=tC||(tC={})).float32="float32",tS.int32="int32",tS.bool="int32",tS.complex64="complex64",(tD=tw||(tw={})).float32="float32",tD.int32="int32",tD.bool="bool",tD.complex64="complex64",(tN=tE||(tE={})).float32="float32",tN.int32="float32",tN.bool="float32",tN.complex64="complex64",(tT=tR||(tR={})).float32="complex64",tT.int32="complex64",tT.bool="complex64",tT.complex64="complex64";var tk={float32:tE,int32:tC,bool:tw,complex64:tR};function Dt(h,g){if("string"===h||"string"===g){if("string"===h&&"string"===g)return"string";throw Error("Can not upcast "+h+" with "+g)}return tk[h][g]}function Tt(h){return Dt(h,"int32")}function Nt(h,g){if(h.dtype===g.dtype)return[h,g];var te=Dt(h.dtype,g.dtype);return[h.cast(te),g.cast(te)]}function Ft(h,g){C(h.dtype===g.dtype,function(){return"The dtypes of the first("+h.dtype+") and second("+g.dtype+") input must match"})}function _t(h){var g=[];return function t(h,g,te){if(null!=h){if(h instanceof tx)return void g.push(h);if(Array.isArray(h)||"object"==typeof h)for(var tr in h){var to=h[tr];te.has(to)||(te.add(to),t(to,g,te))}}}(h,g,new Set),g}Object.freeze({makeTypesMatch:Nt,assertTypesMatch:Ft,isTensorInList:function(h,g){return g.some(function(g){return g.id===h.id})},getTensorsInContainer:_t});var tA,tS,tD,tN,tT,tF,tO=function(){function t(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}return t.prototype.dispose=function(){for(var h in this.registeredVariables)this.registeredVariables[h].dispose()},t}(),t_=function(){function t(h){this.ENV=h,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new tO}return t.prototype.ready=function(){return n(this,void 0,void 0,function(){var h,g,te;return r(this,function(tr){switch(tr.label){case 0:if(null!=this.pendingBackendInit)return[2,this.pendingBackendInit.then(function(){})];if(null!=this.backendInstance)return[2];h=this.getSortedBackends(),g=0,tr.label=1;case 1:return g<h.length?(te=h[g],[4,this.initializeBackend(te).success]):[3,5];case 2:return tr.sent()?[4,this.setBackend(te)]:[3,4];case 3:return tr.sent(),[2];case 4:return g++,[3,1];case 5:throw Error("Could not initialize any backends, all backend initializations failed.")}})})},Object.defineProperty(t.prototype,"backend",{get:function(){if(null!=this.pendingBackendInit)throw Error("Backend '"+this.backendName+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){var h=this.initializeBackendsAndReturnBest(),g=h.name;if(h.asyncInit)throw Error("The highest priority backend '"+g+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(g)}return this.backendInstance},enumerable:!0,configurable:!0}),t.prototype.backendNames=function(){return Object.keys(this.registryFactory)},t.prototype.findBackend=function(h){return h in this.registry||h in this.registryFactory&&!this.initializeBackend(h).asyncInit?this.registry[h]:null},t.prototype.findBackendFactory=function(h){return h in this.registryFactory?this.registryFactory[h].factory:null},t.prototype.registerBackend=function(h,g,te){return void 0===te&&(te=1),h in this.registryFactory?(console.warn(h+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[h]={factory:g,priority:te},!0)},t.prototype.setBackend=function(h){return n(this,void 0,void 0,function(){var g,te,tr;return r(this,function(to){switch(to.label){case 0:if(null==this.registryFactory[h])throw Error("Backend name '"+h+"' not found in registry");return this.backendName=h,null!=this.registry[h]?[3,4]:(this.backendInstance=null,te=(g=this.initializeBackend(h)).success,g.asyncInit?[4,te]:[3,2]);case 1:return tr=to.sent(),[3,3];case 2:tr=te,to.label=3;case 3:if(!tr)return[2,!1];to.label=4;case 4:return this.backendInstance=this.registry[h],this.setupRegisteredKernels(),this.profiler=new tf(this.backendInstance),[2,!0]}})})},t.prototype.setupRegisteredKernels=function(){var h=this;f(this.backendName).forEach(function(g){null!=g.setupFunc&&g.setupFunc(h.backendInstance)})},t.prototype.disposeRegisteredKernels=function(h){var g=this;f(h).forEach(function(te){null!=te.disposeFunc&&te.disposeFunc(g.registry[h])})},t.prototype.initializeBackend=function(h){var g=this,te=this.registryFactory[h];if(null==te)throw Error("Cannot initialize backend "+h+", no registration found.");try{var tr=te.factory();if(Promise.resolve(tr)===tr){var to=++this.pendingBackendInitId,tu=tr.then(function(te){return!(to<g.pendingBackendInitId)&&(g.registry[h]=te,g.pendingBackendInit=null,!0)}).catch(function(te){return!(to<g.pendingBackendInitId)&&(g.pendingBackendInit=null,console.warn("Initialization of backend "+h+" failed"),console.warn(te.stack||te.message),!1)});return this.pendingBackendInit=tu,{success:tu,asyncInit:!0}}return this.registry[h]=tr,{success:!0,asyncInit:!1}}catch(g){return console.warn("Initialization of backend "+h+" failed"),console.warn(g.stack||g.message),{success:!1,asyncInit:!1}}},t.prototype.removeBackend=function(h){if(!(h in this.registryFactory))throw Error(h+" backend not found in registry");this.backendName===h&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,h in this.registry&&(this.disposeRegisteredKernels(h),this.registry[h].dispose(),delete this.registry[h]),delete this.registryFactory[h],this.backendName===h&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)},t.prototype.getSortedBackends=function(){var h=this;if(0===Object.keys(this.registryFactory).length)throw Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(function(g,te){return h.registryFactory[te].priority-h.registryFactory[g].priority})},t.prototype.initializeBackendsAndReturnBest=function(){for(var h=this.getSortedBackends(),g=0;g<h.length;g++){var te=h[g],tr=this.initializeBackend(te),to=tr.success,tu=tr.asyncInit;if(tu||to)return{name:te,asyncInit:tu}}throw Error("Could not initialize any backends, all backend initializations failed.")},t.prototype.moveData=function(h,g){var te=this.state.tensorInfo.get(g),tr=te.backend,to=this.readSync(g);tr.disposeData(g),te.backend=h,h.move(g,to,te.shape,te.dtype),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++},t.prototype.tidy=function(h,g){var te,tr=this,to=null;if(null==g){if("function"!=typeof h)throw Error("Please provide a function to tidy()");g=h}else{if("string"!=typeof h&&!(h instanceof String))throw Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof g)throw Error("When calling with two arguments, the 2nd argument to tidy() must be a function");to=h}return this.scopedRun(function(){return tr.startScope(to)},function(){return tr.endScope(te)},function(){return(te=g())instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),te})},t.prototype.scopedRun=function(h,g,te){h();try{var tr=te();return g(),tr}catch(h){throw g(),h}},t.prototype.nextTensorId=function(){return t.nextTensorId++},t.prototype.nextVariableId=function(){return t.nextVariableId++},t.prototype.clone=function(h){var g=this.makeTensorFromDataId(h.dataId,h.shape,h.dtype);return this.addTapeNode(this.state.activeScope.name,{x:h},[g],function(h){return{x:function(){return h.toFloat()}}},[]),g},t.prototype.runKernel=function(h,g,te,tr,to){return this.runKernelFunc(null,g,null,h,te,tr,to)},t.prototype.shouldCheckForMemLeaks=function(){return this.ENV.getBool("IS_TEST")},t.prototype.checkKernelForMemLeak=function(h,g,te){var tr=this.backend.numDataIds(),to=0;te.forEach(function(h){to+="complex64"===h.dtype?3:1});var tu=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],tc=tr-g-to-tu;if(tc>0)throw Error("Backend '"+this.backendName+"' has an internal memory leak ("+tc+" data ids) after running '"+h+"'")},t.prototype.runKernelFunc=function(h,g,te,tr,to,tu,tc){var tl,th=this;void 0===tu&&(tu=[]),void 0===tc&&(tc=[]);var td=[],tf=this.isTapeOn();null==tr&&(tr=null!=this.state.activeScope?this.state.activeScope.name:"");var tp,d=function(h){tf&&(td=h.map(function(h){return th.keep(th.clone(h))}))},tv=this.state.numBytes,tm=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);var tg,ty=l(tr,this.backendName);return tp=null!=ty?function(){var h=th.backend.numDataIds(),te=Array.isArray(tg=ty.kernelFunc({inputs:g,attrs:to,backend:th.backend}))?tg:[tg];th.shouldCheckForMemLeaks()&&th.checkKernelForMemLeak(tr,h,te);var tl=te.map(function(h){var g=h.dataId,te=h.shape,tr=h.dtype;return th.makeTensorFromDataId(g,te,tr)}),td=tl.filter(function(h,g){return tc[g]});return d((tu||[]).slice().concat(td)),tl}:function(){var g=th.backend.numDataIds(),te=Array.isArray(tg=th.tidy(function(){return h(th.backend,d)}))?tg:[tg];return th.shouldCheckForMemLeaks()&&th.checkKernelForMemLeak(tr,g,te),te},this.scopedRun(function(){return th.state.kernelDepth++},function(){return th.state.kernelDepth--},function(){tl=th.ENV.getBool("DEBUG")?th.profiler.profileKernel(tr,g,function(){return tp()}):tp()}),tf&&this.addTapeNode(tr,g,tl,te,td),this.state.profiling&&this.state.activeProfile.kernels.push({name:tr,bytesAdded:this.state.numBytes-tv,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-tm,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(g).map(function(h){return g[h].shape}),outputShapes:tl.map(function(h){return h.shape})}),Array.isArray(tg)?tl:tl[0]},t.prototype.makeTensor=function(h,g,te,tr){if(null==h)throw Error("Values passed to engine.makeTensor() are null");te=te||"float32",tr=tr||this.backend;var to=h;"string"===te&&H(h[0])&&(to=h.map(function(h){return rt(h)}));var tu=tr.write(to,g,te),tc=new tx(g,te,tu,this.nextTensorId());if(this.incRef(tc,tr),"string"===te){var tl=this.state.tensorInfo.get(tu),th=G(to);this.state.numBytes+=th-tl.bytes,tl.bytes=th}return tc},t.prototype.makeTensorFromDataId=function(h,g,te,tr){var to=new tx(g,te=te||"float32",h,this.nextTensorId());return this.incRef(to,tr),to},t.prototype.makeVariable=function(h,g,te,tr){void 0===g&&(g=!0),te=te||this.nextVariableId().toString(),null!=tr&&tr!==h.dtype&&(h=h.asType(tr));var to=new tI(h,g,te,this.nextTensorId());if(null!=this.state.registeredVariables[to.name])throw Error("Variable with name "+to.name+" was already registered");return this.state.registeredVariables[to.name]=to,this.incRef(to,this.backend),to},t.prototype.incRef=function(h,g){var te=this.state.tensorInfo.has(h.dataId)?this.state.tensorInfo.get(h.dataId).refCount:0;if(this.state.numTensors++,"string"===h.dtype&&this.state.numStringTensors++,0===te){this.state.numDataBuffers++;var tr=0;"complex64"!==h.dtype&&"string"!==h.dtype&&(tr=h.size*z(h.dtype)),this.state.tensorInfo.set(h.dataId,{backend:g||this.backend,dtype:h.dtype,shape:h.shape,bytes:tr,refCount:0}),this.state.numBytes+=tr}this.state.tensorInfo.get(h.dataId).refCount++,h instanceof tI||this.track(h)},t.prototype.disposeTensor=function(h){if(this.state.tensorInfo.has(h.dataId)){this.state.numTensors--,"string"===h.dtype&&this.state.numStringTensors--;var g=this.state.tensorInfo.get(h.dataId);g.refCount<=1?("complex64"!==h.dtype&&(this.state.numBytes-=g.bytes),this.state.numDataBuffers--,g.backend.disposeData(h.dataId),this.state.tensorInfo.delete(h.dataId)):this.state.tensorInfo.get(h.dataId).refCount--}},t.prototype.disposeVariables=function(){for(var h in this.state.registeredVariables){var g=this.state.registeredVariables[h];this.disposeVariable(g)}},t.prototype.disposeVariable=function(h){this.disposeTensor(h),null!=this.state.registeredVariables[h.name]&&delete this.state.registeredVariables[h.name]},t.prototype.memory=function(){var h=this.backend.memory();return h.numTensors=this.state.numTensors,h.numDataBuffers=this.state.numDataBuffers,h.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(h.unreliable=!0,null==h.reasons&&(h.reasons=[]),h.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),h},t.prototype.profile=function(h){return n(this,void 0,void 0,function(){var g,te;return r(this,function(tr){return this.state.profiling=!0,g=this.state.numBytes,te=this.state.numTensors,this.state.activeProfile.kernels=[],this.state.activeProfile.result=h(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max.apply(Math,this.state.activeProfile.kernels.map(function(h){return h.totalBytesSnapshot})),this.state.activeProfile.newBytes=this.state.numBytes-g,this.state.activeProfile.newTensors=this.state.numTensors-te,[2,this.state.activeProfile]})})},t.prototype.isTapeOn=function(){return this.state.gradientDepth>0&&0===this.state.kernelDepth},t.prototype.addTapeNode=function(h,g,te,tr,to){var tu=this,tc={id:this.state.nextTapeNodeId++,kernelName:h,inputs:g,outputs:te,saved:to},tl=td.get(h);null!=tl&&(tr=tl.gradFunc),null!=tr&&(tc.gradient=function(h){return h=h.map(function(h,g){if(null==h){var tr=te[g],to=tt(tr.size,tr.dtype);return tu.makeTensor(to,tr.shape,tr.dtype)}return h}),tr(h.length>1?h:h[0],to)}),this.state.activeTape.push(tc)},t.prototype.keep=function(h){return h.kept=!0,h},t.prototype.startTape=function(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++},t.prototype.endTape=function(){this.state.gradientDepth--},t.prototype.startScope=function(h){var g={track:[],name:"unnamed scope",id:this.state.nextScopeId++};h&&(g.name=h),this.state.scopeStack.push(g),this.state.activeScope=g},t.prototype.endScope=function(h){for(var g=this,te=_t(h),tr=new Set(te.map(function(h){return h.id})),to=0;to<this.state.activeScope.track.length;to++){var tu=this.state.activeScope.track[to];tu.kept||tr.has(tu.id)||tu.dispose()}var tc=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],te.forEach(function(h){h.kept||h.scopeId!==tc.id||g.track(h)})},t.prototype.gradients=function(h,g,te,tr){var to=this;if(void 0===tr&&(tr=!1),C(g.length>0,function(){return"gradients() received an empty list of xs."}),null!=te&&"float32"!==te.dtype)throw Error("dy must have 'float32' dtype, but has '"+te.dtype+"'");var tu=this.scopedRun(function(){return to.startTape()},function(){return to.endTape()},function(){return to.tidy("forward",h)});C(tu instanceof tx,function(){return"The result y returned by f() must be a tensor."});var tc=function(h,g,te){for(var tr,to={},tu={},tc=0;tc<g.length;tc++)to[g[tc].id]=!0;for(tc=0;tc<h.length;tc++){var tl=(tr=h[tc]).inputs;for(var th in tl){for(var td=tl[th],tf=!1,tp=0;tp<g.length;tp++)if(to[td.id]){tr.outputs.forEach(function(h){return to[h.id]=!0}),tf=!0,tu[tr.id]=!0;break}if(tf)break}}var tv={};tv[te.id]=!0;var tm={};for(tc=h.length-1;tc>=0;tc--)for(tl=(tr=h[tc]).inputs,tp=0;tp<tr.outputs.length;tp++)if(tv[tr.outputs[tp].id]){for(var th in tl)tv[tl[th].id]=!0,tm[tr.id]=!0;break}var tg=[];for(tc=0;tc<h.length;tc++)if(tu[(tr=h[tc]).id]&&tm[tr.id]){var ty={};for(var th in tr.inputs){var tx=tr.inputs[th];to[tx.id]&&(ty[th]=tx)}var tb=Object.assign({},tr);tb.inputs=ty,tb.outputs=tr.outputs,tg.push(tb)}return tg}(this.state.activeTape,g,tu);if(!tr&&0===tc.length&&g.length>0)throw Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",function(){var h,tr,tl={};tl[tu.id]=null==te?(tr=Z(k(h=tu.shape),"float32"),tM.makeTensor(tr,h,"float32")):te,function(h,g,te){for(var tr=g.length-1;tr>=0;tr--)(function(tr){var to=g[tr],tu=[];if(to.outputs.forEach(function(g){var te=h[g.id];null!=te?tu.push(te):tu.push(null)}),null==to.gradient)throw Error("Cannot compute gradient: gradient function not found for "+to.kernelName+".");var tc=to.gradient(tu),s=function(g){if(!(g in tc))throw Error("Cannot backprop through input "+g+". Available gradients found: "+Object.keys(tc)+".");var tr=te(function(){return tc[g]()});if("float32"!==tr.dtype)throw Error("Error in gradient for op "+to.kernelName+". The gradient of input "+g+" must have 'float32' dtype, but has '"+tr.dtype+"'");var tu=to.inputs[g];if(!S(tr.shape,tu.shape))throw Error("Error in gradient for op "+to.kernelName+". The gradient of input '"+g+"' has shape '"+tr.shape+"', which does not match the shape of the input '"+tu.shape+"'");if(null==h[tu.id])h[tu.id]=tr;else{var tl=h[tu.id];h[tu.id]=tl.add(tr),tl.dispose()}};for(var tl in to.inputs)s(tl)})(tr)}(tl,tc,function(h){return to.tidy(h)});var th=g.map(function(h){return tl[h.id]});return 0===to.state.gradientDepth&&(to.state.activeTape.forEach(function(h){for(var g=0,te=h.saved;g<te.length;g++)te[g].dispose()}),to.state.activeTape=null),{value:tu,grads:th}})},t.prototype.customGrad=function(h){var g=this;return C(X(h),function(){return"The f passed in customGrad(f) must be a function."}),function(){for(var te,tr=[],to=0;to<arguments.length;to++)tr[to]=arguments[to];C(tr.every(function(h){return h instanceof tx}),function(){return"The args passed in customGrad(f)(x1, x2,...) must all be tensors"});var tu={};return tr.forEach(function(h,g){tu[g]=h}),g.runKernelFunc(function(g,to){return C((te=h.apply(void 0,tr.concat([to]))).value instanceof tx,function(){return"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"}),C(X(te.gradFunc),function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."}),te.value},tu,function(h,g){var to=te.gradFunc(h,g),tu=Array.isArray(to)?to:[to];C(tu.length===tr.length,function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."}),C(tu.every(function(h){return h instanceof tx}),function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."});var tc={};return tu.forEach(function(h,g){tc[g]=function(){return h}}),tc})}},t.prototype.readSync=function(h){return this.state.tensorInfo.get(h).backend.readSync(h)},t.prototype.read=function(h){return this.state.tensorInfo.get(h).backend.read(h)},t.prototype.time=function(h){return n(this,void 0,void 0,function(){var g,te;return r(this,function(tr){switch(tr.label){case 0:return g=et(),[4,this.backend.time(h)];case 1:return(te=tr.sent()).wallMs=et()-g,[2,te]}})})},t.prototype.track=function(h){return null!=this.state.activeScope&&(h.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(h)),h},Object.defineProperty(t.prototype,"registeredVariables",{get:function(){return this.state.registeredVariables},enumerable:!0,configurable:!0}),t.prototype.reset=function(){for(var h in this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new tO,this.registry)this.disposeRegisteredKernels(h),this.registry[h].dispose(),delete this.registry[h];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null},t.nextTensorId=0,t.nextVariableId=0,t}(),tM=function(){var h=function(){if(null==tF){var h=void 0;if("undefined"!=typeof window)h=window;else if(void 0!==te.g)h=te.g;else if(void 0!==to)h=to;else{if("undefined"==typeof self)throw Error("Could not find a global object");to=self}tF=h}return tF}();if(null==h._tfengine){var g=new tc(h);h._tfengine=new t_(g)}return tl=h._tfengine.ENV,tm=function(){return h._tfengine},h._tfengine}();function Wt(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}var tB=tl;tB.registerFlag("DEBUG",function(){return!1},function(h){h&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),tB.registerFlag("IS_BROWSER",function(){return Wt()}),tB.registerFlag("IS_NODE",function(){return void 0!==to&&void 0!==to.versions&&void 0!==to.versions.node}),tB.registerFlag("IS_CHROME",function(){return"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)}),tB.registerFlag("PROD",function(){return!1}),tB.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",function(){return tB.getBool("DEBUG")}),tB.registerFlag("DEPRECATION_WARNINGS_ENABLED",function(){return!0}),tB.registerFlag("IS_TEST",function(){return!1});var tP,tL,tW,tV={},tU={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Kt(h,g){tV[h]=g}function jt(h){h in tV||(tV[h]=function(h){if(1!==h&&2!==h)throw Error("Cannot get WebGL rendering context, WebGL is disabled.");var g=function(h){if("undefined"!=typeof OffscreenCanvas&&2===h)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw Error("Cannot create a canvas in this context")}(h);return(g.addEventListener("webglcontextlost",function(g){g.preventDefault(),delete tV[h]},!1),1===h)?g.getContext("webgl",tU)||g.getContext("experimental-webgl",tU):g.getContext("webgl2",tU)}(h));var g=tV[h];return g.isContextLost()?(delete tV[h],jt(h)):(g.disable(g.DEPTH_TEST),g.disable(g.STENCIL_TEST),g.disable(g.BLEND),g.disable(g.DITHER),g.disable(g.POLYGON_OFFSET_FILL),g.disable(g.SAMPLE_COVERAGE),g.enable(g.SCISSOR_TEST),g.enable(g.CULL_FACE),g.cullFace(g.BACK),tV[h])}function Yt(h){return T(Math.ceil(k(h)/4))}function $t(h,g){return[Math.max(1,Math.ceil(g/2)),Math.max(1,Math.ceil(h/2))]}function Qt(h,g){var te,tr,to,tu,tc,th,td,tf,tp;return 2===tl.getNumber("WEBGL_VERSION")?(te=h.R32F,tr=h.R16F,to=h.RGBA16F,tu=h.RGBA32F,tc=h.RED,th=4,td=1,tf=h.HALF_FLOAT):(te=h.RGBA,tr=h.RGBA,to=h.RGBA,tu=h.RGBA,tc=h.RGBA,th=4,td=4,tf=null!=g?g.HALF_FLOAT_OES:null),tp=h.FLOAT,{internalFormatFloat:te,internalFormatHalfFloat:tr,internalFormatPackedHalfFloat:to,internalFormatPackedFloat:tu,textureFormatFloat:tc,downloadTextureFormat:h.RGBA,downloadUnpackNumChannels:th,defaultNumChannels:td,textureTypeHalfFloat:tf,textureTypeFloat:tp}}function Jt(h,g,te){var tr=te();return g&&function(h){var g=h.getError();if(g!==h.NO_ERROR)throw Error("WebGL Error: "+ne(h,g))}(h),tr}function ee(h){return!!(tl.getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===h||596e-10<Math.abs(h)&&65504>Math.abs(h))}function ne(h,g){switch(g){case h.NO_ERROR:return"NO_ERROR";case h.INVALID_ENUM:return"INVALID_ENUM";case h.INVALID_VALUE:return"INVALID_VALUE";case h.INVALID_OPERATION:return"INVALID_OPERATION";case h.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case h.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case h.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+g}}function re(h,g,te){return ke(h,g,function(){return h.getExtension(te)},'Extension "'+te+'" not supported on this browser.')}function oe(h,g,te){var tr=ke(h,g,function(){return h.createShader(h.VERTEX_SHADER)},"Unable to create vertex WebGLShader.");if(Jt(h,g,function(){return h.shaderSource(tr,te)}),Jt(h,g,function(){return h.compileShader(tr)}),!1===h.getShaderParameter(tr,h.COMPILE_STATUS))throw console.log(h.getShaderInfoLog(tr)),Error("Failed to compile vertex shader.");return tr}function ae(h,g,te){var tr=ke(h,g,function(){return h.createShader(h.FRAGMENT_SHADER)},"Unable to create fragment WebGLShader.");if(Jt(h,g,function(){return h.shaderSource(tr,te)}),Jt(h,g,function(){return h.compileShader(tr)}),!1===h.getShaderParameter(tr,h.COMPILE_STATUS))throw function(h,g){var te=tj.exec(g);if(null==te)return console.log("Couldn't parse line number in error: "+g),void console.log(h);for(var tr=+te[1],to=h.split("\n"),tu=to.length.toString().length+2,tc=to.map(function(h,g){return N((g+1).toString(),tu)+h}),tl=0,th=0;th<tc.length;th++)tl=Math.max(tc[th].length,tl);var td=tc.slice(0,tr-1),tf=tc.slice(tr-1,tr),tp=tc.slice(tr);console.log(td.join("\n")),console.log(g.split("\n")[0]),console.log("%c "+N(tf[0],tl),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(tp.join("\n"))}(te,h.getShaderInfoLog(tr)),Error("Failed to compile fragment shader.");return tr}(tz=tP||(tP={}))[tz.DENSE=0]="DENSE",tz[tz.SHARED_BATCH=1]="SHARED_BATCH",(tH=tL||(tL={}))[tH.RENDER=0]="RENDER",tH[tH.UPLOAD=1]="UPLOAD",tH[tH.PIXELS=2]="PIXELS",tH[tH.DOWNLOAD=3]="DOWNLOAD",(tG=tW||(tW={}))[tG.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",tG[tG.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",tG[tG.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",tG[tG.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",tG[tG.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16";var tz,tH,tG,tq,tK,tj=/ERROR: [0-9]+:([0-9]+):/g;function ce(h,g){return ke(h,g,function(){return h.createProgram()},"Unable to create WebGLProgram.")}function le(h,g,te){if(Jt(h,g,function(){return h.linkProgram(te)}),!1===h.getProgramParameter(te,h.LINK_STATUS))throw console.log(h.getProgramInfoLog(te)),Error("Failed to link vertex and fragment shaders.")}function he(h,g,te){if(Jt(h,g,function(){return h.validateProgram(te)}),!1===h.getProgramParameter(te,h.VALIDATE_STATUS))throw console.log(h.getProgramInfoLog(te)),Error("Shader program validation failed.")}function fe(h,g,te){var tr=ke(h,g,function(){return h.createBuffer()},"Unable to create WebGLBuffer");return Jt(h,g,function(){return h.bindBuffer(h.ARRAY_BUFFER,tr)}),Jt(h,g,function(){return h.bufferData(h.ARRAY_BUFFER,te,h.STATIC_DRAW)}),tr}function de(h,g,te){var tr=ke(h,g,function(){return h.createBuffer()},"Unable to create WebGLBuffer");return Jt(h,g,function(){return h.bindBuffer(h.ELEMENT_ARRAY_BUFFER,tr)}),Jt(h,g,function(){return h.bufferData(h.ELEMENT_ARRAY_BUFFER,te,h.STATIC_DRAW)}),tr}function pe(h,g){return ke(h,g,function(){return h.createTexture()},"Unable to create WebGLTexture.")}function ve(h,g){var te=tl.getNumber("WEBGL_MAX_TEXTURE_SIZE");if(h<=0||g<=0){var tr="["+h+"x"+g+"]";throw Error("Requested texture size "+tr+" is invalid.")}if(h>te||g>te)throw Error("Requested texture size "+(tr="["+h+"x"+g+"]")+" greater than WebGL maximum on this browser / GPU "+("["+te)+"x"+te+"].")}function me(h,g){return ke(h,g,function(){return h.createFramebuffer()},"Unable to create WebGLFramebuffer.")}function ge(h,g,te,tr,to,tu,tc,tl){var th=h.getAttribLocation(te,tr);return -1!==th&&(Jt(h,g,function(){return h.bindBuffer(h.ARRAY_BUFFER,to)}),Jt(h,g,function(){return h.vertexAttribPointer(th,tu,h.FLOAT,!1,tc,tl)}),Jt(h,g,function(){return h.enableVertexAttribArray(th)}),!0)}function ye(h,g,te,tr){Se(h,tr),Jt(h,g,function(){return h.activeTexture(h.TEXTURE0+tr)}),Jt(h,g,function(){return h.bindTexture(h.TEXTURE_2D,te)})}function xe(h,g,te,tr){return ke(h,g,function(){return h.getUniformLocation(te,tr)},'uniform "'+tr+'" not present in program.')}function be(h,g,te){return h.getUniformLocation(g,te)}function we(h,g,te,tr,to,tu){Jt(h,g,function(){return ye(h,g,tr,tu)}),Jt(h,g,function(){return h.uniform1i(to,tu)})}function Ce(h,g,te,tr){Jt(h,g,function(){return h.bindFramebuffer(h.FRAMEBUFFER,tr)}),Jt(h,g,function(){return h.framebufferTexture2D(h.FRAMEBUFFER,h.COLOR_ATTACHMENT0,h.TEXTURE_2D,te,0)})}function Ee(h,g,te){Jt(h,g,function(){return h.bindFramebuffer(h.FRAMEBUFFER,te)}),Jt(h,g,function(){return h.framebufferTexture2D(h.FRAMEBUFFER,h.COLOR_ATTACHMENT0,h.TEXTURE_2D,null,0)})}function Re(h){var g=h.checkFramebufferStatus(h.FRAMEBUFFER);if(g!==h.FRAMEBUFFER_COMPLETE)throw Error("Error binding framebuffer: "+Ie(h,g))}function Ie(h,g){switch(g){case h.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case h.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case h.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case h.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+g}}function ke(h,g,te,tr){var to=Jt(h,g,function(){return te()});if(null==to)throw Error(tr);return to}function Se(h,g){var te=h.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,tr=g+h.TEXTURE0;if(tr<h.TEXTURE0||tr>te)throw Error("textureUnit must be in [gl.TEXTURE0, gl.TEXTURE"+te+"].")}function Ae(h,g){return void 0===g&&(g=2),k(h.slice(0,h.length-g))}function De(h){if(0===h.length)throw Error("Cannot get rows and columns of an empty shape array.");return[h.length>1?h[h.length-2]:1,h[h.length-1]]}function Te(h){var g=[1,1,1];return 0===h.length||1===h.length&&1===h[0]||(g=[Ae(h)].concat(De(h))),g}function Ne(h,g){void 0===g&&(g=!1);var te,tr=tl.getNumber("WEBGL_MAX_TEXTURE_SIZE");g&&(tr*=2,1===(h=h.map(function(g,te){return te>=h.length-2?b(h[te]):h[te]})).length&&(h=[2,h[0]])),2!==h.length&&(h=M(h).newShape);var to=k(h);if(h.length<=1&&to<=tr)return[1,to];if(2===h.length&&h[0]<=tr&&h[1]<=tr)return h;if(3===h.length&&h[0]*h[1]<=tr&&h[2]<=tr)return[h[0]*h[1],h[2]];if(3===h.length&&h[0]<=tr&&h[1]*h[2]<=tr)return[h[0],h[1]*h[2]];if(4===h.length&&h[0]*h[1]*h[2]<=tr&&h[3]<=tr)return[h[0]*h[1]*h[2],h[3]];if(4===h.length&&h[0]<=tr&&h[1]*h[2]*h[3]<=tr)return[h[0],h[1]*h[2]*h[3]];if(g){var tu=Ae(h),tc=2,th=2;return h.length&&(tc=(te=De(h))[0],th=te[1]),T(to=tu*(tc/2)*(th/2)).map(function(h){return 2*h})}return T(to)}function _e(h,g){if(S(h=h.slice(-2),g=g.slice(-2))||!h.length||!g.length||0===h[0]||0===h[1]||0===g[0]||0===g[1])return!0;if(h.length!==g.length){var te=h.slice(-1)[0],tr=g.slice(-1)[0];if(te===tr||te%2==0&&tr%2==0&&(1===h[0]||1===g[0]))return!0}return h[1]===g[1]&&h[0]%2==0&&g[0]%2==0}function Oe(h){if(null==tq){var g=jt(h);tq=g.getParameter(g.MAX_TEXTURE_SIZE)}return tq}function Me(h){if(null==tK){var g=jt(h);tK=g.getParameter(g.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,tK)}function Be(h){if(0===h)return 0;var g=jt(h);return Pe(g,"EXT_disjoint_timer_query_webgl2")&&2===h?2:Pe(g,"EXT_disjoint_timer_query")?1:0}function Pe(h,g){return null!=h.getExtension(g)}function Le(h){try{if(null!=jt(h))return!0}catch(h){}return!1}function We(h){if(0===h)return!1;var g=jt(h);if(1===h){if(!Pe(g,"OES_texture_float"))return!1}else if(!Pe(g,"EXT_color_buffer_float"))return!1;return Ve(g)}function Ue(h){if(0===h)return!1;var g=jt(h);if(1!==h){if(Pe(g,"EXT_color_buffer_float"))return Ve(g);if(Pe(g,"EXT_color_buffer_half_float")){var te,tr,to,tu,tc=g.getExtension("EXT_color_buffer_half_float");return te=Qt(g,tc),tr=g.createTexture(),g.bindTexture(g.TEXTURE_2D,tr),g.texImage2D(g.TEXTURE_2D,0,te.internalFormatHalfFloat,1,1,0,te.textureFormatFloat,te.textureTypeHalfFloat,null),to=g.createFramebuffer(),g.bindFramebuffer(g.FRAMEBUFFER,to),g.framebufferTexture2D(g.FRAMEBUFFER,g.COLOR_ATTACHMENT0,g.TEXTURE_2D,tr,0),tu=g.checkFramebufferStatus(g.FRAMEBUFFER)===g.FRAMEBUFFER_COMPLETE,g.bindTexture(g.TEXTURE_2D,null),g.bindFramebuffer(g.FRAMEBUFFER,null),g.deleteTexture(tr),g.deleteFramebuffer(to),tu}return!1}return!!Pe(g,"OES_texture_float")&&!!Pe(g,"WEBGL_color_buffer_float")&&Ve(g)}function Ve(h){var g=Qt(h),te=h.createTexture();h.bindTexture(h.TEXTURE_2D,te),h.texImage2D(h.TEXTURE_2D,0,g.internalFormatFloat,1,1,0,g.textureFormatFloat,g.textureTypeFloat,null);var tr=h.createFramebuffer();h.bindFramebuffer(h.FRAMEBUFFER,tr),h.framebufferTexture2D(h.FRAMEBUFFER,h.COLOR_ATTACHMENT0,h.TEXTURE_2D,te,0);var to=h.checkFramebufferStatus(h.FRAMEBUFFER)===h.FRAMEBUFFER_COMPLETE;return h.bindTexture(h.TEXTURE_2D,null),h.bindFramebuffer(h.FRAMEBUFFER,null),h.deleteTexture(te),h.deleteFramebuffer(tr),to}function ze(h){return 2===h&&null!=jt(h).fenceSync}var tX=Object.freeze({callAndCheck:Jt,canBeRepresented:ee,getWebGLErrorMessage:ne,getExtensionOrThrow:re,createVertexShader:oe,createFragmentShader:ae,createProgram:ce,linkProgram:le,validateProgram:he,createStaticVertexBuffer:fe,createStaticIndexBuffer:de,getNumChannels:function(){return 2===tl.getNumber("WEBGL_VERSION")?1:4},createTexture:pe,validateTextureSize:ve,createFramebuffer:me,bindVertexBufferToProgramAttribute:ge,bindTextureUnit:ye,unbindTextureUnit:function(h,g,te){Se(h,te),Jt(h,g,function(){return h.activeTexture(h.TEXTURE0+te)}),Jt(h,g,function(){return h.bindTexture(h.TEXTURE_2D,null)})},getProgramUniformLocationOrThrow:xe,getProgramUniformLocation:be,bindTextureToProgramUniformSampler:we,bindCanvasToFramebuffer:function(h,g){Jt(h,g,function(){return h.bindFramebuffer(h.FRAMEBUFFER,null)}),Jt(h,g,function(){return h.viewport(0,0,h.canvas.width,h.canvas.height)}),Jt(h,g,function(){return h.scissor(0,0,h.canvas.width,h.canvas.height)})},bindColorTextureToFramebuffer:Ce,unbindColorTextureFromFramebuffer:Ee,validateFramebuffer:Re,getFramebufferErrorMessage:Ie,getBatchDim:Ae,getRowsCols:De,getShapeAs3D:Te,getTextureShapeFromLogicalShape:Ne,isReshapeFree:_e,getWebGLMaxTextureSize:Oe,resetMaxTextureSize:function(){tq=null},resetMaxTexturesInShader:function(){tK=null},getMaxTexturesInShader:Me,getWebGLDisjointQueryTimerVersion:Be,hasExtension:Pe,isWebGLVersionEnabled:Le,isCapableOfRenderingToFloatTexture:We,isDownloadFloatTextureEnabled:Ue,isWebGLFenceEnabled:ze}),t$=tl;function Xe(h){tl.getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(h+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Ze(h,g){return tM.tidy(h,g)}function tn(h){_t(h).forEach(function(h){return h.dispose()})}function dn(){for(var h=[],g=0;g<arguments.length;g++)h[g]=arguments[g];tl.getBool("IS_TEST")||console.warn.apply(console,h)}function pn(h,g){var te=h;if(V(h))return"string"===g?[]:[h.length];if(!Array.isArray(h))return[];for(var tr=[];Array.isArray(te)||V(te)&&"string"!==g;)tr.push(te.length),te=te[0];return Array.isArray(h)&&tl.getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&function t(h,g,te){if(te=te||[],!Array.isArray(h)&&!V(h))return void C(0===g.length,function(){return"Element arr["+te.join("][")+"] is a primitive, but should be an array/TypedArray of "+g[0]+" elements"});C(g.length>0,function(){return"Element arr["+te.join("][")+"] should be a primitive, but is an array of "+h.length+" elements"}),C(h.length===g[0],function(){return"Element arr["+te.join("][")+"] should have "+g[0]+" elements, but has "+h.length+" elements"});for(var tr=g.slice(1),to=0;to<h.length;++to)t(h[to],tr,te.concat(to))}(h,tr,[]),tr}function vn(h,g,te,tr){if(null!=h&&("numeric"!==h&&h!==g||"numeric"===h&&"string"===g))throw Error("Argument '"+te+"' passed to '"+tr+"' must be "+h+" tensor, but got "+g+" tensor")}function mn(h,g,te,tr){if(void 0===tr&&(tr="numeric"),h instanceof tx)return vn(tr,h.dtype,g,te),h;var to=j(h);if("string"!==to&&["bool","int32","float32"].indexOf(tr)>=0&&(to=tr),vn(tr,to,g,te),null==h||!V(h)&&!Array.isArray(h)&&"number"!=typeof h&&"boolean"!=typeof h&&"string"!=typeof h)throw Error("Argument '"+g+"' passed to '"+te+"' must be a Tensor or TensorLike, but got '"+(null==h?"null":h.constructor.name)+"'");var tu=pn(h,to);V(h)||Array.isArray(h)||(h=[h]);var tc="string"!==to?Q(h,to,tl.getBool("DEBUG")):I(h,[],!0);return tM.makeTensor(tc,tu,to)}function gn(h,g,te,tr){if(void 0===tr&&(tr="numeric"),!Array.isArray(h))throw Error("Argument "+g+" passed to "+te+" must be a `Tensor[]` or `TensorLike[]`");return h.map(function(h,tr){return mn(h,g+"["+tr+"]",te)},tr)}function yn(h,g){for(var te=0;te<h.length;++te)if(h[h.length-te-1]!==g-1-te)return!1;return!0}function xn(h,g,te){for(var tr=h.length+g.length,to=[],tu=0,tc=0,tl=0;tl<tr;tl++)-1===te.indexOf(tl)?to.push(h[tu++]):to.push(g[tc++]);return to}function bn(h,g){for(var te=[],tr=h.length,to=0;to<tr;to++)-1===g.indexOf(to)&&te.push(h[to]);return[te,g.map(function(g){return h[g]})]}function wn(h,g){return xn(h,g.map(function(h){return 1}),g)}function Cn(h,g,te){C(yn(g,te),function(){return h+" supports only inner-most axes for now. Got axes "+g+" and rank-"+te+" input."})}function En(h,g){if(yn(h,g))return null;for(var te=[],tr=0;tr<g;++tr)-1===h.indexOf(tr)&&te.push(tr);return h.forEach(function(h){return te.push(h)}),te}function Rn(h){return h.map(function(h,g){return[g,h]}).sort(function(h,g){return h[1]-g[1]}).map(function(h){return h[0]})}function In(h,g){for(var te=[],tr=g-h;tr<g;++tr)te.push(tr);return te}function kn(h,g){var te=h[0].length;h.forEach(function(h,g){C(h.length===te,function(){return"Error in concat"+te+"D: rank of tensors["+g+"] must be the same as the rank of the rest ("+te+")"})}),C(g>=0&&g<te,function(){return"Error in concat"+te+"D: axis must be between 0 and "+(te-1)+"."});var tr=h[0];h.forEach(function(h,to){for(var tu=0;tu<te;tu++)C(tu===g||h[tu]===tr[tu],function(){return"Error in concat"+te+"D: Shape of tensors["+to+"] ("+h+") does not match the shape of the rest ("+tr+") along the non-concatenated axis "+to+"."})})}function Sn(h,g){for(var te=h[0].slice(),tr=1;tr<h.length;tr++)te[g]+=h[tr][g];return te}function An(h){var g=Object.keys(h);if(1!==g.length)throw Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+g.length+" keys.");var te=g[0],tr=h[te];te.endsWith("_")&&(te=te.substring(0,te.length-1));var o=function(){for(var h=[],g=0;g<arguments.length;g++)h[g]=arguments[g];tM.startScope(te);try{var to=tr.apply(void 0,h);return to instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),tM.endScope(to),to}catch(h){throw tM.endScope(null),h}};return Object.defineProperty(o,"name",{value:te,configurable:!0}),o}t$.registerFlag("HAS_WEBGL",function(){return t$.getNumber("WEBGL_VERSION")>0}),t$.registerFlag("WEBGL_VERSION",function(){return Le(2)?2:Le(1)?1:0}),t$.registerFlag("WEBGL_BUFFER_SUPPORTED",function(){return 2===t$.get("WEBGL_VERSION")}),t$.registerFlag("WEBGL_CPU_FORWARD",function(){return!0}),t$.registerFlag("WEBGL_FORCE_F16_TEXTURES",function(){return!1}),t$.registerFlag("WEBGL_PACK",function(){return t$.getBool("HAS_WEBGL")}),t$.registerFlag("WEBGL_PACK_NORMALIZATION",function(){return t$.getBool("WEBGL_PACK")}),t$.registerFlag("WEBGL_PACK_CLIP",function(){return t$.getBool("WEBGL_PACK")}),t$.registerFlag("WEBGL_PACK_DEPTHWISECONV",function(){return!1}),t$.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",function(){return t$.getBool("WEBGL_PACK")}),t$.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",function(){return t$.getBool("WEBGL_PACK")}),t$.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",function(){return t$.getBool("WEBGL_PACK")}),t$.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",function(){return t$.getBool("WEBGL_PACK")}),t$.registerFlag("WEBGL_PACK_REDUCE",function(){return t$.getBool("WEBGL_PACK")}),t$.registerFlag("WEBGL_LAZILY_UNPACK",function(){return t$.getBool("WEBGL_PACK")}),t$.registerFlag("WEBGL_CONV_IM2COL",function(){return t$.getBool("WEBGL_PACK")}),t$.registerFlag("WEBGL_MAX_TEXTURE_SIZE",function(){return Oe(t$.getNumber("WEBGL_VERSION"))}),t$.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",function(){return Me(t$.getNumber("WEBGL_VERSION"))}),t$.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",function(){var h=t$.getNumber("WEBGL_VERSION");return 0===h?0:Be(h)}),t$.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",function(){var h;return t$.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&(h=navigator.userAgent||navigator.vendor||window.opera,!(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(h)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(h.substr(0,4))))}),t$.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",function(){return We(t$.getNumber("WEBGL_VERSION"))}),t$.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",function(){return!t$.getBool("WEBGL_FORCE_F16_TEXTURES")&&t$.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")}),t$.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",function(){return Ue(t$.getNumber("WEBGL_VERSION"))}),t$.registerFlag("WEBGL_FENCE_API_ENABLED",function(){return ze(t$.getNumber("WEBGL_VERSION"))}),t$.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",function(){return t$.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0}),ty=Xe;var tY=An({complex_:function(h,g){var te=mn(h,"real","complex"),tr=mn(g,"imag","complex");return E(te.shape,tr.shape,"real and imag shapes, "+te.shape+" and "+tr.shape+", must match in call to tf.complex()."),tM.runKernelFunc(function(h){return h.complex(te,tr)},{$real:te,$imag:tr})}}),tJ=An({real_:function(h){var g=mn(h,"input","real");return tM.runKernelFunc(function(h){return h.real(g)},{$input:g})}}),tQ=An({imag_:function(h){var g=mn(h,"input","imag");return tM.runKernelFunc(function(h){return h.imag(g)},{$input:g})}});function Fn(h,g,te){return _n(h,g,pn(h,te),te)}function _n(h,g,te,tr){if(null==tr&&(tr=j(h)),"complex64"===tr)throw Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!V(h)&&!Array.isArray(h)&&"number"!=typeof h&&"boolean"!=typeof h&&"string"!=typeof h)throw Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=g){nt(g);var to=k(g),tu=k(te);C(to===tu,function(){return"Based on the provided shape, ["+g+"], the tensor should have "+to+" values but has "+tu});for(var tc=0;tc<te.length;++tc){var th=te[tc],td=tc!==te.length-1||th!==k(g.slice(tc));C(te[tc]===g[tc]||!td,function(){return"Error creating a new Tensor. Inferred shape ("+te+") does not match the provided shape ("+g+"). "})}}return V(h)||Array.isArray(h)||(h=[h]),g=g||te,h="string"!==tr?Q(h,tr,tl.getBool("DEBUG")):I(h,[],!0),tM.makeTensor(h,g,tr)}function On(h,g){if((V(h)&&"string"!==g||Array.isArray(h))&&"complex64"!==g)throw Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===g&&V(h)&&!(h instanceof Uint8Array))throw Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return _n(h,[],[],g)}function Mn(h,g){R(h);var te=pn(h,g);if(1!==te.length)throw Error("tensor1d() requires values to be a flat/TypedArray");return _n(h,null,te,g)}function Bn(h,g,te){if(R(h),null!=g&&2!==g.length)throw Error("tensor2d() requires shape to have two numbers");var tr=pn(h,te);if(2!==tr.length&&1!==tr.length)throw Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===tr.length&&null==g)throw Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return _n(h,g,tr,te)}function Pn(h,g,te){if(R(h),null!=g&&3!==g.length)throw Error("tensor3d() requires shape to have three numbers");var tr=pn(h,te);if(3!==tr.length&&1!==tr.length)throw Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===tr.length&&null==g)throw Error("tensor3d() requires shape to be provided when `values` are a flat array");return _n(h,g,tr,te)}function Ln(h,g,te){if(R(h),null!=g&&4!==g.length)throw Error("tensor4d() requires shape to have four numbers");var tr=pn(h,te);if(4!==tr.length&&1!==tr.length)throw Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===tr.length&&null==g)throw Error("tensor4d() requires shape to be provided when `values` are a flat array");return _n(h,g,tr,te)}function zn(h,g){if(void 0===g&&(g="float32"),"complex64"===g)return tY(zn(h,"float32"),Gn(h,"float32"));var te=Z(k(h),g);return tM.makeTensor(te,h,g)}function Gn(h,g){if(void 0===g&&(g="float32"),"complex64"===g)return tY(Gn(h,"float32"),Gn(h,"float32"));var te=tt(k(h),g);return tM.makeTensor(te,h,g)}function Hn(h,g,te){return tM.runKernelFunc(function(tr){return tr.fill(h,g,te)},{})}function Kn(h,g,te,tr){if(void 0===te&&(te=1),void 0===tr&&(tr="float32"),0===te)throw Error("Cannot have a step of zero");if(h===g||h<g&&te<0||g<h&&te>1)return Gn([0],tr);var to=tt(Math.abs(Math.ceil((g-h)/te)),tr);g<h&&1===te&&(te=-1),to[0]=h;for(var tu=1;tu<to.length;tu++)to[tu]=to[tu-1]+te;return Mn(to,tr)}var tZ=An({onesLike_:function(h){var g=mn(h,"x","onesLike");return"complex64"===g.dtype?tY(tZ(tJ(g)),t0(tQ(g))):tM.runKernelFunc(function(h){return h.onesLike(g)},{$x:g},function(h,g){return{$x:function(){return t0(h)}}})}}),t0=An({zerosLike_:function(h){var g=mn(h,"x","zerosLike");return tM.runKernelFunc(function(h){return h.zerosLike(g)},{$x:g},function(h,g){return{$x:function(){return t0(h)}}})}}),t1=An({concat_:function(h,g){void 0===g&&(g=0),C(h.length>=1,function(){return"Pass at least one tensor to concat"});var te=gn(h,"tensors","concat");"complex64"===te[0].dtype&&te.forEach(function(h){if("complex64"!==h.dtype)throw Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype "+h.dtype+". ")}),g=O(g,te[0].shape)[0];var tr=Sn(te.map(function(h){return h.shape}),g);if(0===k(tr))return Fn([],tr);if(1===(te=te.filter(function(h){return h.size>0})).length)return te[0];var to=te.map(function(h){return h.shape});kn(to,g);var tu=te,tc={axis:g};return tM.runKernelFunc(function(h){return h.concat(te,g)},tu,function(h){return t6(h,to.map(function(h){return h[g]}),g).map(function(h){return function(){return h}})},"Concat",tc)}}),t2=An({concat1d_:function(h){return t1(h,0)}}),t3=An({concat2d_:function(h,g){return t1(h,g)}}),t4=An({concat3d_:function(h,g){return t1(h,g)}}),t5=An({concat4d_:function(h,g){return t1(h,g)}}),t6=An({split_:function(h,g,te){void 0===te&&(te=0);var tr,to=mn(h,"x","split");return te=O(te,to.shape)[0],"number"==typeof g?(C(to.shape[te]%g==0,function(){return"Number of splits must evenly divide the axis."}),tr=Array(g).fill(to.shape[te]/g)):(C(to.shape[te]===g.reduce(function(h,g){return h+g}),function(){return"The sum of sizes must match the size of the axis dimension."}),tr=g),tM.runKernelFunc(function(h){return h.split(to,tr,te)},{$x:to},function(h){return{$x:function(){return t1(h,te)}}})}});function er(h,g){return h(g={exports:{}},g.exports),g.exports}"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:void 0!==te.g?te.g:"undefined"!=typeof self&&self;var t8=er(function(h){!function(h,g,te){function r(h){var g,te=this,tr=(g=4022871197,function(h){h=h.toString();for(var te=0;te<h.length;te++){var tr=.02519603282416938*(g+=h.charCodeAt(te));tr-=g=tr>>>0,g=(tr*=g)>>>0,g+=4294967296*(tr-=g)}return 23283064365386963e-26*(g>>>0)});te.next=function(){var h=2091639*te.s0+23283064365386963e-26*te.c;return te.s0=te.s1,te.s1=te.s2,te.s2=h-(te.c=0|h)},te.c=1,te.s0=tr(" "),te.s1=tr(" "),te.s2=tr(" "),te.s0-=tr(h),te.s0<0&&(te.s0+=1),te.s1-=tr(h),te.s1<0&&(te.s1+=1),te.s2-=tr(h),te.s2<0&&(te.s2+=1),tr=null}function o(h,g){return g.c=h.c,g.s0=h.s0,g.s1=h.s1,g.s2=h.s2,g}function a(h,g){var te=new r(h),tr=g&&g.state,to=te.next;return to.int32=function(){return 4294967296*te.next()|0},to.double=function(){return to()+11102230246251565e-32*(2097152*to()|0)},to.quick=to,tr&&("object"==typeof tr&&o(tr,te),to.state=function(){return o(te,{})}),to}g&&g.exports?g.exports=a:te&&te.amd?te(function(){return a}):this.alea=a}(0,h,!1)}),t7=er(function(h){!function(h,g,te){function r(h){var g=this,te="";g.x=0,g.y=0,g.z=0,g.w=0,g.next=function(){var h=g.x^g.x<<11;return g.x=g.y,g.y=g.z,g.z=g.w,g.w^=g.w>>>19^h^h>>>8},h===(0|h)?g.x=h:te+=h;for(var tr=0;tr<te.length+64;tr++)g.x^=0|te.charCodeAt(tr),g.next()}function o(h,g){return g.x=h.x,g.y=h.y,g.z=h.z,g.w=h.w,g}function a(h,g){var te=new r(h),tr=g&&g.state,i=function(){return(te.next()>>>0)/4294967296};return i.double=function(){do var h=((te.next()>>>11)+(te.next()>>>0)/4294967296)/2097152;while(0===h);return h},i.int32=te.next,i.quick=i,tr&&("object"==typeof tr&&o(tr,te),i.state=function(){return o(te,{})}),i}g&&g.exports?g.exports=a:te&&te.amd?te(function(){return a}):this.xor128=a}(0,h,!1)}),t9=er(function(h){!function(h,g,te){function r(h){var g=this,te="";g.next=function(){var h=g.x^g.x>>>2;return g.x=g.y,g.y=g.z,g.z=g.w,g.w=g.v,(g.d=g.d+362437|0)+(g.v=g.v^g.v<<4^h^h<<1)|0},g.x=0,g.y=0,g.z=0,g.w=0,g.v=0,h===(0|h)?g.x=h:te+=h;for(var tr=0;tr<te.length+64;tr++)g.x^=0|te.charCodeAt(tr),tr==te.length&&(g.d=g.x<<10^g.x>>>4),g.next()}function o(h,g){return g.x=h.x,g.y=h.y,g.z=h.z,g.w=h.w,g.v=h.v,g.d=h.d,g}function a(h,g){var te=new r(h),tr=g&&g.state,i=function(){return(te.next()>>>0)/4294967296};return i.double=function(){do var h=((te.next()>>>11)+(te.next()>>>0)/4294967296)/2097152;while(0===h);return h},i.int32=te.next,i.quick=i,tr&&("object"==typeof tr&&o(tr,te),i.state=function(){return o(te,{})}),i}g&&g.exports?g.exports=a:te&&te.amd?te(function(){return a}):this.xorwow=a}(0,h,!1)}),nn=er(function(h){!function(h,g,te){function r(h){var g=this;g.next=function(){var h,te,tr=g.x,to=g.i;return h=tr[to],te=(h^=h>>>7)^h<<24^((h=tr[to+1&7])^h>>>10)^((h=tr[to+3&7])^h>>>3)^((h=tr[to+4&7])^h<<7),h=tr[to+7&7],te^=(h^=h<<13)^h<<9,tr[to]=te,g.i=to+1&7,te},function(h,g){var te,tr=[];if(g===(0|g))tr[0]=g;else for(g=""+g,te=0;te<g.length;++te)tr[7&te]=tr[7&te]<<15^g.charCodeAt(te)+tr[te+1&7]<<13;for(;tr.length<8;)tr.push(0);for(te=0;te<8&&0===tr[te];++te);for(8==te?tr[7]=-1:tr[te],h.x=tr,h.i=0,te=256;te>0;--te)h.next()}(g,h)}function o(h,g){return g.x=h.x.slice(),g.i=h.i,g}function a(h,g){null==h&&(h=+new Date);var te=new r(h),tr=g&&g.state,i=function(){return(te.next()>>>0)/4294967296};return i.double=function(){do var h=((te.next()>>>11)+(te.next()>>>0)/4294967296)/2097152;while(0===h);return h},i.int32=te.next,i.quick=i,tr&&(tr.x&&o(tr,te),i.state=function(){return o(te,{})}),i}g&&g.exports?g.exports=a:te&&te.amd?te(function(){return a}):this.xorshift7=a}(0,h,!1)}),nr=er(function(h){!function(h,g,te){function r(h){var g=this;g.next=function(){var h,te,tr=g.w,to=g.X,tu=g.i;return g.w=tr=tr+1640531527|0,te=to[tu+34&127],h=to[tu=tu+1&127],te^=te<<13,h^=h<<17,te^=te>>>15,h^=h>>>12,te=to[tu]=te^h,g.i=tu,te+(tr^tr>>>16)|0},function(h,g){var te,tr,to,tu,tc,tl=[],th=128;for(g===(0|g)?(tr=g,g=null):(g+="\x00",tr=0,th=Math.max(th,g.length)),to=0,tu=-32;tu<th;++tu)g&&(tr^=g.charCodeAt((tu+32)%g.length)),0===tu&&(tc=tr),tr^=tr<<10,tr^=tr>>>15,tr^=tr<<4,tr^=tr>>>13,tu>=0&&(tc=tc+1640531527|0,to=0==(te=tl[127&tu]^=tr+tc)?to+1:0);for(to>=128&&(tl[127&(g&&g.length||0)]=-1),to=127,tu=512;tu>0;--tu)tr=tl[to+34&127],te=tl[to=to+1&127],tr^=tr<<13,te^=te<<17,tr^=tr>>>15,te^=te>>>12,tl[to]=tr^te;h.w=tc,h.X=tl,h.i=to}(g,h)}function o(h,g){return g.i=h.i,g.w=h.w,g.X=h.X.slice(),g}function a(h,g){null==h&&(h=+new Date);var te=new r(h),tr=g&&g.state,i=function(){return(te.next()>>>0)/4294967296};return i.double=function(){do var h=((te.next()>>>11)+(te.next()>>>0)/4294967296)/2097152;while(0===h);return h},i.int32=te.next,i.quick=i,tr&&(tr.X&&o(tr,te),i.state=function(){return o(te,{})}),i}g&&g.exports?g.exports=a:te&&te.amd?te(function(){return a}):this.xor4096=a}(0,h,!1)}),nu=er(function(h){!function(h,g,te){function r(h){var g=this,te="";g.next=function(){var h=g.b,te=g.c,tr=g.d,to=g.a;return h=h<<25^h>>>7^te,te=te-tr|0,tr=tr<<24^tr>>>8^to,to=to-h|0,g.b=h=h<<20^h>>>12^te,g.c=te=te-tr|0,g.d=tr<<16^te>>>16^to,g.a=to-h|0},g.a=0,g.b=0,g.c=-1640531527,g.d=1367130551,h===Math.floor(h)?(g.a=h/4294967296|0,g.b=0|h):te+=h;for(var tr=0;tr<te.length+20;tr++)g.b^=0|te.charCodeAt(tr),g.next()}function o(h,g){return g.a=h.a,g.b=h.b,g.c=h.c,g.d=h.d,g}function a(h,g){var te=new r(h),tr=g&&g.state,i=function(){return(te.next()>>>0)/4294967296};return i.double=function(){do var h=((te.next()>>>11)+(te.next()>>>0)/4294967296)/2097152;while(0===h);return h},i.int32=te.next,i.quick=i,tr&&("object"==typeof tr&&o(tr,te),i.state=function(){return o(te,{})}),i}g&&g.exports?g.exports=a:te&&te.amd?te(function(){return a}):this.tychei=a}(0,h,!1)}),nl=er(function(h){!function(g,tr){var to,tu=this,tc="random",tl=tr.pow(256,6),th=tr.pow(2,52),td=2*th;function f(h,te,tf){var tp=[],tv=v(function t(h,g){var te,tr=[],to=typeof h;if(g&&"object"==to)for(te in h)try{tr.push(t(h[te],g-1))}catch(h){}return tr.length?tr:"string"==to?h:h+"\x00"}((te=1==te?{entropy:!0}:te||{}).entropy?[h,m(g)]:null==h?function(){try{var h;return to&&(h=to.randomBytes)?h=h(256):(h=new Uint8Array(256),(tu.crypto||tu.msCrypto).getRandomValues(h)),m(h)}catch(h){var te=tu.navigator,tr=te&&te.plugins;return[+new Date,tu,tr,tu.screen,m(g)]}}():h,3),tp),tm=new d(tp),b=function(){for(var h=tm.g(6),g=tl,te=0;h<th;)h=(h+te)*256,g*=256,te=tm.g(1);for(;h>=td;)h/=2,g/=2,te>>>=1;return(h+te)/g};return b.int32=function(){return 0|tm.g(4)},b.quick=function(){return tm.g(4)/4294967296},b.double=b,v(m(tm.S),g),(te.pass||tf||function(h,g,te,to){return to&&(to.S&&p(to,tm),h.state=function(){return p(tm,{})}),te?(tr[tc]=h,g):h})(b,tv,"global"in te?te.global:this==tr,te.state)}function d(h){var g,te=h.length,tr=this,to=0,tu=tr.i=tr.j=0,tc=tr.S=[];for(te||(h=[te++]);to<256;)tc[to]=to++;for(to=0;to<256;to++)tc[to]=tc[tu=255&tu+h[to%te]+(g=tc[to])],tc[tu]=g;(tr.g=function(h){for(var g,te=0,to=tr.i,tu=tr.j,tc=tr.S;h--;)g=tc[to=255&to+1],te=256*te+tc[255&(tc[to]=tc[tu=255&tu+g])+(tc[tu]=g)];return tr.i=to,tr.j=tu,te})(256)}function p(h,g){return g.i=h.i,g.j=h.j,g.S=h.S.slice(),g}function v(h,g){for(var te,tr=h+"",to=0;to<tr.length;)g[255&to]=255&(te^=19*g[255&to])+tr.charCodeAt(to++);return m(g)}function m(h){return String.fromCharCode.apply(0,h)}if(tr["seed"+tc]=f,v(tr.random(),g),h.exports){h.exports=f;try{to=te(4902)}catch(h){}}}([],Math)});nl.alea=t8,nl.xor128=t7,nl.xorwow=t9,nl.xorshift7=nn,nl.xor4096=nr,nl.tychei=nu;var nh=nl.alea,nd=function(){function t(h,g,te,tr,to){this.mean=h,this.stdDev=g,this.dtype=te,this.nextVal=NaN,this.truncated=tr,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);var tu=to||Math.random();this.random=nh(tu.toString())}return t.prototype.nextValue=function(){if(!isNaN(this.nextVal)){var h=this.nextVal;return this.nextVal=NaN,h}for(var g,te,tr=!1;!tr;){var to=void 0,tu=void 0,tc=void 0;do tc=(to=2*this.random()-1)*to+(tu=2*this.random()-1)*tu;while(tc>=1||0===tc);var tl=Math.sqrt(-2*Math.log(tc)/tc);g=this.mean+this.stdDev*to*tl,te=this.mean+this.stdDev*tu*tl,this.truncated&&!this.isValidTruncated(g)||(tr=!0)}return this.truncated&&!this.isValidTruncated(te)||(this.nextVal=this.convertValue(te)),this.convertValue(g)},t.prototype.convertValue=function(h){return null==this.dtype||"float32"===this.dtype?h:Math.round(h)},t.prototype.isValidTruncated=function(h){return h<=this.upper&&h>=this.lower},t}(),nf=function(){function t(h,g,te,tr){this.alpha=h,this.beta=1/g,this.dtype=te;var to=tr||Math.random();this.randu=nh(to.toString()),this.randn=new nd(0,1,te,!1,this.randu()),this.d=h<1?h+2/3:h-1/3,this.c=1/Math.sqrt(9*this.d)}return t.prototype.nextValue=function(){for(var h,g,te,tr,to,tu;;){do tr=this.randn.nextValue(),tu=1+this.c*tr;while(tu<=0);if(tu*=tu*tu,g=1-.331*(h=tr*tr)*h,te=.5*h+this.d*(1-tu+Math.log(tu)),(to=this.randu())<g||Math.log(to)<te)break}return tu=1/this.beta*this.d*tu,this.alpha<1&&(tu*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(tu)},t.prototype.convertValue=function(h){return"float32"===this.dtype?h:Math.round(h)},t}(),np=function(){function t(h,g,te,tr){var to=this;if(void 0===h&&(h=0),void 0===g&&(g=1),this.canReturnFloat=function(){return null==to.dtype||"float32"===to.dtype},this.min=h,this.range=g-h,this.dtype=te,null==tr&&(tr=Math.random()),"number"==typeof tr&&(tr=tr.toString()),!this.canReturnFloat()&&this.range<=1)throw Error("The difference between "+h+" - "+g+" <= 1 and dtype is not float");this.random=nh(tr)}return t.prototype.convertValue=function(h){return this.canReturnFloat()?h:Math.round(h)},t.prototype.nextValue=function(){return this.convertValue(this.min+this.range*this.random())},t}();function dr(h,g,te){return void 0===g&&(g="float32"),g=g||"float32",nt(h),new tv(h,g,te)}var nv=An({batchToSpaceND_:function(h,g,te){var tr=mn(h,"x","batchToSpaceND"),to=g.reduce(function(h,g){return h*g});return C(tr.rank>=1+g.length,function(){return"input rank is "+tr.rank+" but should be > than blockShape.length "+g.length}),C(te.length===g.length,function(){return"crops.length is "+te.length+" but should be equal to blockShape.length  "+g.length}),C(tr.shape[0]%to==0,function(){return"input tensor batch is "+tr.shape[0]+" but is not divisible by the product of the elements of blockShape "+g.join(" * ")+" === "+to}),tM.runKernelFunc(function(h){return h.batchToSpaceND(tr,g,te)},{$x:tr},function(h){return{$x:function(){return h.spaceToBatchND(g,te)}}})}}),nm=An({broadcastTo_:function(h,g){var te=mn(h,"broadcastTo","x"),tr=te.shape;if(g.some(function(h){return!(h>0)||h%1!=0}))throw Error("broadcastTo(): Invalid broadcast shape ["+g+"].");if(g.length<te.rank)throw Error("broadcastTo(): shape.length="+g.length+" < input.rank="+te.rank+".");if(g.length>te.rank){for(var to=te.shape.slice();to.length<g.length;)to.unshift(1);te=te.reshape(to)}for(var tu=Array.from(g),tc=g.length-1;tc>=0;tc--)if(te.shape[tc]===g[tc])tu[tc]=1;else if(1!==te.shape[tc])throw Error("broadcastTo(): ["+tr+"] cannot be broadcast to ["+g+"].");var tl=tu.map(function(h,g){return h>1?g:-1}).filter(function(h){return h>=0});return 0===tl.length?te.clone():tM.runKernelFunc(function(h){return h.tile(te,tu)},{input:te},function(h){return{input:function(){return h.sum(tl,!0)}}})}}),ng=An({cast_:function(h,g){var te=mn(h,"x","cast");if(!W(g))throw Error("Failed to cast to unknown dtype "+g);if("string"===g&&"string"!==te.dtype||"string"!==g&&"string"===te.dtype)throw Error("Only strings can be casted to strings");return tM.runKernelFunc(function(h){return h.cast(te,g)},{x:te},function(h){return{x:function(){return h.clone()}}},"Cast",{dtype:g})}}),ny=An({clone_:function(h){var g=mn(h,"x","clone",null);return tM.runKernelFunc(function(){return tM.makeTensorFromDataId(g.dataId,g.shape,g.dtype)},{$x:g},function(h){return{$x:function(){return h.toFloat()}}})}}),nx=An({cumsum_:function(h,g,te,tr){void 0===g&&(g=0),void 0===te&&(te=!1),void 0===tr&&(tr=!1);var to=mn(h,"x","cumsum"),tu=En([g|=0],to.rank),tc=to;null!=tu&&(tc=to.transpose(tu));var tl=In(1,to.rank)[0],th=tM.runKernelFunc(function(h){return h.cumsum(tc,tl,te,tr)},{permutedX:tc},function(h){return{permutedX:function(){return h.cumsum(g,te,!tr)}}});return null!=tu&&(th=th.transpose(tu)),th}}),nb=An({depthToSpace_:function(h,g,te){void 0===te&&(te="NHWC");var tr=mn(h,"x","depthToSpace"),to="NHWC"===te?tr.shape[1]:tr.shape[2],tu="NHWC"===te?tr.shape[2]:tr.shape[3],tc="NHWC"===te?tr.shape[3]:tr.shape[1];return C(to*g>=0,function(){return"Negative dimension size caused by overflow when multiplying\n      "+to+" and "+g+"  for depthToSpace with input shape\n      "+tr.shape}),C(tu*g>=0,function(){return"Negative dimension size caused by overflow when multiplying\n      "+tu+" and "+g+" for depthToSpace with input shape\n          "+tr.shape}),C(tc%(g*g)==0,function(){return"Dimension size must be evenly divisible by "+g*g+" but is "+tc+" for depthToSpace with input shape "+tr.shape}),tM.runKernelFunc(function(h){return h.depthToSpace(tr,g,te)},{$x:tr})}}),nC=An({expandDims_:function(h,g){void 0===g&&(g=0);var te=mn(h,"x","expandDims",null);C(g<=te.rank,function(){return"Axis must be <= rank of the tensor"});var tr=te.shape.slice();return g<0&&(C(-(te.rank+1)<=g,function(){return"Axis must be in the interval ["+-(te.rank+1)+", "+te.rank+"]"}),g=te.rank+g+1),tr.splice(g,0,1),n_(te,tr)}}),nw=An({eye_:function(h,g,te,tr){void 0===tr&&(tr="float32"),null==g&&(g=h);for(var to=dr([h,g],tr),tu=h<=g?h:g,tc=0;tc<tu;++tc)to.set(1,tc,tc);var tl=to.toTensor().as2D(h,g);if(null==te)return tl;if(1===te.length)return nL(nC(tl,0),[te[0],1,1]);if(2===te.length)return nL(nC(nC(tl,0),0),[te[0],te[1],1,1]);if(3===te.length)return nL(nC(nC(nC(tl,0),0),0),[te[0],te[1],te[2],1,1]);throw Error("eye() currently supports only 1D and 2D batchShapes, but received "+te.length+"D.")}}),nE=An({multinomial_:function(h,g,te,tr){void 0===tr&&(tr=!1);var to=mn(h,"logits","multinomial"),tu=to.size,tc=to.rank;if(tu<2)throw Error("Error in multinomial: you need at least 2 outcomes, but got "+tu+".");if(tc>2)throw Error("Rank of probabilities must be 1 or 2, but is "+tc);te=te||Math.random();var tl=1===tc?to.as2D(1,-1):to,th=tM.runKernelFunc(function(h){return h.multinomial(tl,tr,g,te)},{logits2D:tl});return 1===tc?th.as1D():th}}),nR=An({oneHot_:function(h,g,te,tr){if(void 0===te&&(te=1),void 0===tr&&(tr=0),g<2)throw Error("Error in oneHot: depth must be >=2, but it is "+g);var to=mn(h,"indices","oneHot","int32"),tu=to.shape.concat([g]);return to=to.flatten(),tM.runKernelFunc(function(h){return h.oneHot(to,g,te,tr)},{$indices:to},function(h){return{$indices:function(){return Gn(to.shape,"float32")}}}).reshape(tu)}}),nI=An({pad_:function(h,g,te){void 0===te&&(te=0);var tr=mn(h,"x","pad");if(0===tr.rank)throw Error("pad(scalar) is not defined. Pass non-scalar to pad");var to={paddings:g,constantValue:te};return tM.runKernelFunc(function(h){return h.pad(tr,g,te)},{x:tr},function(h){var te=g.map(function(h){return h[0]});return{x:function(){return h.slice(te,tr.shape)}}},"PadV2",to)}}),nk=An({pad1d_:function(h,g,te){return void 0===te&&(te=0),C(2===g.length,function(){return"Invalid number of paddings. Must be length of 2."}),nI(h,[g],te)}}),nA=An({pad2d_:function(h,g,te){return void 0===te&&(te=0),C(2===g.length&&2===g[0].length&&2===g[1].length,function(){return"Invalid number of paddings. Must be length of 2 each."}),nI(h,g,te)}}),nS=An({pad3d_:function(h,g,te){return void 0===te&&(te=0),C(3===g.length&&2===g[0].length&&2===g[1].length&&2===g[2].length,function(){return"Invalid number of paddings. Must be length of 2 each."}),nI(h,g,te)}}),nD=An({pad4d_:function(h,g,te){return void 0===te&&(te=0),C(4===g.length&&2===g[0].length&&2===g[1].length&&2===g[2].length&&2===g[3].length,function(){return"Invalid number of paddings. Must be length of 2 each."}),nI(h,g,te)}}),nN=An({rand_:function(h,g,te){var tr=k(h),to=null;if(null==te||"float32"===te)to=new Float32Array(tr);else if("int32"===te)to=new Int32Array(tr);else{if("bool"!==te)throw Error("Unknown data type "+te);to=new Uint8Array(tr)}for(var tu=0;tu<tr;tu++)to[tu]=g();return tM.makeTensor(to,h,te)}}),nT=An({randomNormal_:function(h,g,te,tr,to){if(void 0===g&&(g=0),void 0===te&&(te=1),null!=tr&&"bool"===tr)throw Error("Unsupported data type "+tr);for(var tu=new nd(g,te,tr,!1,to),tc=dr(h,tr),tl=0;tl<tc.values.length;tl++)tc.values[tl]=tu.nextValue();return tc.toTensor()}}),nF=An({randomGamma_:function(h,g,te,tr,to){if(void 0===te&&(te=1),void 0===tr&&(tr="float32"),null==te&&(te=1),null==tr&&(tr="float32"),"float32"!==tr&&"int32"!==tr)throw Error("Unsupported data type "+tr);for(var tu=new nf(g,te,tr,to),tc=dr(h,tr),tl=0;tl<tc.values.length;tl++)tc.values[tl]=tu.nextValue();return tc.toTensor()}}),nO=An({randomUniform_:function(h,g,te,tr,to){void 0===g&&(g=0),void 0===te&&(te=1),void 0===tr&&(tr="float32");for(var tu=dr(h,tr),tc=new np(g,te,null,to),tl=0;tl<tu.values.length;tl++)tu.values[tl]=tc.nextValue();return tu.toTensor()}}),n_=An({reshape_:function(h,g){var te=mn(h,"x","reshape",null);g=_(g,te.size),C(te.size===k(g),function(){return"new shape and old shape must have the same number of elements."});var tr={shape:g};return tM.runKernelFunc(function(h){return h.reshape(te,g)},{x:te},function(h){return{x:function(){return h.reshape(te.shape)}}},"Reshape",tr)}}),nM=An({spaceToBatchND_:function(h,g,te){var tr=mn(h,"x","spaceToBatchND");return C(tr.rank>=1+g.length,function(){return"input rank "+tr.rank+" should be > than [blockShape] "+g.length}),C(te.length===g.length,function(){return"paddings.shape[0] "+te.length+" must be equal to [blockShape] "+g.length}),C(tr.shape.reduce(function(h,tr,to){return to>0&&to<=g.length?h&&(tr+te[to-1][0]+te[to-1][1])%g[to-1]==0:h},!0),function(){return"input spatial dimensions "+tr.shape.slice(1)+" with paddings "+te.toString()+" must be divisible by blockShapes "+g.toString()}),tM.runKernelFunc(function(h){return h.spaceToBatchND(tr,g,te)},{$x:tr},function(h){return{$x:function(){return h.batchToSpaceND(g,te)}}})}}),nB=An({squeeze_:function(h,g){var te=mn(h,"x","squeeze");return n_(te,M(te.shape,g).newShape)}}),nP=An({stack_:function(h,g){void 0===g&&(g=0);var te=gn(h,"tensors","stack");if(C(te.length>=1,function(){return"Pass at least one tensor to tf.stack"}),1===te.length)return te[0].expandDims(g);var tr=te[0].rank,to=te[0].shape,tu=te[0].dtype;return C(g<=tr,function(){return"Axis must be <= rank of the tensor"}),te.forEach(function(h){E(to,h.shape,"All tensors passed to stack must have matching shapes")}),te.forEach(function(h){C(tu===h.dtype,function(){return"All tensors passed to stack must have matching dtypes"})}),t1(te.map(function(h){return h.expandDims(g)}),g)}}),nL=An({tile_:function(h,g){var te=mn(h,"x","tile",null);C(te.rank===g.length,function(){return"Error in transpose: rank of input "+te.rank+" must match length of reps "+g+"."});var tr=[te];return tM.runKernelFunc(function(h,tr){var to=h.tile(te,g);return tr([te]),to},{x:te},function(h,te){var tr=te[0];return{x:function(){var te=t0(tr);if(1===tr.rank)for(var to=0;to<g[0];++to)te=te.add(h.slice([to*tr.shape[0]],[tr.shape[0]]));else if(2===tr.rank)for(to=0;to<g[0];++to)for(var tu=0;tu<g[1];++tu)te=te.add(h.slice([to*tr.shape[0],tu*tr.shape[1]],[tr.shape[0],tr.shape[1]]));else if(3===tr.rank)for(to=0;to<g[0];++to)for(tu=0;tu<g[1];++tu)for(var tc=0;tc<g[2];++tc)te=te.add(h.slice([to*tr.shape[0],tu*tr.shape[1],tc*tr.shape[2]],[tr.shape[0],tr.shape[1],tr.shape[2]]));else{if(4!==tr.rank)throw Error("Gradient for tile operation is not implemented for rank-"+tr.rank+" tensors yet.");for(to=0;to<g[0];++to)for(tu=0;tu<g[1];++tu)for(tc=0;tc<g[2];++tc)for(var tl=0;tl<g[3];++tl)te=te.add(h.slice([to*tr.shape[0],tu*tr.shape[1],tc*tr.shape[2],tl*tr.shape[3]],[tr.shape[0],tr.shape[1],tr.shape[2],tr.shape[3]]))}return te}}},"Tile",{reps:g},tr)}}),nW=An({truncatedNormal_:function(h,g,te,tr,to){if(void 0===g&&(g=0),void 0===te&&(te=1),null!=tr&&"bool"===tr)throw Error("Unsupported data type "+tr);for(var tu=new nd(g,te,tr,!0,to),tc=dr(h,tr),tl=0;tl<tc.values.length;tl++)tc.values[tl]=tu.nextValue();return tc.toTensor()}}),nV=An({unstack_:function(h,g){void 0===g&&(g=0),g=g||0;var te=mn(h,"x","unstack");C(g>=-te.shape.length&&g<te.shape.length,function(){return"Axis = "+g+" is not in [-"+te.shape.length+", "+te.shape.length+")"}),g<0&&(g+=te.shape.length);var tr={axis:g};return tM.runKernelFunc(function(h){return h.unstack(te,g)},{x:te},function(h){return{x:function(){return nP(h,g)}}},"Unpack",tr)}});function zr(h,g,te,tr){void 0===tr&&(tr=!0);var to=[];if(tr)(to=to.concat(g.slice(0))).push(h[0]/te),to=to.concat(h.slice(1));else{to=to.concat(h[0]);for(var tu=g.length,tc=0;tc<tu;++tc)to=to.concat([h[tc+1]/g[tc],g[tc]]);to=to.concat(h.slice(tu+1))}return to}function Gr(h,g,te){void 0===te&&(te=!0);var tr=[];if(te){tr.push(g);for(var to=g+1;to<h;++to)to<=2*g?(tr.push(to),tr.push(to-(g+1))):tr.push(to)}else{var tu=[],tc=[];for(to=1;to<h;++to)to>=2*g+1||to%2==1?tc.push(to):tu.push(to);tr.push.apply(tr,tu),tr.push(0),tr.push.apply(tr,tc)}return tr}function Hr(h,g,te,tr){void 0===tr&&(tr=!0);var to=[];tr?to.push(h[0]/te):to.push(h[0]*te);for(var tu=1;tu<h.length;++tu)tu<=g.length?tr?to.push(g[tu-1]*h[tu]):to.push(h[tu]/g[tu-1]):to.push(h[tu]);return to}function qr(h,g){for(var te=[0],tr=0;tr<g;++tr)te.push(h[tr][0]);return te}function Kr(h,g,te){for(var tr=h.slice(0,1),to=0;to<te;++to)tr.push(h[to+1]-g[to][0]-g[to][1]);return tr}function jr(h,g){if(h.rank<1)throw Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was "+h.rank+".");if(g.rank<1)throw Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was "+g.rank+".");if("int32"!==g.dtype)throw Error("tf.gatherND() expects the indices to be int32 type, but the dtype was "+g.dtype+".");if(g.shape[g.rank-1]>h.rank)throw Error("index innermost dimension length must be <= tensor rank; saw: "+g.shape[g.rank-1]+" vs. "+h.rank);if(0===h.size)throw Error("Requested more than 0 entries, but input is empty. Input shape: "+h.shape+".");for(var te=g.shape,tr=te[te.length-1],to=1,tu=0;tu<te.length-1;++tu)to*=te[tu];var tc=h.shape,tl=te.slice();tl.pop();var th=1;for(tu=tr;tu<h.rank;++tu)th*=tc[tu],tl.push(tc[tu]);var td=$(h.shape).map(function(h){return h/th}).concat([1]).slice(0,tr);return[tl,to,th,td]}function $r(h){return h<=30?h:Y(h,Math.floor(Math.sqrt(h)))}function Qr(h,g,te){var tr=g.rank>1?g.shape[g.rank-1]:1,to=g.rank>1?g.rank-1:1,tu="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+te.shape+", indices.shape: "+g.shape+", shape: "+h+", sliceDim: "+tr+", and batchDim: "+to+".";if(te.rank<to)throw Error(tu+" update.rank < "+to+". ");if(h.length<tr+(te.rank-to))throw Error(tu+" Output shape length < "+(tr+(te.rank-to)));if(te.rank!==to+h.length-tr)throw Error(tu+" update.rank != "+(to+h.length-tr));for(var tc=0;tc<to;++tc)if(te.shape[tc]!==g.shape[tc])throw Error(tu+" updates.shape["+tc+"] ("+te.shape[tc]+") != indices.shape["+tc+"] ("+g.shape[tc]+").");for(tc=0;tc<te.rank-to;++tc)if(te.shape[tc+to]!==h[tc+tr])throw Error(tu+" updates.shape["+(tc+to)+"] ("+te.shape[tc+to]+") != shape["+(tc+to)+"] ("+h[tc+to]+")")}function Jr(h,g,te){if(g.rank<1)throw Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was "+g.rank+".");if(h.rank<1)throw Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was "+h.rank+".");if("int32"!==g.dtype)throw Error("The dtype of 'indices' should be int32, but got dtype: "+g.dtype);if(te.length<1)throw Error("Output rank must be greater or equal to 1, but got shape: "+te);if(0===te.length){if(0===g.size)throw Error("Indices specified for empty output. indices shape: "+g.shape);if(0===h.size)throw Error("Updates specified for empty output. updates shape: "+h.shape)}Qr(te,g,h)}function Zr(h,g,te){for(var tr=g.shape.length,to=tr>1?g.shape[tr-1]:1,tu=te.length,tc=1,tl=to;tl<tu;++tl)tc*=te[tl];var th=to<1?1:to;return{sliceRank:to,numUpdates:k(g.shape)/th,sliceSize:tc,strides:$(te.slice(0,to)).concat([1]),outputSize:k(te)}}function eo(h,g,te){C(h.rank===g.length,function(){return"Error in slice"+h.rank+"D: Length of begin "+g+" must match the rank of the array ("+h.rank+")."}),C(h.rank===te.length,function(){return"Error in slice"+h.rank+"D: Length of size "+te+" must match the rank of the array ("+h.rank+")."});for(var r=function(tr){C(g[tr]+te[tr]<=h.shape[tr],function(){return"Error in slice"+h.rank+"D: begin["+tr+"] + size["+tr+"] ("+(g[tr]+te[tr])+") would overflow input.shape["+tr+"] ("+h.shape[tr]+")"})},tr=0;tr<h.rank;++tr)r(tr)}function no(h){for(var g=[],te=0;h>0;)1&h&&g.push(te),h/=2,te++;return g}function ro(h,g,te){for(var tr=[],to=0;to<h.length;to++)tr[to]=Math.ceil((g[to]-h[to])/te[to]);return tr}function oo(h,g,te,tr,to){var tu=g[to],tc=te[to]||1;(h&1<<to||null==tu)&&(tu=tc>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);var tl=tr[to];return tu<0&&(tu+=tl),tu=x(0,tu,tl-1)}function ao(h,g,te,tr,to){var tu=g[to],tc=te[to]||1;(h&1<<to||null==tu)&&(tu=tc>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);var tl=tr[to];return tu<0&&(tu+=tl),tu=tc>0?x(0,tu,tl):x(-1,tu,tl-1)}function io(h,g,te){for(var tr=te.length,to=0;to<te.length;to++)if(te[to]>1){tr=to;break}for(to=tr+1;to<te.length;to++)if(g[to]>0||te[to]!==h[to])return!1;return!0}function so(h,g){for(var te=h.length>0?h[h.length-1]:1,tr=0;tr<h.length-1;tr++)te+=h[tr]*g[tr];return te}function vo(h){return tM.customGrad(h)}Object.freeze({prepareAndValidate:jr}),Object.freeze({validateUpdateShape:Qr,validateInput:Jr,calculateShapes:Zr}),Object.freeze({assertParamsValid:eo,maskToAxes:no,computeOutShape:ro,startForAxis:oo,stopForAxis:ao,isSliceContinous:io,computeFlatOffset:so});var nU=An({softmax_:function(h,g){void 0===g&&(g=-1);var te=mn(h,"logits","softmax","float32");if(-1===g&&(g=te.rank-1),g!==te.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank "+te.rank+" and dim was "+g);return tM.runKernelFunc(function(h,tr){var to=h.softmax(te,g);return tr([to]),to},{logits:te},function(h,te){var tr=te[0],to=h.mul(tr);return{logits:function(){return to.sub(to.sum([g],!0).mul(tr))}}},"Softmax",{dim:g},[],[!0])}}),nz=An({logSoftmax_:function(h,g){void 0===g&&(g=-1);var te=mn(h,"logits","logSoftmax");if(-1===g&&(g=te.rank-1),g!==te.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank "+te.rank+" and axis was "+g);return vo(function(h,te){var tr=h.max(g,!0),to=h.sub(tr),tu=to.toFloat().sub(to.exp().sum(g,!0).log());return te([tu]),{value:tu,gradFunc:function(h,te){var tr=te[0].exp();return h.sub(h.sum(g,!0).mul(tr))}}})(te)}}),nH=function(){function t(h,g){this.backend=h,this.dataMover=g,this.data=new WeakMap,this.dataIdsCount=0}return t.prototype.get=function(h){return this.data.has(h)||this.dataMover.moveData(this.backend,h),this.data.get(h)},t.prototype.set=function(h,g){this.dataIdsCount++,this.data.set(h,g)},t.prototype.has=function(h){return this.data.has(h)},t.prototype.delete=function(h){return this.dataIdsCount--,this.data.delete(h)},t.prototype.numDataIds=function(){return this.dataIdsCount},t}(),nG=function(){function t(){}return t.prototype.time=function(h){return wo("time")},t.prototype.read=function(h){return wo("read")},t.prototype.readSync=function(h){return wo("readSync")},t.prototype.numDataIds=function(){return wo("numDataIds")},t.prototype.disposeData=function(h){return wo("disposeData")},t.prototype.write=function(h,g,te){return wo("write")},t.prototype.move=function(h,g,te,tr){return wo("move")},t.prototype.memory=function(){return wo("memory")},t.prototype.floatPrecision=function(){return wo("floatPrecision")},t.prototype.epsilon=function(){return 32===this.floatPrecision()?1e-7:1e-4},t.prototype.batchMatMul=function(h,g,te,tr){return wo("batchMatMul")},t.prototype.fusedBatchMatMul=function(h){return h.a,h.b,h.transposeA,h.transposeB,h.bias,h.activation,h.preluActivationWeights,wo("fusedBatchMatMul")},t.prototype.slice=function(h,g,te){return wo("slice")},t.prototype.stridedSlice=function(h,g,te,tr){return wo("stridedSlice")},t.prototype.unstack=function(h,g){return wo("unstack")},t.prototype.reverse=function(h,g){return wo("reverse")},t.prototype.concat=function(h,g){return wo("concat")},t.prototype.neg=function(h){return wo("neg")},t.prototype.add=function(h,g){return wo("add")},t.prototype.addN=function(h){return wo("addN")},t.prototype.subtract=function(h,g){return wo("subtract")},t.prototype.multiply=function(h,g){return wo("multiply")},t.prototype.realDivide=function(h,g){return wo("realDivide")},t.prototype.floorDiv=function(h,g){return wo("floorDiv")},t.prototype.sum=function(h,g){return wo("sum")},t.prototype.prod=function(h,g){return wo("prod")},t.prototype.unsortedSegmentSum=function(h,g,te){return wo("unsortedSegmentSum")},t.prototype.argMin=function(h,g){return wo("argMin")},t.prototype.argMax=function(h,g){return wo("argMax")},t.prototype.equal=function(h,g){return wo("equal")},t.prototype.notEqual=function(h,g){return wo("notEqual")},t.prototype.less=function(h,g){return wo("less")},t.prototype.lessEqual=function(h,g){return wo("lessEqual")},t.prototype.greater=function(h,g){return wo("greater")},t.prototype.greaterEqual=function(h,g){return wo("greaterEqual")},t.prototype.logicalNot=function(h){return wo("logicalNot")},t.prototype.logicalAnd=function(h,g){return wo("logicalAnd")},t.prototype.logicalOr=function(h,g){return wo("logicalOr")},t.prototype.where=function(h){return wo("where")},t.prototype.select=function(h,g,te){return wo("select")},t.prototype.topk=function(h,g,te){return wo("topk")},t.prototype.min=function(h,g){return wo("min")},t.prototype.minimum=function(h,g){return wo("minimum")},t.prototype.mod=function(h,g){return wo("mod")},t.prototype.max=function(h,g){return wo("max")},t.prototype.maximum=function(h,g){return wo("maximum")},t.prototype.all=function(h,g){return wo("all")},t.prototype.any=function(h,g){return wo("any")},t.prototype.squaredDifference=function(h,g){return wo("squaredDifference")},t.prototype.ceil=function(h){return wo("ceil")},t.prototype.floor=function(h){return wo("floor")},t.prototype.round=function(h){return wo("round")},t.prototype.sign=function(h){return wo("sign")},t.prototype.isNaN=function(h){return wo("isNaN")},t.prototype.isInf=function(h){return wo("isInf")},t.prototype.isFinite=function(h){return wo("isFinite")},t.prototype.pow=function(h,g){return wo("pow")},t.prototype.exp=function(h){return wo("exp")},t.prototype.expm1=function(h){return wo("expm1")},t.prototype.softmax=function(h,g){return wo("softmax")},t.prototype.log=function(h){return wo("log")},t.prototype.log1p=function(h){return wo("log1p")},t.prototype.sqrt=function(h){return wo("sqrt")},t.prototype.rsqrt=function(h){return wo("rsqrt")},t.prototype.square=function(h){return wo("square")},t.prototype.reciprocal=function(h){return wo("reciprocal")},t.prototype.relu=function(h){return wo("relu")},t.prototype.relu6=function(h){return wo("relu6")},t.prototype.prelu=function(h,g){return wo("prelu")},t.prototype.elu=function(h){return wo("elu")},t.prototype.eluDer=function(h,g){return wo("eluDer")},t.prototype.selu=function(h){return wo("selu")},t.prototype.int=function(h){return wo("int")},t.prototype.clip=function(h,g,te){return wo("clip")},t.prototype.abs=function(h){return wo("abs")},t.prototype.complexAbs=function(h){return wo("complexAbs")},t.prototype.sigmoid=function(h){return wo("sigmoid")},t.prototype.softplus=function(h){return wo("softplus")},t.prototype.sin=function(h){return wo("sin")},t.prototype.cos=function(h){return wo("cos")},t.prototype.tan=function(h){return wo("tan")},t.prototype.asin=function(h){return wo("asin")},t.prototype.acos=function(h){return wo("acos")},t.prototype.atan=function(h){return wo("atan")},t.prototype.atan2=function(h,g){return wo("atan2")},t.prototype.sinh=function(h){return wo("sinh")},t.prototype.cosh=function(h){return wo("cosh")},t.prototype.tanh=function(h){return wo("tanh")},t.prototype.asinh=function(h){return wo("asinh")},t.prototype.acosh=function(h){return wo("acosh")},t.prototype.atanh=function(h){return wo("atanh")},t.prototype.erf=function(h){return wo("erf")},t.prototype.step=function(h,g){return wo("step")},t.prototype.fusedConv2d=function(h){return h.input,h.filter,h.convInfo,h.bias,h.activation,h.preluActivationWeights,wo("fusedConv2d")},t.prototype.conv2d=function(h,g,te){return wo("conv2d")},t.prototype.conv2dDerInput=function(h,g,te){return wo("conv2dDerInput")},t.prototype.conv2dDerFilter=function(h,g,te){return wo("conv2dDerFilter")},t.prototype.fusedDepthwiseConv2D=function(h){return h.input,h.filter,h.convInfo,h.bias,h.activation,h.preluActivationWeights,wo("fusedDepthwiseConv2D")},t.prototype.depthwiseConv2D=function(h,g,te){return wo("depthwiseConv2D")},t.prototype.depthwiseConv2DDerInput=function(h,g,te){return wo("depthwiseConv2DDerInput")},t.prototype.depthwiseConv2DDerFilter=function(h,g,te){return wo("depthwiseConv2DDerFilter")},t.prototype.conv3d=function(h,g,te){return wo("conv3d")},t.prototype.conv3dDerInput=function(h,g,te){return wo("conv3dDerInput")},t.prototype.conv3dDerFilter=function(h,g,te){return wo("conv3dDerFilter")},t.prototype.maxPool=function(h,g){return wo("maxPool")},t.prototype.maxPoolBackprop=function(h,g,te,tr){return wo("maxPoolBackprop")},t.prototype.avgPool=function(h,g){return wo("avgPool")},t.prototype.avgPoolBackprop=function(h,g,te){return wo("avgPoolBackprop")},t.prototype.avgPool3d=function(h,g){return wo("avgPool3d")},t.prototype.avgPool3dBackprop=function(h,g,te){return wo("avgPool3dBackprop")},t.prototype.maxPool3d=function(h,g){return wo("maxPool3d")},t.prototype.maxPool3dBackprop=function(h,g,te,tr){return wo("maxPool3dBackprop")},t.prototype.reshape=function(h,g){return wo("reshape")},t.prototype.cast=function(h,g){return wo("cast")},t.prototype.tile=function(h,g){return wo("tile")},t.prototype.pad=function(h,g,te){return wo("pad")},t.prototype.transpose=function(h,g){return wo("transpose")},t.prototype.gather=function(h,g,te){return wo("gather")},t.prototype.gatherND=function(h,g){return wo("gatherND")},t.prototype.scatterND=function(h,g,te){return wo("scatterND")},t.prototype.batchToSpaceND=function(h,g,te){return wo("batchToSpaceND")},t.prototype.spaceToBatchND=function(h,g,te){return wo("spaceToBatchND")},t.prototype.resizeBilinear=function(h,g,te,tr){return wo("resizeBilinear")},t.prototype.resizeBilinearBackprop=function(h,g,te){return wo("resizeBilinearBackprop")},t.prototype.resizeNearestNeighbor=function(h,g,te,tr){return wo("resizeNearestNeighbor")},t.prototype.resizeNearestNeighborBackprop=function(h,g,te){return wo("resizeNearestNeighborBackprop")},t.prototype.batchNormalization=function(h,g,te,tr,to,tu){return wo("batchNormalization")},t.prototype.localResponseNormalization4D=function(h,g,te,tr,to){return wo("localResponseNormalization4D")},t.prototype.LRNGrad=function(h,g,te,tr,to,tu,tc){return wo("LRNGrad")},t.prototype.multinomial=function(h,g,te,tr){return wo("multinomial")},t.prototype.oneHot=function(h,g,te,tr){return wo("oneHot")},t.prototype.cumsum=function(h,g,te,tr){return wo("cumsum")},t.prototype.nonMaxSuppression=function(h,g,te,tr,to){return wo("nonMaxSuppression")},t.prototype.fft=function(h){return wo("fft")},t.prototype.ifft=function(h){return wo("ifft")},t.prototype.complex=function(h,g){return wo("complex")},t.prototype.real=function(h){return wo("real")},t.prototype.imag=function(h){return wo("imag")},t.prototype.cropAndResize=function(h,g,te,tr,to,tu){return wo("cropAndResize")},t.prototype.depthToSpace=function(h,g,te){return wo("depthToSpace")},t.prototype.split=function(h,g,te){return wo("split")},t.prototype.sparseToDense=function(h,g,te,tr){return wo("sparseToDense")},t.prototype.diag=function(h){return wo("diag")},t.prototype.fill=function(h,g,te){return wo("fill")},t.prototype.onesLike=function(h){return wo("onesLike")},t.prototype.zerosLike=function(h){return wo("zerosLike")},t.prototype.linspace=function(h,g,te){return wo("linspace")},t.prototype.dispose=function(){return wo("dispose")},t}();function wo(h){throw Error("'"+h+"' not yet implemented or not found in the registry. Did you forget to import the kernel?")}function Co(h,g){for(var te=h.length,tr=[],to=0;to<te;to++){var tu=te-1-to,tc=h[tu]||1;(g[g.length-1-to]||1)>1&&1===tc&&tr.unshift(tu)}return tr}function Eo(h,g){for(var te=[],tr=0;tr<g.length;tr++){var to=h[h.length-tr-1],tu=g.length-tr-1,tc=g[tu];(null==to||1===to&&tc>1)&&te.unshift(tu)}return te}function Ro(h,g){for(var te=[],tr=Math.max(h.length,g.length),to=0;to<tr;to++){var tu=h[h.length-to-1];null==tu&&(tu=1);var tc=g[g.length-to-1];if(null==tc&&(tc=1),1===tu)te.unshift(tc);else if(1===tc)te.unshift(tu);else{if(tu!==tc)throw Error("Operands could not be broadcast together with shapes "+h+" and "+g+".");te.unshift(tu)}}return te}function Io(h,g,te,tr,to,tu,tc){void 0===tc&&(tc="channelsLast");var tl,th=To(g),td=th[0],tf=th[1];if("channelsLast"===tc)tl=[td,tf,h[3],h[3]];else{if("channelsFirst"!==tc)throw Error("Unknown dataFormat "+tc);tl=[td,tf,h[1],h[1]]}return So(h,tl,te,tr,to,tu,!1,tc)}function ko(h,g,te,tr,to,tu,tc){void 0===tc&&(tc="NDHWC");var tl,th,td=No(g),tf=td[0],tp=td[1],tv=td[2];if("NDHWC"===tc)th="channelsLast",tl=[tf,tp,tv,h[4],h[4]];else{if("NCDHW"!==tc)throw Error("Unknown dataFormat "+tc);th="channelsFirst",tl=[tf,tp,tv,h[1],h[1]]}return Ao(h,tl,te,tr,to,!1,th,tu)}function So(h,g,te,tr,to,tu,tc,tl){void 0===tc&&(tc=!1),void 0===tl&&(tl="channelsLast");var th=-1,td=-1,tf=-1,tp=-1;if("channelsLast"===tl)th=h[0],td=h[1],tf=h[2],tp=h[3];else{if("channelsFirst"!==tl)throw Error("Unknown dataFormat "+tl);th=h[0],tp=h[1],td=h[2],tf=h[3]}var tv,tm=g[0],tg=g[1],ty=g[3],tx=To(te),tb=tx[0],tC=tx[1],tw=To(tr),tE=tw[0],tR=tw[1],tI=Fo(tm,tE),tk=Fo(tg,tR),tA=function(h,g,te,tr,to,tu,tc,tl){var th,td,tf;if("number"==typeof h){th={top:h,bottom:h,left:h,right:h,type:0===h?"VALID":"NUMBER"};var tp,tv,tm,tg,ty,tx,tb=(tp=[g,te],null==(tv=h)&&(tv=Do(tp,tu,tr)),tm=tp[0],tg=tp[1],C(A(ty=_o((tm-tu+2*tv)/tr+1,tl)),function(){return"The output # of rows ("+ty+") must be an integer. Change the stride and/or zero pad parameters"}),C(A(tx=_o((tg-tu+2*tv)/tr+1,tl)),function(){return"The output # of columns ("+tx+") must be an integer. Change the stride and/or zero pad parameters"}),[ty,tx]);td=tb[0],tf=tb[1]}else if("same"===h){td=Math.ceil(g/tr),tf=Math.ceil(te/to);var tC=Math.max(0,(td-1)*tr+tu-g),tw=Math.max(0,(tf-1)*to+tc-te),tE=Math.floor(tC/2),tR=Math.floor(tw/2);th={top:tE,bottom:tC-tE,left:tR,right:tw-tR,type:"SAME"}}else{if("valid"!==h)throw Error("Unknown padding parameter: "+h);th={top:0,bottom:0,left:0,right:0,type:"VALID"},td=Math.ceil((g-tu+1)/tr),tf=Math.ceil((te-tc+1)/to)}return{padInfo:th,outHeight:td,outWidth:tf}}(to,td,tf,tb,tC,tI,tk,tu),tS=tA.padInfo,tD=tA.outHeight,tN=tA.outWidth,tT=tc?ty*tp:ty;return"channelsFirst"===tl?tv=[th,tT,tD,tN]:"channelsLast"===tl&&(tv=[th,tD,tN,tT]),{batchSize:th,dataFormat:tl,inHeight:td,inWidth:tf,inChannels:tp,outHeight:tD,outWidth:tN,outChannels:tT,padInfo:tS,strideHeight:tb,strideWidth:tC,filterHeight:tm,filterWidth:tg,effectiveFilterHeight:tI,effectiveFilterWidth:tk,dilationHeight:tE,dilationWidth:tR,inShape:h,outShape:tv,filterShape:g}}function Ao(h,g,te,tr,to,tu,tc,tl){void 0===tu&&(tu=!1),void 0===tc&&(tc="channelsLast");var th=-1,td=-1,tf=-1,tp=-1,tv=-1;if("channelsLast"===tc)th=h[0],td=h[1],tf=h[2],tp=h[3],tv=h[4];else{if("channelsFirst"!==tc)throw Error("Unknown dataFormat "+tc);th=h[0],tv=h[1],td=h[2],tf=h[3],tp=h[4]}var tm,tg=g[0],ty=g[1],tx=g[2],tb=g[4],tC=No(te),tw=tC[0],tE=tC[1],tR=tC[2],tI=No(tr),tk=tI[0],tA=tI[1],tS=tI[2],tD=Fo(tg,tk),tN=Fo(ty,tA),tT=Fo(tx,tS),tF=function(h,g,te,tr,to,tu,tc,tl,th,td,tf){var tp,tv,tm,tg;if("number"==typeof h){tp={top:h,bottom:h,left:h,right:h,front:h,back:h,type:0===h?"VALID":"NUMBER"};var ty,tx,tb,tC,tw,tE,tR,tI,tk=(ty=[g,te,tr,1],null==(tx=h)&&(tx=Do(ty,tl,to)),tb=ty[0],tC=ty[1],tw=ty[2],C(A(tE=_o((tb-tl+2*tx)/to+1,tf)),function(){return"The output # of depths ("+tE+") must be an integer. Change the stride and/or zero pad parameters"}),C(A(tR=_o((tC-tl+2*tx)/to+1,tf)),function(){return"The output # of rows ("+tR+") must be an integer. Change the stride and/or zero pad parameters"}),C(A(tI=_o((tw-tl+2*tx)/to+1,tf)),function(){return"The output # of columns ("+tI+") must be an integer. Change the stride and/or zero pad parameters"}),[tE,tR,tI,1]);tv=tk[0],tm=tk[1],tg=tk[2]}else if("same"===h){tv=Math.ceil(g/to),tm=Math.ceil(te/tu),tg=Math.ceil(tr/tc);var tA=(tv-1)*to+tl-g,tS=(tm-1)*tu+th-te,tD=(tg-1)*tc+td-tr,tN=Math.floor(tA/2),tT=Math.floor(tS/2),tF=Math.floor(tD/2);tp={top:tT,bottom:tS-tT,left:tF,right:tD-tF,front:tN,back:tA-tN,type:"SAME"}}else{if("valid"!==h)throw Error("Unknown padding parameter: "+h);tp={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},tv=Math.ceil((g-tl+1)/to),tm=Math.ceil((te-th+1)/tu),tg=Math.ceil((tr-td+1)/tc)}return{padInfo:tp,outDepth:tv,outHeight:tm,outWidth:tg}}(to,td,tf,tp,tw,tE,tR,tD,tN,tT,tl),tO=tF.padInfo,t_=tF.outDepth,tM=tF.outHeight,tB=tF.outWidth,tP=tu?tb*tv:tb;return"channelsFirst"===tc?tm=[th,tP,t_,tM,tB]:"channelsLast"===tc&&(tm=[th,t_,tM,tB,tP]),{batchSize:th,dataFormat:tc,inDepth:td,inHeight:tf,inWidth:tp,inChannels:tv,outDepth:t_,outHeight:tM,outWidth:tB,outChannels:tP,padInfo:tO,strideDepth:tw,strideHeight:tE,strideWidth:tR,filterDepth:tg,filterHeight:ty,filterWidth:tx,effectiveFilterDepth:tD,effectiveFilterHeight:tN,effectiveFilterWidth:tT,dilationDepth:tk,dilationHeight:tA,dilationWidth:tS,inShape:h,outShape:tm,filterShape:g}}function Do(h,g,te,tr){void 0===tr&&(tr=1);var to=Fo(g,tr);return Math.floor((h[0]*(te-1)-te+to)/2)}function To(h){return"number"==typeof h?[h,h,h]:2===h.length?[h[0],h[1],1]:h}function No(h){return"number"==typeof h?[h,h,h]:h}function Fo(h,g){return g<=1?h:h+(h-1)*(g-1)}function _o(h,g){if(!g)return h;switch(g){case"round":return Math.round(h);case"ceil":return Math.ceil(h);case"floor":return Math.floor(h);default:throw Error("Unknown roundingMode "+g)}}function Oo(h){var g=To(h),te=g[0],tr=g[1],to=g[2];return 1===te&&1===tr&&1===to}function Mo(h,g){return Oo(h)||Oo(g)}function Bo(h){if("NHWC"===h)return"channelsLast";if("NCHW"===h)return"channelsFirst";throw Error("Unknown dataFormat "+h)}function Po(h,g,te){if("complex64"===g){if("complex64"===h.dtype)return h.clone();var tr=Gn(h.shape),to=h.toFloat(),tu=te.complex(to,tr);return tr.dispose(),to.dispose(),tu}if(!U(h.dtype,g))return tM.makeTensorFromDataId(h.dataId,h.shape,g);if("complex64"===h.dtype){var tc=te.real(h);return tu=tc.cast(g),tc.dispose(),tu}if("int32"===g)return te.int(h);if("bool"===g){var tl=On(0,h.dtype);return tu=te.notEqual(h,tl),tl.dispose(),tu}throw Error("Error in Cast: failed to cast "+h.dtype+" to "+g)}function Lo(h,g){return tM.makeTensorFromDataId(h.dataId,g,h.dtype)}function Wo(h,g,te){var tr=(g-h)/(te-1),to=tt(te,"float32");to[0]=h;for(var tu=1;tu<to.length;tu++)to[tu]=to[tu-1]+tr;return Mn(to,"float32")}function Vo(h,g){if(h.length!==g.length)throw Error("Cannot merge real and imag arrays of different lengths. real:"+h.length+", imag: "+g.length+".");for(var te=new Float32Array(2*h.length),tr=0;tr<te.length;tr+=2)te[tr]=h[tr/2],te[tr+1]=g[tr/2];return te}function zo(h,g){return{real:h[2*g],imag:h[2*g+1]}}function Ko(h,g){return h>g?1:h<g?-1:0}function jo(h,g,te,tr,to){return Yo(h,g,te,tr,to,0).selectedIndices}function Xo(h,g,te,tr,to,tu){var tc=Yo(h,g,te,tr,to,tu,!0);return tc.numValidOutputs.dispose(),{selectedIndices:tc.selectedIndices,selectedScores:tc.selectedScores}}function Yo(h,g,te,tr,to,tu,tc,tl){void 0===tc&&(tc=!1),void 0===tl&&(tl=!1);for(var th=Array.from(g).map(function(h,g){return{score:h,boxIndex:g,suppressBeginIndex:0}}).filter(function(h){return h.score>to}).sort(Jo),td=tu>0?-.5/tu:0,tf=[],tp=[];tf.length<te&&th.length>0;){var tv=th.pop(),tm=tv.score,tg=tv.boxIndex,ty=tv.suppressBeginIndex;if(tm<to)break;for(var tx=!1,tb=tf.length-1;tb>=ty;--tb){var tC=function(h,g,te){var tr=h.subarray(4*g,4*g+4),to=h.subarray(4*te,4*te+4),tu=Math.min(tr[0],tr[2]),tc=Math.min(tr[1],tr[3]),tl=Math.max(tr[0],tr[2]),th=Math.max(tr[1],tr[3]),td=Math.min(to[0],to[2]),tf=Math.min(to[1],to[3]),tp=Math.max(to[0],to[2]),tv=Math.max(to[1],to[3]),tm=(tl-tu)*(th-tc),tg=(tp-td)*(tv-tf);if(tm<=0||tg<=0)return 0;var ty=Math.max(Math.min(tl,tp)-Math.max(tu,td),0)*Math.max(Math.min(th,tv)-Math.max(tc,tf),0);return ty/(tm+tg-ty)}(h,tg,tf[tb]);if(tC>=tr){tx=!0;break}if(tv.score=tv.score*function(h,g,te){var tr=Math.exp(g*te*te);return te<=h?tr:0}(tr,td,tC),tv.score<=to)break}tv.suppressBeginIndex=tf.length,tx||(tv.score===tm?(tf.push(tg),tp.push(tv.score)):tv.score>to&&function(h,g,te){var tr=function(h,g,te){for(var tr=0,to=h.length,tu=0,tc=!1;tr<to;){var tl=te(g,h[tu=tr+(to-tr>>>1)]);tl>0?tr=tu+1:(to=tu,tc=!tl)}return tc?tr:-tr-1}(h,g,te||Ko),to=tr<0?-(tr+1):tr;h.splice(to,0,g)}(th,tv,Jo))}var tw=tf.length;return tl&&(tf.fill(0,tw),tp.fill(0,tw)),{selectedIndices:Mn(tf,"int32"),selectedScores:Mn(tp,"float32"),numValidOutputs:On(tw,"int32")}}function Jo(h,g){return h.score-g.score||h.score===g.score&&g.boxIndex-h.boxIndex}function Zo(h,g,te){var tr=Array(h.rank).fill(0),to=h.shape.slice();return g.map(function(g){to[te]=g;var tu=h.slice(tr,to);return tr[te]+=g,tu})}function ta(h,g){for(var te=Array(h.rank),tr=0;tr<te.length;tr++)te[tr]=h.shape[tr]*g[tr];var to=dr(te,h.dtype);for(tr=0;tr<to.values.length;++tr){for(var tu=to.indexToLoc(tr),tc=Array(h.rank),tl=0;tl<tc.length;tl++)tc[tl]=tu[tl]%h.shape[tl];var th=h.locToIndex(tc);to.values[tr]=h.values[th]}return to.toTensor()}function ea(h,g,te,tr,to){for(var tu=g[g.length-1],tc=[h.length/tu,tu],tl=tc[0],th=tc[1],td=B(te,tl*tr),tf=B("int32",tl*tr),tp=0;tp<tl;tp++){for(var tv=tp*th,tm=h.subarray(tv,tv+th),tg=[],ty=0;ty<tm.length;ty++)tg.push({value:tm[ty],index:ty});tg.sort(function(h,g){return g.value-h.value});var tx=tp*tr,tb=td.subarray(tx,tx+tr),tC=tf.subarray(tx,tx+tr);for(ty=0;ty<tr;ty++)tb[ty]=tg[ty].value,tC[ty]=tg[ty].index}var tw=g.slice();return tw[tw.length-1]=tr,[Fn(td,tw,te),Fn(tf,tw,"int32")]}function na(h,g){for(var te=[],tr=0;tr<g.length;tr++)g[tr]&&te.push(tr);var to=dr(h,"int32"),tu=dr([te.length,h.length],"int32");for(tr=0;tr<te.length;tr++){var tc=to.indexToLoc(te[tr]),tl=tr*h.length;tu.values.set(tc,tl)}return tu.toTensor()}Object.freeze({castTensor:Po,reshapeTensor:Lo,linspaceImpl:Wo,upcastType:Dt,axesAreInnerMostDims:yn,combineLocations:xn,computeOutAndReduceShapes:bn,expandShapeToKeepDim:wn,assertAxesAreInnerMostDims:Cn,getAxesPermutation:En,getUndoAxesPermutation:Rn,getInnerMostAxes:In,getBroadcastDims:Co,getReductionAxes:Eo,assertAndGetBroadcastShape:Ro,assertParamsConsistent:kn,computeOutShape:Sn,computePool2DInfo:Io,computePool3DInfo:ko,computeConv2DInfo:So,computeConv3DInfo:Ao,computeDefaultPad:Do,tupleValuesAreOne:Oo,eitherStridesOrDilationsAreOne:Mo,convertConv2DDataFormat:Bo,PARALLELIZE_THRESHOLD:30,computeOptimalWindowSize:$r});var ra=function(h,g){this.outputShape=[],this.outputShape=h,this.variableNames=g.map(function(h,g){return"T"+g});var te=[];this.variableNames.forEach(function(h){te.push("float v"+h+" = get"+h+"AtOutCoords();")});var tr=this.variableNames.map(function(h){return"v"+h}).join(" + ");this.userCode="\n      void main() {\n        "+te.join("\n        ")+"\n\n        float result = "+tr+";\n        setOutput(result);\n      }\n    "},oa=function(h,g){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=h,this.variableNames=g.map(function(h,g){return"T"+g});var te=[];this.variableNames.forEach(function(h){te.push("vec4 v"+h+" = get"+h+"AtOutCoords();")});var tr=this.variableNames.map(function(h){return"v"+h}).join(" + ");this.userCode="\n      void main() {\n        "+te.join("\n        ")+"\n\n        vec4 result = "+tr+";\n        setOutput(result);\n      }\n    "},aa=function(h,g,te){this.variableNames=["A"];var tr=h.windowSize,to=h.batchSize,tu=Math.ceil(h.inSize/tr);te||this.variableNames.push("bestIndicesA"),this.outputShape=[to,tu],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+tr+";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < "+tr+"; i++) {\n          int inIdx = "+(te?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));")+";\n          float candidate = getA(batch, inIdx);\n          if (candidate "+("max"===g?">":"<")+" bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    "};function ia(h,g){return["x","y","z","w","u","v"].slice(0,g).map(function(g){return h+"."+g})}function sa(h,g){return 1===g?[h]:ia(h,g)}function ua(){var h,g,te,tr,to,tu,tc,th,td,tf;return 2===tl.getNumber("WEBGL_VERSION")?(h="#version 300 es",g="in",te="out",tr="in",to="texture",tu="outputColor",tc="out vec4 outputColor;",th="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",td="",tf="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(h="",g="attribute",te="varying",tr="varying",to="texture2D",tu="gl_FragColor",tc="",th="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",td="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",tf="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:h,attribute:g,varyingVs:te,varyingFs:tr,texture2D:to,output:tu,defineOutput:tc,defineSpecialNaN:th,defineSpecialInf:td,defineRound:tf}}function ca(h,g,te){void 0===te&&(te="index");var tr=$(g);return tr.map(function(g,to){return"int "+h[to]+" = "+te+" / "+g+"; "+(to===tr.length-1?"int "+h[to+1]+" = "+te+" - "+h[to]+" * "+g:"index -= "+h[to]+" * "+g)+";"}).join("")}function la(h){var g=$(h).map(function(h){return h.toString()});return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * "+g[0]+" + coords.y * "+g[1]+" + coords.z;\n  }\n"}var nq="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";function xa(h){return"offset"+h}function ba(h){var g=h.name,te=k(h.shapeInfo.logicalShape);return te<2?"return "+g+";":"\n    for (int i = 0; i < "+te+"; i++) {\n      if (i == index) {\n        return "+g+"[i];\n      }\n    }\n  "}function wa(h){if(h<=1)return"int";if(2===h)return"ivec2";if(3===h)return"ivec3";if(4===h)return"ivec4";if(5===h)return"ivec5";if(6===h)return"ivec6";throw Error("GPU for rank "+h+" is not yet supported")}function Ca(h,g){var te=JSON.parse(JSON.stringify(h));return te.shapeInfo.logicalShape=g,te}function Ea(h,g){return g.map(function(g){return h[g]}).join(", ")}var Ra=function(h,g,te,tr){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,C(h.length>2,function(){return"Packed arg"+(te.charAt(0).toUpperCase()+te.slice(1))+" supports only inputs with rank above 2."});var to=Math.ceil(h[h.length-1]/g);this.outputShape=h.slice(0,-1),to>1&&this.outputShape.push(to),tr||this.variableNames.push("bestIndicesA");var tu,tc,tl=this.outputShape,th=tl.length,td=wa(th),tf=sa("coords",th);if(1===to){var tp=wa(tc=th+1);tu="\n        "+tp+" sourceLocR = "+tp+"("+tf.join()+", 0);\n        ++"+tf[th-1]+";\n        "+tp+" sourceLocG = "+tp+"("+tf.join()+", 0);\n        ++"+tf[th-2]+";\n        "+tp+" sourceLocA = "+tp+"("+tf.join()+", 0);\n        --"+tf[th-1]+";\n        "+tp+" sourceLocB = "+tp+"("+tf.join()+", 0);\n        --"+tf[th-2]+";"}else tc=th,tu="\n        "+td+" sourceLocR = coords;\n        ++"+tf[th-1]+";\n        "+td+" sourceLocG = coords;\n        ++"+tf[th-2]+";\n        "+td+" sourceLocA = coords;\n        --"+tf[th-1]+";\n        "+td+" sourceLocB = coords;\n        --"+tf[th-2]+";";var tv=["x","y","z","w","u","v"].slice(0,tc),tm="."+tv[tc-1],tg=tv.map(function(h){return"int "+h}),ty=sa("sourceLocR",tc-1).concat("inIdx.r"),tx=sa("sourceLocG",tc-1).concat("inIdx.g"),tb=sa("sourceLocB",tc-1).concat("inIdx.b"),tC=sa("sourceLocA",tc-1).concat("inIdx.a"),tw=tr?"":"\n          inIdx = round(vec4(getBestIndicesAChannel("+ty.join()+"),\n                             getBestIndicesAChannel("+tx.join()+"),\n                             getBestIndicesAChannel("+tb.join()+"),\n                             getBestIndicesAChannel("+tC.join()+")));",tE="vec4(\n            getAChannel("+ty.join()+"),\n            hasNextCol ? getAChannel("+tx.join()+") : 0.,\n            hasNextRow ? getAChannel("+tb.join()+") : 0.,\n            hasNextRow && hasNextCol ? getAChannel("+tC.join()+") : 0.)",tR=tr?"":"\n      float getBestIndicesAChannel("+tg.join()+") {\n        return getChannel(getBestIndicesA("+tv.join()+"),\n                                          vec2("+tv.slice(-2).join()+"));\n      }";this.userCode="\n      float getAChannel("+tg.join()+") {\n        return getChannel(getA("+tv.join()+"),\n                               vec2("+tv.slice(-2).join()+"));\n      }\n      "+tR+"\n      void main() {\n        "+td+" coords = getOutputCoords();\n        bool hasNextCol = "+tf[th-1]+" < "+(tl[th-1]-1)+";\n        bool hasNextRow = "+tf[th-2]+" < "+(tl[th-2]-1)+";\n        "+tu+"\n        ivec4 srcIdx = ivec4(sourceLocR"+tm+", sourceLocG"+tm+",\n          sourceLocB"+tm+", sourceLocA"+tm+") * "+g+";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = "+tE+";\n\n        for (int i = 0; i < "+g+"; i++) {\n          inIdx = srcIdx;\n          "+tw+"\n          vec4 candidate = "+tE+";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4("+("max"===te?"greaterThan":"lessThan")+"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    "},Ia=function(h){this.variableNames=["dy"],this.outputShape=h.inShape;var g=h.filterHeight,te=h.filterWidth,tr=h.strideHeight,to=h.strideWidth,tu=h.dilationHeight,tc=h.dilationWidth,tl=h.effectiveFilterHeight,th=h.effectiveFilterWidth,td=tl-1-h.padInfo.top,tf=th-1-h.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2("+td+", "+tf+");\n      const float avgMultiplier = float("+1/(g*te)+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+tl+";\n            wR += "+tu+") {\n          float dyR = float(dyRCorner + wR) / "+tr+".0;\n\n          if (dyR < 0.0 || dyR >= "+h.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+th+";\n            wC+= "+tc+") {\n            float dyC = float(dyCCorner + wC) / "+to+".0;\n\n            if (dyC < 0.0 || dyC >= "+h.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},ka=function(h){this.variableNames=["dy"],this.outputShape=h.inShape;var g=h.filterDepth,te=h.filterHeight,tr=h.filterWidth,to=h.strideDepth,tu=h.strideHeight,tc=h.strideWidth,tl=h.dilationDepth,th=h.dilationHeight,td=h.dilationWidth,tf=h.effectiveFilterDepth,tp=h.effectiveFilterHeight,tv=h.effectiveFilterWidth,tm=tf-1-h.padInfo.front,tg=tp-1-h.padInfo.top,ty=tv-1-h.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3("+tm+", "+tg+", "+ty+");\n      const float avgMultiplier = float("+1/(g*te*tr)+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < "+tf+";\n            wD += "+tl+") {\n          float dyD = float(dyDCorner + wD) / "+to+".0;\n\n          if (dyD < 0.0 || dyD >= "+h.outDepth+".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < "+tp+";\n              wR += "+th+") {\n            float dyR = float(dyRCorner + wR) / "+tu+".0;\n\n            if (dyR < 0.0 || dyR >= "+h.outHeight+".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < "+tv+";\n                wC += "+td+") {\n              float dyC = float(dyCCorner + wC) / "+tc+".0;\n\n              if (dyC < 0.0 || dyC >= "+h.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Sa=function(h,g,te,tr,to,tu){this.outputShape=[],this.variableNames=["x","mean","variance"],Ro(h,g),Ro(h,te);var tc="0.0";null!=tr&&(Ro(h,tr),this.variableNames.push("offset"),tc="getOffsetAtOutCoords()");var tl="1.0";null!=to&&(Ro(h,to),this.variableNames.push("scale"),tl="getScaleAtOutCoords()"),this.outputShape=h,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = "+tc+";\n        float scale = "+tl+";\n        float inv = scale * inversesqrt(variance + float("+tu+"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    "},Aa=function(h,g,te,tr,to,tu){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ro(h,g),Ro(h,te);var tc="vec4(0.0)";null!=tr&&(Ro(h,tr),this.variableNames.push("offset"),tc="getOffsetAtOutCoords()");var tl="vec4(1.0)";null!=to&&(Ro(h,to),this.variableNames.push("scale"),tl="getScaleAtOutCoords()"),this.outputShape=h,this.userCode="\n      void main() {\n        vec4 offset = "+tc+";\n        vec4 scale = "+tl+";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4("+tu+"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    "},Na=function(h,g,te){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ro(g,te),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        "+h+"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    "},nK="return a + b;",nj="return a - b;",nX="return a * b;",n$="return (a < 0.) ? b * a : a;",Ba=function(h,g,te){this.variableNames=["A","B"],this.outputShape=Ro(g,te),this.userCode="\n      float binaryOperation(float a, float b) {\n        "+h+"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    "},nY="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",La=function(h,g,te,tr){void 0===tr&&(tr=!1),this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ro(g,te);var to=this.outputShape.length,tu="";if(tr){if(0===to||1===k(this.outputShape))tu="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(tu="\n          "+wa(to)+" coords = getOutputCoords();\n        ",1===to)tu+="\n            result.y = (coords + 1) >= "+this.outputShape[0]+" ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";else{var tc=sa("coords",to);tu+="\n            bool nextRowOutOfBounds =\n              ("+tc[to-2]+" + 1) >= "+this.outputShape[to-2]+";\n            bool nextColOutOfBounds =\n              ("+tc[to-1]+" + 1) >= "+this.outputShape[to-1]+";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "}}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        "+h+"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        "+tu+"\n\n        setOutput(result);\n      }\n    "},nJ=function(){function t(h){this.variableNames=["A"],this.outputShape=h,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(h,g){var te=this;return function(tr,to){null==te.minLoc&&(te.minLoc=tr.getUniformLocationNoThrow(to,"minVal"),te.maxLoc=tr.getUniformLocationNoThrow(to,"maxVal")),tr.gl.uniform1f(te.minLoc,h),tr.gl.uniform1f(te.maxLoc,g)}},t}(),nQ=function(){function t(h){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=h,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(h,g){var te=this;return function(tr,to){null==te.minLoc&&(te.minLoc=tr.getUniformLocationNoThrow(to,"minVal"),te.maxLoc=tr.getUniformLocationNoThrow(to,"maxVal")),tr.gl.uniform1f(te.minLoc,h),tr.gl.uniform1f(te.maxLoc,g)}},t}(),Va=function(h){this.variableNames=["real","imag"],this.outputShape=h,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "},za=function(h){this.outputShape=[],this.outputShape=Sn(h,1),this.variableNames=h.map(function(h,g){return"T"+g});var g=Array(h.length-1);g[0]=h[0][1];for(var te=1;te<g.length;te++)g[te]=g[te-1]+h[te][1];var tr=["if (yC < "+g[0]+") setOutput(getT0(yR, yC));"];for(te=1;te<g.length;te++){var to=g[te-1];tr.push("else if (yC < "+g[te]+") setOutput(getT"+te+"(yR, yC-"+to+"));")}var tu=g.length,tc=g[g.length-1];tr.push("else setOutput(getT"+tu+"(yR, yC-"+tc+"));"),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        "+tr.join("\n        ")+"\n      }\n    "},Ga=function(h,g){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Sn(h,g);var te=this.outputShape,tr=te.length,to=wa(tr),tu=sa("coords",tr),tc=["x","y","z","w","u","v"].slice(0,tr);this.variableNames=h.map(function(h,g){return"T"+g});var tl=Array(h.length-1);tl[0]=h[0][g];for(var th=1;th<tl.length;th++)tl[th]=tl[th-1]+h[th][g];var td=tc[g],tf=tc.slice(-2),tp=tc.join(),tv="if ("+td+" < "+tl[0]+") {\n        return getChannel(\n            getT0("+tp+"), vec2("+tf.join()+"));\n        }";for(th=1;th<tl.length;th++){var tm=tl[th-1];tv+="\n        if ("+td+" < "+tl[th]+"  && "+td+" >= "+tl[th-1]+") {\n          return getChannel(\n            getT"+th+"("+Ha(tc,td,tm)+"),\n            vec2("+Ha(tf,td,tm)+"));\n        }"}var tg=tl.length,ty=tl[tl.length-1];tv+="\n        return getChannel(\n          getT"+tg+"("+Ha(tc,td,ty)+"),\n          vec2("+Ha(tf,td,ty)+"));",this.userCode="\n      float getValue("+tc.map(function(h){return"int "+h})+") {\n        "+tv+"\n      }\n\n      void main() {\n        "+to+" coords = getOutputCoords();\n        vec4 result = vec4(getValue("+tu+"), 0., 0., 0.);\n\n        "+tu[tr-1]+" = "+tu[tr-1]+" + 1;\n        if ("+tu[tr-1]+" < "+te[tr-1]+") {\n          result.g = getValue("+tu+");\n        }\n\n        "+tu[tr-2]+" = "+tu[tr-2]+" + 1;\n        if ("+tu[tr-2]+" < "+te[tr-2]+") {\n          result.a = getValue("+tu+");\n        }\n\n        "+tu[tr-1]+" = "+tu[tr-1]+" - 1;\n        if ("+tu[tr-2]+" < "+te[tr-2]+" &&\n            "+tu[tr-1]+" < "+te[tr-1]+") {\n          result.b = getValue("+tu+");\n        }\n        setOutput(result);\n      }\n    "};function Ha(h,g,te){var tr=h.indexOf(g);return h.map(function(h,g){return g===tr?h+" - "+te:h}).join()}var qa=function(h){this.variableNames=["x","dy"],this.outputShape=h.filterShape;var g=h.strideHeight,te=h.strideWidth,tr=h.padInfo.top,to=h.padInfo.left,tu="channelsLast"===h.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+h.batchSize+"; b++) {\n          for (int yR = 0; yR < "+h.outHeight+"; yR++) {\n            int xR = wR + yR * "+g+" - "+tr+";\n\n            if (xR < 0 || xR >= "+h.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+h.outWidth+"; yC++) {\n              int xC = wC + yC * "+te+" - "+to+";\n\n              if (xC < 0 || xC >= "+h.inWidth+") {\n                continue;\n              }\n\n              if ("+tu+") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Ka=function(h){this.variableNames=["dy","W"],this.outputShape=h.inShape;var g=h.filterHeight,te=h.filterWidth,tr=h.strideHeight,to=h.strideWidth,tu="channelsLast"===h.dataFormat,tc=g-1-h.padInfo.top,tl=te-1-h.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2("+tc+", "+tl+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords["+(tu?3:1)+"];\n\n        ivec2 dyCorner = ivec2(coords["+(tu?1:2)+"], coords["+(tu?2:3)+"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+g+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+tr+".0;\n\n          if (dyR < 0.0 || dyR >= "+h.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+g+" - 1 - wR;\n\n          for (int wC = 0; wC < "+te+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+to+".0;\n\n            if (dyC < 0.0 || dyC >= "+h.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+te+" - 1 - wC;\n\n            for (int d2 = 0; d2 < "+h.outChannels+"; d2++) {\n\n              if ("+tu+") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},ja=function(h){this.variableNames=["x","dy"],this.outputShape=h.filterShape;var g=h.strideDepth,te=h.strideHeight,tr=h.strideWidth,to=h.padInfo.front,tu=h.padInfo.top,tc=h.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+h.batchSize+"; b++) {\n          for (int yF = 0; yF < "+h.outDepth+"; yF++) {\n            int xF = wF + yF * "+g+" - "+to+";\n\n            if (xF < 0 || xF >= "+h.inDepth+") {\n              continue;\n            }\n\n            for (int yR = 0; yR < "+h.outHeight+"; yR++) {\n              int xR = wR + yR * "+te+" - "+tu+";\n\n              if (xR < 0 || xR >= "+h.inHeight+") {\n                continue;\n              }\n\n              for (int yC = 0; yC < "+h.outWidth+"; yC++) {\n                int xC = wC + yC * "+tr+" - "+tc+";\n\n                if (xC < 0 || xC >= "+h.inWidth+") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Xa=function(h){this.variableNames=["dy","W"],this.outputShape=h.inShape;var g=h.filterDepth,te=h.filterHeight,tr=h.filterWidth,to=h.strideDepth,tu=h.strideHeight,tc=h.strideWidth,tl=g-1-h.padInfo.front,th=te-1-h.padInfo.top,td=tr-1-h.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3("+tl+", "+th+", "+td+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < "+g+"; wF++) {\n          float dyF = float(dyFCorner + wF) / "+to+".0;\n\n          if (dyF < 0.0 || dyF >= "+h.outDepth+".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = "+g+" - 1 - wF;\n\n          for (int wR = 0; wR < "+te+"; wR++) {\n            float dyR = float(dyRCorner + wR) / "+tu+".0;\n\n            if (dyR < 0.0 || dyR >= "+h.outHeight+".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = "+te+" - 1 - wR;\n\n            for (int wC = 0; wC < "+tr+"; wC++) {\n              float dyC = float(dyCCorner + wC) / "+tc+".0;\n\n              if (dyC < 0.0 || dyC >= "+h.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = "+tr+" - 1 - wC;\n\n              for (int d2 = 0; d2 < "+h.outChannels+"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Ya=function(h){this.variableNames=["x","dy"],this.outputShape=h.filterShape;var g=h.strideHeight,te=h.strideWidth,tr=h.padInfo.top,to=h.padInfo.left,tu=h.outChannels/h.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * "+tu+" + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < "+h.batchSize+"; b++) {\n          for (int yR = 0; yR < "+h.outHeight+"; yR++) {\n            int xR = wR + yR * "+g+" - "+tr+";\n\n            if (xR < 0 || xR >= "+h.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+h.outWidth+"; yC++) {\n              int xC = wC + yC * "+te+" - "+to+";\n\n              if (xC < 0 || xC >= "+h.inWidth+") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},$a=function(h){this.variableNames=["dy","W"],this.outputShape=h.inShape;var g=h.filterHeight,te=h.filterWidth,tr=h.strideHeight,to=h.strideWidth,tu=g-1-h.padInfo.top,tc=te-1-h.padInfo.left,tl=h.outChannels/h.inChannels;this.userCode="\n      const ivec2 pads = ivec2("+tu+", "+tc+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < "+g+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+tr+".0;\n\n          if (dyR < 0.0 || dyR >= "+h.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+g+" - 1 - wR;\n\n          for (int wC = 0; wC < "+te+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+to+".0;\n\n            if (dyC < 0.0 || dyC >= "+h.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+te+" - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < "+tl+"; dm++) {\n              int d2 = d1 * "+tl+" + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Qa=function(h,g,te,tr){void 0===g&&(g=!1),void 0===te&&(te=null),void 0===tr&&(tr=!1),this.variableNames=["x","W"],this.outputShape=h.outShape;var to=h.padInfo.top,tu=h.padInfo.left,tc=h.strideHeight,tl=h.strideWidth,th=h.dilationHeight,td=h.dilationWidth,tf=h.filterHeight,tp=h.filterWidth,tv=4*Math.floor(h.inChannels/4),tm=h.inChannels%4,tg="channelsLast"===h.dataFormat,ty="",tx="";te&&(ty=tr?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          "+te+"\n        }":"\n          float activation(float x) {\n            "+te+"\n          }\n        ",tx="result = activation(result);");var tb=g?"result += getBiasAtOutCoords();":"";g&&this.variableNames.push("bias"),tr&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+ty+"\n\n      const ivec2 strides = ivec2("+tc+", "+tl+");\n      const ivec2 pads = ivec2("+to+", "+tu+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords["+(tg?3:1)+"];\n\n        ivec2 xRCCorner =\n            ivec2(coords["+(tg?1:2)+"], coords["+(tg?2:3)+"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+tf+"; wR++) {\n          int xR = xRCorner + wR * "+th+";\n\n          if (xR < 0 || xR >= "+h.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+tp+"; wC++) {\n            int xC = xCCorner + wC * "+td+";\n\n            if (xC < 0 || xC >= "+h.inWidth+") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < "+tv+"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if ("+tg+") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if ("+(1===tm)+") {\n\n              if ("+tg+") {\n                dotProd +=\n                    getX(batch, xR, xC, "+tv+") *\n                    getW(wR, wC, "+tv+", d2);\n              } else {\n                dotProd +=\n                    getX(batch, "+tv+", xR, xC) *\n                    getW(wR, wC, "+tv+", d2);\n              }\n\n            } else if ("+(2===tm)+") {\n              vec2 wValues = vec2(\n                getW(wR, wC, "+tv+", d2),\n                getW(wR, wC, "+tv+" + 1, d2)\n              );\n\n              if ("+tg+") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, "+tv+"),\n                  getX(batch, xR, xC, "+tv+" + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, "+tv+", xR, xC),\n                  getX(batch, "+tv+" + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if ("+(3===tm)+") {\n              vec3 wValues = vec3(\n                getW(wR, wC, "+tv+", d2),\n                getW(wR, wC, "+tv+" + 1, d2),\n                getW(wR, wC, "+tv+" + 2, d2)\n              );\n\n              if ("+tg+") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, "+tv+"),\n                  getX(batch, xR, xC, "+tv+" + 1),\n                  getX(batch, xR, xC, "+tv+" + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, "+tv+", xR, xC),\n                  getX(batch, "+tv+" + 1, xR, xC),\n                  getX(batch, "+tv+" + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        "+tb+"\n        "+tx+"\n        setOutput(result);\n      }\n    "},Ja=function(h){this.variableNames=["x","W"],this.outputShape=h.outShape;var g=h.padInfo.front,te=h.padInfo.top,tr=h.padInfo.left,to=h.strideDepth,tu=h.strideHeight,tc=h.strideWidth,tl=h.dilationDepth,th=h.dilationHeight,td=h.dilationWidth,tf=h.filterDepth,tp=h.filterHeight,tv=h.filterWidth,tm=4*Math.floor(h.inChannels/4),tg=h.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3("+to+", "+tu+", "+tc+");\n      const ivec3 pads = ivec3("+g+", "+te+", "+tr+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < "+tf+"; wF++) {\n          int xF = xFCorner + wF * "+tl+";\n\n          if (xF < 0 || xF >= "+h.inDepth+") {\n            continue;\n          }\n\n          for (int wR = 0; wR < "+tp+"; wR++) {\n            int xR = xRCorner + wR * "+th+";\n\n            if (xR < 0 || xR >= "+h.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+tv+"; wC++) {\n              int xC = xCCorner + wC * "+td+";\n\n              if (xC < 0 || xC >= "+h.inWidth+") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < "+tm+"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if ("+(1===tg)+") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, "+tm+") *\n                  getW(wF, wR, wC, "+tm+", d2);\n              } else if ("+(2===tg)+") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, "+tm+"),\n                  getX(batch, xF, xR, xC, "+tm+" + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, "+tm+", d2),\n                  getW(wF, wR, wC, "+tm+" + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if ("+(3===tg)+") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, "+tm+"),\n                  getX(batch, xF, xR, xC, "+tm+" + 1),\n                  getX(batch, xF, xR, xC, "+tm+" + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, "+tm+", d2),\n                  getW(wF, wR, wC, "+tm+" + 1, d2),\n                  getW(wF, wR, wC, "+tm+" + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Za=function(h,g,te,tr){void 0===g&&(g=!1),void 0===te&&(te=null),void 0===tr&&(tr=!1),this.variableNames=["x","W"],this.outputShape=h.outShape;var to=h.inHeight,tu=h.inWidth,tc=h.padInfo.top,tl=h.padInfo.left,th=h.strideHeight,td=h.strideWidth,tf=h.dilationHeight,tp=h.dilationWidth,tv=h.filterHeight,tm=h.filterWidth,tg=h.outChannels/h.inChannels,ty="",tx="";te&&(ty=tr?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          "+te+"\n        }":"\n          float activation(float x) {\n            "+te+"\n          }\n        ",tx="result = activation(result);");var tb=g?"result += getBiasAtOutCoords();":"";g&&this.variableNames.push("bias"),tr&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+ty+"\n\n      const ivec2 strides = ivec2("+th+", "+td+");\n      const ivec2 pads = ivec2("+tc+", "+tl+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / "+tg+";\n        int q = d2 - d1 * "+tg+";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < "+tv+"; wR++) {\n          int xR = xRCorner + wR * "+tf+";\n\n          if (xR < 0 || xR >= "+to+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+tm+"; wC++) {\n            int xC = xCCorner + wC * "+tp+";\n\n            if (xC < 0 || xC >= "+tu+") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        "+tb+"\n        "+tx+"\n        setOutput(result);\n      }\n    "},ti=function(h,g,te,tr){void 0===g&&(g=!1),void 0===te&&(te=null),void 0===tr&&(tr=!1),this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=h.outShape;for(var to=h.inHeight,tu=h.inWidth,tc=h.padInfo.top,tl=h.padInfo.left,th=h.strideHeight,td=h.strideWidth,tf=h.dilationHeight,tp=h.dilationWidth,tv=h.filterHeight,tm=h.filterWidth,tg="int xR; int xC; int xCOffset;",ty=0;ty<tv;ty++)for(var tx=0;tx<tm;tx++)tg+="\n          vec4 xTexelR"+ty+"C"+2*tx+" = vec4(0.);\n          vec4 wR"+ty+"C"+tx+" = vec4(0.);\n          vec4 xR"+ty+"C"+tx+" = vec4(0.);";for(ty=0;ty<tv;ty++)for(var tb=0;tb<tm;tb++){if(tg+="\n          xR = xRCorner + "+ty*tf+";\n          xC = xCCorner + "+(tx=2*tb)*tp+";\n        ",1===td){if(tx<tm&&(tg+=tl%2==1?"\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < "+to+" && xCOffset >= 0 && xCOffset < "+tu+") {\n                  xTexelR"+ty+"C"+tx+" = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= "+tu+") {\n                    xTexelR"+ty+"C"+tx+".zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR"+ty+"C"+tx+" = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < "+to+" && xCOffset >= 0 && xCOffset < "+tu+") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= "+tu+") {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR"+ty+"C"+tx+" = vec4(previous.zw, xTexelR"+ty+"C"+tx+".xy);\n                } else {\n                  xR"+ty+"C"+tx+" = vec4(0, 0, xTexelR"+ty+"C"+tx+".xy);\n                }\n              ":"\n                if(xR >= 0 && xR < "+to+" && xC >= 0 && xC < "+tu+") {\n                  xTexelR"+ty+"C"+tx+" = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR"+ty+"C"+tx+" = vec4(0.);\n                }\n\n                xR"+ty+"C"+tx+" = xTexelR"+ty+"C"+tx+";\n              ",tx+1<tm)){var tC=tl%2==0?b(tp):tp;tp%2==0&&tl%2==1||tp%2!=0&&tl%2!=1?(tg+="\n                  xCOffset = xC + "+tl%2+" + "+tC+";\n\n                  if(xR >= 0 && xR < "+to+" &&\n                    xCOffset >= 0 && xCOffset < "+tu+") {\n                    xTexelR"+ty+"C"+(tx+2)+" = getX(batch, xR, xCOffset, d1);\n                  }\n                ",tp>1&&(tg+="\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < "+to+" &&\n                      xCOffset >= 0 && xCOffset < "+tu+") {\n                      xTexelR"+ty+"C"+tx+" = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR"+ty+"C"+tx+" = vec4(0.);\n                    }\n                  "),tg+="\n                  xR"+ty+"C"+(tx+1)+" = vec4(\n                    xTexelR"+ty+"C"+tx+".zw, xTexelR"+ty+"C"+(tx+2)+".xy);\n                "):tg+="\n                  xCOffset = xC + "+tC+";\n\n                  if(xR >= 0 && xR < "+to+" &&\n                    xCOffset >= 0 && xCOffset < "+tu+") {\n                    xTexelR"+ty+"C"+(tx+2)+" = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR"+ty+"C"+(tx+1)+" = xTexelR"+ty+"C"+(tx+2)+";\n                "}}else tx<tm&&(tg+="\n              if(xR >= 0 && xR < "+to+") {\n            ",tl%2==1?(tg+="\n                xCOffset = xC + 1 - "+td+";\n                if(xCOffset >= 0 && xCOffset < "+tu+") {\n                  xTexelR"+ty+"C"+tx+" = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+ty+"C"+tx+" = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < "+tu+") {\n                  xTexelR"+ty+"C"+(tx+2)+" = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR"+ty+"C"+(tx+2)+" = vec4(0.);\n                }\n\n                xR"+ty+"C"+tx+" = vec4(\n                  xTexelR"+ty+"C"+tx+".zw, xTexelR"+ty+"C"+(tx+2)+".zw);\n              ",tx+1<tm&&(tg+="\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + "+td+";\n                  if(xCOffset >= 0 && xCOffset < "+tu+") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR"+ty+"C"+(tx+1)+" = vec4(xTexelR"+ty+"C"+(tx+2)+".xy, final.xy);\n                ")):(tg+="\n                if(xC >= 0 && xC < "+tu+") {\n                  xTexelR"+ty+"C"+tx+" = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR"+ty+"C"+tx+" = vec4(0.);\n                }\n\n                xCOffset = xC + "+td+";\n                if(xCOffset >= 0 && xCOffset < "+tu+") {\n                  xTexelR"+ty+"C"+(tx+2)+" = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+ty+"C"+(tx+2)+" = vec4(0.);\n                }\n\n                xR"+ty+"C"+tx+" = vec4(\n                  xTexelR"+ty+"C"+tx+".xy, xTexelR"+ty+"C"+(tx+2)+".xy);\n              ",tx+1<tm&&(tg+="\n                  xR"+ty+"C"+(tx+1)+" = vec4(\n                    xTexelR"+ty+"C"+tx+".zw, xTexelR"+ty+"C"+(tx+2)+".zw);\n                ")),tg+="}");tx<tm&&(tg+="\n            vec4 wTexelR"+ty+"C"+tx+" = getW("+ty+", "+tx+", d1, q);\n            wR"+ty+"C"+tx+" = vec4(wTexelR"+ty+"C"+tx+".xz, wTexelR"+ty+"C"+tx+".xz);\n          ",tx+1<tm&&(tg+="\n              vec4 wTexelR"+ty+"C"+(tx+1)+" = getW("+ty+", "+(tx+1)+", d1, q);\n              wR"+ty+"C"+(tx+1)+" =\n                vec4(wTexelR"+ty+"C"+(tx+1)+".xz, wTexelR"+ty+"C"+(tx+1)+".xz);"))}for(ty=0;ty<tv;ty++)for(tx=0;tx<tm;tx++)tg+="dotProd += xR"+ty+"C"+tx+" * wR"+ty+"C"+tx+";";var tw="",tE="";te&&(tw=tr?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          "+te+"\n        }":"vec4 activation(vec4 x) {\n          "+te+"\n        }",tE="result = activation(result);");var tR=g?"result += getBiasAtOutCoords();":"";g&&this.variableNames.push("bias"),tr&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+tw+"\n\n      const ivec2 strides = ivec2("+th+", "+td+");\n      const ivec2 pads = ivec2("+tc+", "+tl+");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        "+tg+"\n\n        vec4 result = dotProd;\n        "+tR+"\n        "+tE+"\n        setOutput(result);\n      }\n    "},ei=function(h,g,te,tr,to){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];var tu=h[0],tc=h[1],tl=h[2],th=h[3],td=g[0],tf=te[0],tp=te[1];this.outputShape=[td,tf,tp,th];var tv=[tc-1+".0",tl-1+".0"],tm=tv[0],tg=tv[1],ty=tf>1?[""+(tc-1)/(tf-1),"(y2-y1) * height_ratio","y1*"+tm+" + float(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+tm],tx=ty[0],tb=ty[1],tC=ty[2],tw=tp>1?[""+(tl-1)/(tp-1),"(x2-x1) * width_ratio","x1*"+tg+" + float(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+tg],tE=tw[0],tR=tw[1],tI=tw[2];this.userCode="\n      const float height_ratio = float("+tx+");\n      const float width_ratio = float("+tE+");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= "+tu+") {\n          return;\n        }\n\n        float height_scale = "+tb+";\n        float width_scale = "+tR+";\n\n        float in_y = "+tC+";\n        if( in_y < 0.0 || in_y > "+tm+" ) {\n          setOutput(float("+to+"));\n          return;\n        }\n        float in_x = "+tI+";\n        if( in_x < 0.0 || in_x > "+tg+" ) {\n          setOutput(float("+to+"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if("+("bilinear"===tr?1:0)+" == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    "},ni=function(h,g,te){this.variableNames=["x"],this.outputShape=h;var tr=h.length,to=h[h.length-1];this.userCode="\n      int getIndex(int i) {\n        "+(te?"return "+to+" -i - 1;":"return i;")+"\n      }\n\n      void main() {\n        "+wa(tr)+" coords = getOutputCoords();\n        int end = "+ri(tr,"coords")+";\n        float val = 0.0;\n        for (int i = "+to+" - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx "+(te?"<":">")+" end) {\n            continue;\n          }\n          if (idx == end && "+g+") {\n            continue;\n          }\n          "+ri(tr,"coords")+" = idx;\n          val += getX("+function(h,g){if(1===h)return""+g;if(2===h)return g+".x, "+g+".y";if(3===h)return g+".x, "+g+".y, "+g+".z";if(4===h)return g+".x, "+g+".y, "+g+".z, "+g+".w";throw Error("Cumulative sum for rank "+h+" is not yet supported")}(tr,"coords")+");\n        }\n        setOutput(val);\n      }\n    "};function ri(h,g){if(1===h)return""+g;if(2===h)return g+".y";if(3===h)return g+".z";if(4===h)return g+".w";throw Error("Cumulative sum for rank "+h+" is not yet supported")}var oi=function(h){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=tP.DENSE;var g=Yt(h),te=ua();this.outputShape=h,this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        "+ca(["r","c","d"],h)+"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2("+g[0]+", "+g[1]+"));\n        int index = 4 * (resTexRC.x * "+g[1]+" + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        "+te.output+" = result;\n      }\n    "},ai=function(h){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=tP.DENSE;var g=Yt(h),te=ua();this.outputShape=h,this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        "+ca(["r","c","d"],h)+"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2("+g[0]+", "+g[1]+"));\n        int index = 4 * (resTexRC.x * "+g[1]+" + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        "+te.output+" = result;\n      }\n    "},nZ=function(){function t(h,g,te){this.variableNames=["x"],this.outputShape=[],this.outputShape=h,this.blockSize=g,this.dataFormat=te,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = "+this.getHeightCoordString()+";\n      int w = "+this.getWidthCoordString()+";\n      int d = "+this.getDepthCoordString()+";\n\n      int in_h = h / "+g+";\n      int offset_h = imod(h, "+g+");\n      int in_w = w / "+g+";\n      int offset_w = imod(w, "+g+");\n      int offset_d = (offset_h * "+g+" + offset_w) *\n        "+this.getOutputDepthSize()+";\n      int in_d = d + offset_d;\n\n      float result = "+this.getInputSamplingString()+";\n      setOutput(result);\n    }\n  "}return t.prototype.getHeightCoordString=function(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"},t.prototype.getWidthCoordString=function(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"},t.prototype.getDepthCoordString=function(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"},t.prototype.getOutputDepthSize=function(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]},t.prototype.getInputSamplingString=function(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"},t}(),si=function(h){this.variableNames=["X"],this.outputShape=[h,h],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "},ui=function(h){this.variableNames=["A"],this.outTexUsage=tL.DOWNLOAD;var g=ua();this.outputShape=h,this.userCode="\n      "+nq+"\n\n      void main() {\n        float x = getAAtOutCoords();\n        "+g.output+" = encode_float(x);\n      }\n    "},ci=function(h){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=tL.DOWNLOAD;var g=ua();this.outputShape=h,this.userCode="\n      "+nq+"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        "+g.output+" = encode_float(x);\n      }\n    "},li=function(h,g,te){void 0===te&&(te=!1),this.variableNames=["A"];var tr=ua(),to=g[0],tu=g[1];this.outputShape=h;var tc="result";te&&(tc="floor(result * 255. + 0.5)"),this.userCode="\n      "+la(h)+"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / "+tu+";\n        int c = imod(flatIndex, "+tu+");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2("+tu+".0, "+to+".0);\n        vec4 values = "+tr.texture2D+"(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        "+tr.output+" = vec4("+tc+", 0., 0., 0.);\n      }\n    "},hi=function(h,g,te){void 0===te&&(te=!1),this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;var tr=ua(),to=g[0],tu=g[1];this.outputShape=h;var tc="",tl="result";te&&(tl="floor(result * 255. + 0.5)");for(var th=0;th<=1;th++)for(var td=0;td<=1;td++){var tf=2*th+td;tc+="\n          localCoords = coords;\n          if(localCoords[2] + "+td+" < "+h[2]+") {\n            localCoords[2] += "+td+";\n            if(localCoords[1] + "+th+" < "+h[1]+") {\n              localCoords[1] += "+th+";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / "+tu+";\n              c = imod(flatIndex, "+tu+");\n              uv = (vec2(c, r) + halfCR) / vec2("+tu+".0, "+to+".0);\n              values = "+tr.texture2D+"(A, uv);\n\n              if(offset == 0) {\n                result["+tf+"] = values[0];\n              } else if(offset == 1) {\n                result["+tf+"] = values[1];\n              } else if(offset == 2) {\n                result["+tf+"] = values[2];\n              } else {\n                result["+tf+"] = values[3];\n              }\n            }\n          }\n        "}this.userCode="\n      "+la(h)+"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        "+tc+"\n\n        "+tr.output+" = "+tl+";\n      }\n    "},pi=function(h,g,te){this.variableNames=["real","imag"];var tr=g[1];this.outputShape=g;var to=te?"2.0 * "+Math.PI:"-2.0 * "+Math.PI;this.userCode="\n      const float exponentMultiplier = "+to+";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        "+h+"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float("+tr+");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < "+tr+"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / "+(te?tr+".0":"1.0")+";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    "},n0=function(){function t(h,g){this.outputShape=[],this.variableNames=["x"],this.outputShape=h,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}return t.prototype.getCustomSetupFunc=function(h){var g=this;return function(te,tr){null==g.valueLoc&&(g.valueLoc=te.getUniformLocationNoThrow(tr,"value")),te.gl.uniform1f(g.valueLoc,h)}},t}(),mi=function(h,g,te){this.variableNames=["A","indices"];var tr=h.slice();tr[te]=g,this.outputShape=tr,this.rank=tr.length;var to=wa(this.rank),tu=function(h,g){var te=h.length;if(te>4)throw Error("Gather for rank "+te+" is not yet supported");if(1===te)return"int(getIndices(resRC))";for(var tr=["resRC.x","resRC.y","resRC.z","resRC.w"],to=[],tu=0;tu<h.length;tu++)tu===g?to.push("int(getIndices("+tr[tu]+"))"):to.push(""+tr[tu]);return to.join()}(h,te);this.userCode="\n      void main() {\n        "+to+" resRC = getOutputCoords();\n        setOutput(getA("+tu+"));\n      }\n    "},gi=function(h,g,te){this.sliceDim=h,this.strides=g,this.variableNames=["x","indices"],this.outputShape=te;var tr=wa(g.length),to=wa(te.length),tu=this.sliceDim>1?"strides[j]":"strides";this.userCode="\n        "+tr+" strides = "+tr+"("+this.strides+");\n         void main() {\n          "+to+" coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < "+this.sliceDim+"; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * "+tu+";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      "};function yi(h,g){var te=ua();return oe(h,g,te.version+"\n    precision highp float;\n    "+te.attribute+" vec3 clipSpacePos;\n    "+te.attribute+" vec2 uv;\n    "+te.varyingVs+" vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }")}function xi(h,g){return fe(h,g,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function bi(h,g){return de(h,g,new Uint16Array([0,1,2,2,1,3]))}function wi(h,g,te,tr,to,tu,tc){ve(te,tr);var tl=pe(h,g),th=h.TEXTURE_2D;return Jt(h,g,function(){return h.bindTexture(th,tl)}),Jt(h,g,function(){return h.texParameteri(th,h.TEXTURE_WRAP_S,h.CLAMP_TO_EDGE)}),Jt(h,g,function(){return h.texParameteri(th,h.TEXTURE_WRAP_T,h.CLAMP_TO_EDGE)}),Jt(h,g,function(){return h.texParameteri(th,h.TEXTURE_MIN_FILTER,h.NEAREST)}),Jt(h,g,function(){return h.texParameteri(th,h.TEXTURE_MAG_FILTER,h.NEAREST)}),Jt(h,g,function(){return h.texImage2D(th,0,to,te,tr,0,tu,tc,null)}),Jt(h,g,function(){return h.bindTexture(h.TEXTURE_2D,null)}),tl}function Ci(h,g,te,tr,to){var tu=[tr,te];return wi(h,g,tu[0],tu[1],to.internalFormatFloat,to.textureFormatFloat,h.FLOAT)}function Ei(h,g,te,tr,to){var tu=[tr,te];return wi(h,g,tu[0],tu[1],to.internalFormatHalfFloat,to.textureFormatFloat,to.textureTypeHalfFloat)}function Ri(h,g,te,tr,to){var tu=[tr,te];return wi(h,g,tu[0],tu[1],h.RGBA,h.RGBA,h.UNSIGNED_BYTE)}function Ii(h,g,te,tr,to){var tu=$t(te,tr);return wi(h,g,tu[0],tu[1],to.internalFormatPackedFloat,h.RGBA,h.FLOAT)}function ki(h,g,te,tr,to){var tu=$t(te,tr);return wi(h,g,tu[0],tu[1],to.internalFormatPackedHalfFloat,h.RGBA,to.textureTypeHalfFloat)}function Si(h,g,te,tr){return Jt(h,g,function(){return h.bindBuffer(h.ARRAY_BUFFER,tr)}),ge(h,g,te,"clipSpacePos",tr,3,20,0)&&ge(h,g,te,"uv",tr,2,20,12)}function Ai(h,g,te,tr,to,tu,tc){var tl,th,td;Jt(h,g,function(){return h.bindTexture(h.TEXTURE_2D,te)}),tu instanceof Uint8Array?(tl=new Uint8Array(tr*to*4),th=h.UNSIGNED_BYTE,td=h.RGBA):(tl=new Float32Array(tr*to*4),th=h.FLOAT,td=tc.internalFormatPackedFloat),tl.set(tu),Jt(h,g,function(){return h.texImage2D(h.TEXTURE_2D,0,td,tr,to,0,h.RGBA,th,tl)}),Jt(h,g,function(){return h.bindTexture(h.TEXTURE_2D,null)})}function Di(h,g,te,tr){Jt(h,g,function(){return h.bindTexture(h.TEXTURE_2D,te)}),tr.data instanceof Uint8Array?Jt(h,g,function(){return h.texImage2D(h.TEXTURE_2D,0,h.RGBA,tr.width,tr.height,0,h.RGBA,h.UNSIGNED_BYTE,tr.data)}):Jt(h,g,function(){return h.texImage2D(h.TEXTURE_2D,0,h.RGBA,h.RGBA,h.UNSIGNED_BYTE,tr)}),Jt(h,g,function(){return h.bindTexture(h.TEXTURE_2D,null)})}function Ti(h,g,te,tr,to){var tu=h.createBuffer();Jt(h,g,function(){return h.bindBuffer(h.PIXEL_PACK_BUFFER,tu)});var tc=16*te*tr;return Jt(h,g,function(){return h.bufferData(h.PIXEL_PACK_BUFFER,tc,h.STREAM_READ)}),Jt(h,g,function(){return h.readPixels(0,0,tr,te,h.RGBA,h.FLOAT,0)}),Jt(h,g,function(){return h.bindBuffer(h.PIXEL_PACK_BUFFER,null)}),tu}function Ni(h,g,te){var tr=new Float32Array(te);return h.bindBuffer(h.PIXEL_PACK_BUFFER,g),h.getBufferSubData(h.PIXEL_PACK_BUFFER,0,tr),h.bindBuffer(h.PIXEL_PACK_BUFFER,null),tr}function Fi(h,g,te,tr,to){var tu=[tr,te],tc=tu[0],tl=tu[1],th=new Uint8Array(te*tr*4);return Jt(h,g,function(){return h.readPixels(0,0,tc,tl,to.downloadTextureFormat,h.UNSIGNED_BYTE,th)}),new Float32Array(th.buffer)}function _i(h,g,te,tr,to,tu,tc,tl){var th,td=new Float32Array((th=$t(tu,tc))[0]*th[1]*4);return h.bindBuffer(h.PIXEL_PACK_BUFFER,g),h.getBufferSubData(h.PIXEL_PACK_BUFFER,0,td),h.bindBuffer(h.PIXEL_PACK_BUFFER,null),td}function Oi(h,g,te,tr){var to=new Float32Array(te*tr*4);return Jt(h,g,function(){return h.readPixels(0,0,tr,te,h.RGBA,h.FLOAT,to)}),to}var n1=Object.freeze({createVertexShader:yi,createVertexBuffer:xi,createIndexBuffer:bi,createFloat32MatrixTexture:Ci,createFloat16MatrixTexture:Ei,createUnsignedBytesMatrixTexture:Ri,createPackedMatrixTexture:Ii,createFloat16PackedMatrixTexture:ki,bindVertexProgramAttributeStreams:Si,uploadDenseMatrixToTexture:Ai,uploadPixelDataToTexture:Di,createBufferFromOutputTexture:Ti,downloadFloat32MatrixFromBuffer:Ni,downloadByteEncodedFloatMatrixFromOutputTexture:Fi,downloadPackedMatrixFromBuffer:_i,downloadMatrixFromPackedOutputTexture:Oi}),n2=function(){function t(h){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];var g=tl.getNumber("WEBGL_VERSION");null!=h?(this.gl=h,Kt(g,h)):this.gl=jt(g);var te="WEBGL_color_buffer_float";if(1===tl.getNumber("WEBGL_VERSION")){if(this.textureFloatExtension=re(this.gl,this.debug,"OES_texture_float"),Pe(this.gl,"OES_texture_half_float"))this.textureHalfFloatExtension=re(this.gl,this.debug,"OES_texture_half_float");else if(tl.get("WEBGL_FORCE_F16_TEXTURES"))throw Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(te),Pe(this.gl,"EXT_color_buffer_half_float"))this.colorBufferHalfFloatExtension=re(this.gl,this.debug,"EXT_color_buffer_half_float");else if(tl.get("WEBGL_FORCE_F16_TEXTURES"))throw Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(te="EXT_color_buffer_float",Pe(this.gl,te))this.colorBufferFloatExtension=this.gl.getExtension(te);else{if(!Pe(this.gl,"EXT_color_buffer_half_float"))throw Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float")}this.vertexBuffer=xi(this.gl,this.debug),this.indexBuffer=bi(this.gl,this.debug),this.framebuffer=me(this.gl,this.debug),this.textureConfig=Qt(this.gl,this.textureHalfFloatExtension)}return Object.defineProperty(t.prototype,"debug",{get:function(){return tl.getBool("DEBUG")},enumerable:!0,configurable:!0}),t.prototype.dispose=function(){var h=this;if(!this.disposed){null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");var g=this.gl;Jt(g,this.debug,function(){return g.finish()}),Jt(g,this.debug,function(){return g.bindFramebuffer(g.FRAMEBUFFER,null)}),Jt(g,this.debug,function(){return g.deleteFramebuffer(h.framebuffer)}),Jt(g,this.debug,function(){return g.bindBuffer(g.ARRAY_BUFFER,null)}),Jt(g,this.debug,function(){return g.bindBuffer(g.ELEMENT_ARRAY_BUFFER,null)}),Jt(g,this.debug,function(){return g.deleteBuffer(h.indexBuffer)}),this.disposed=!0}},t.prototype.createFloat32MatrixTexture=function(h,g){return this.throwIfDisposed(),Ci(this.gl,this.debug,h,g,this.textureConfig)},t.prototype.createFloat16MatrixTexture=function(h,g){return this.throwIfDisposed(),Ei(this.gl,this.debug,h,g,this.textureConfig)},t.prototype.createUnsignedBytesMatrixTexture=function(h,g){return this.throwIfDisposed(),Ri(this.gl,this.debug,h,g,this.textureConfig)},t.prototype.uploadPixelDataToTexture=function(h,g){this.throwIfDisposed(),Di(this.gl,this.debug,h,g)},t.prototype.uploadDenseMatrixToTexture=function(h,g,te,tr){this.throwIfDisposed(),Ai(this.gl,this.debug,h,g,te,tr,this.textureConfig)},t.prototype.createFloat16PackedMatrixTexture=function(h,g){return this.throwIfDisposed(),ki(this.gl,this.debug,h,g,this.textureConfig)},t.prototype.createPackedMatrixTexture=function(h,g){return this.throwIfDisposed(),Ii(this.gl,this.debug,h,g,this.textureConfig)},t.prototype.deleteMatrixTexture=function(h){var g=this;this.throwIfDisposed(),this.outputTexture===h&&(Ee(this.gl,this.debug,this.framebuffer),this.outputTexture=null),Jt(this.gl,this.debug,function(){return g.gl.deleteTexture(h)})},t.prototype.downloadByteEncodedFloatMatrixFromOutputTexture=function(h,g,te){var tr=this;return this.downloadMatrixDriver(h,function(){return Fi(tr.gl,tr.debug,g,te,tr.textureConfig)})},t.prototype.downloadPackedMatrixFromBuffer=function(h,g,te,tr,to,tu){return _i(this.gl,h,0,0,0,to,tu,this.textureConfig)},t.prototype.downloadFloat32MatrixFromBuffer=function(h,g){return Ni(this.gl,h,g)},t.prototype.createBufferFromTexture=function(h,g,te){this.bindTextureToFrameBuffer(h);var tr=Ti(this.gl,this.debug,g,te,this.textureConfig);return this.unbindTextureToFrameBuffer(),tr},t.prototype.createAndWaitForFence=function(){var h=this.createFence(this.gl);return this.pollFence(h)},t.prototype.createFence=function(h){var g,te,tr=this;if(tl.getBool("WEBGL_FENCE_API_ENABLED")){var to=h.fenceSync(h.SYNC_GPU_COMMANDS_COMPLETE,0);h.flush(),te=function(){var g=h.clientWaitSync(to,0,0);return g===h.ALREADY_SIGNALED||g===h.CONDITION_SATISFIED},g=to}else tl.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(g=this.beginQuery(),this.endQuery(),te=function(){return tr.isQueryAvailable(g,tl.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}):te=function(){return!0};return{query:g,isFencePassed:te}},t.prototype.downloadMatrixFromPackedTexture=function(h,g,te){var tr=this;return this.downloadMatrixDriver(h,function(){return Oi(tr.gl,tr.debug,g,te)})},t.prototype.createProgram=function(h){this.throwIfDisposed();var g=this.gl,te=ae(g,this.debug,h),tr=yi(g,this.debug),to=ce(g,this.debug);return Jt(g,this.debug,function(){return g.attachShader(to,tr)}),Jt(g,this.debug,function(){return g.attachShader(to,te)}),le(g,this.debug,to),this.debug&&he(g,this.debug,to),this.vertexAttrsAreBound||(this.setProgram(to),this.vertexAttrsAreBound=Si(g,this.debug,this.program,this.vertexBuffer)),to},t.prototype.deleteProgram=function(h){var g=this;this.throwIfDisposed(),h===this.program&&(this.program=null),null!=h&&Jt(this.gl,this.debug,function(){return g.gl.deleteProgram(h)})},t.prototype.setProgram=function(h){var g=this;this.throwIfDisposed(),this.program=h,null!=this.program&&this.debug&&he(this.gl,this.debug,this.program),Jt(this.gl,this.debug,function(){return g.gl.useProgram(h)})},t.prototype.getUniformLocation=function(h,g,te){return void 0===te&&(te=!0),this.throwIfDisposed(),te?xe(this.gl,this.debug,h,g):be(this.gl,h,g)},t.prototype.getAttributeLocation=function(h,g){var te=this;return this.throwIfDisposed(),Jt(this.gl,this.debug,function(){return te.gl.getAttribLocation(h,g)})},t.prototype.getUniformLocationNoThrow=function(h,g){return this.throwIfDisposed(),this.gl.getUniformLocation(h,g)},t.prototype.setInputMatrixTexture=function(h,g,te){this.throwIfDisposed(),this.throwIfNoProgram(),we(this.gl,this.debug,this.program,h,g,te)},t.prototype.setOutputMatrixTexture=function(h,g,te){this.setOutputMatrixTextureDriver(h,te,g)},t.prototype.setOutputPackedMatrixTexture=function(h,g,te){this.throwIfDisposed();var tr=$t(g,te),to=tr[0],tu=tr[1];this.setOutputMatrixTextureDriver(h,to,tu)},t.prototype.setOutputMatrixWriteRegion=function(h,g,te,tr){this.setOutputMatrixWriteRegionDriver(te,h,tr,g)},t.prototype.setOutputPackedMatrixWriteRegion=function(h,g,te,tr){throw Error("setOutputPackedMatrixWriteRegion not implemented.")},t.prototype.debugValidate=function(){null!=this.program&&he(this.gl,this.debug,this.program),Re(this.gl)},t.prototype.executeProgram=function(){this.throwIfDisposed(),this.throwIfNoProgram();var h=this.gl;this.debug&&this.debugValidate(),Jt(h,this.debug,function(){return h.drawElements(h.TRIANGLES,6,h.UNSIGNED_SHORT,0)})},t.prototype.blockUntilAllProgramsCompleted=function(){var h=this;this.throwIfDisposed(),Jt(this.gl,this.debug,function(){return h.gl.finish()})},t.prototype.getQueryTimerExtension=function(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=re(this.gl,this.debug,2===tl.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension},t.prototype.getQueryTimerExtensionWebGL2=function(){return this.getQueryTimerExtension()},t.prototype.getQueryTimerExtensionWebGL1=function(){return this.getQueryTimerExtension()},t.prototype.beginQuery=function(){if(2===tl.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var h=this.gl,g=this.getQueryTimerExtensionWebGL2(),te=h.createQuery();return h.beginQuery(g.TIME_ELAPSED_EXT,te),te}var tr=this.getQueryTimerExtensionWebGL1(),to=tr.createQueryEXT();return tr.beginQueryEXT(tr.TIME_ELAPSED_EXT,to),to},t.prototype.endQuery=function(){if(2!==tl.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var h=this.getQueryTimerExtensionWebGL1();h.endQueryEXT(h.TIME_ELAPSED_EXT)}else{var g=this.gl,te=this.getQueryTimerExtensionWebGL2();g.endQuery(te.TIME_ELAPSED_EXT)}},t.prototype.waitForQueryAndGetTime=function(h){return n(this,void 0,void 0,function(){var g=this;return r(this,function(te){switch(te.label){case 0:return[4,F(function(){return g.disposed||g.isQueryAvailable(h,tl.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})];case 1:return te.sent(),[2,this.getQueryTime(h,tl.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))]}})})},t.prototype.getQueryTime=function(h,g){if(0===g)return null;if(2===g){var te=this.gl;return te.getQueryParameter(h,te.QUERY_RESULT)/1e6}var tr=this.getQueryTimerExtensionWebGL1();return tr.getQueryObjectEXT(h,tr.QUERY_RESULT_EXT)/1e6},t.prototype.isQueryAvailable=function(h,g){if(0===g)return!0;if(2===g){var te=this.gl,tr=this.getQueryTimerExtensionWebGL2(),to=te.getQueryParameter(h,te.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(tr.GPU_DISJOINT_EXT)),to&&!this.disjoint}return to=(tr=this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(h,tr.QUERY_RESULT_AVAILABLE_EXT),null==this.disjoint&&(this.disjoint=this.gl.getParameter(tr.GPU_DISJOINT_EXT)),to&&!this.disjoint},t.prototype.pollFence=function(h){var g=this;return new Promise(function(te){g.addItemToPoll(function(){return h.isFencePassed()},function(){return te()})})},t.prototype.pollItems=function(){for(var h=function(h){for(var g=0;g<h.length&&h[g]();++g);return g-1}(this.itemsToPoll.map(function(h){return h.isDoneFn})),g=0;g<=h;++g)(0,this.itemsToPoll[g].resolveFn)();this.itemsToPoll=this.itemsToPoll.slice(h+1)},t.prototype.addItemToPoll=function(h,g){var te=this;this.itemsToPoll.push({isDoneFn:h,resolveFn:g}),this.itemsToPoll.length>1||F(function(){return te.pollItems(),0===te.itemsToPoll.length})},t.prototype.bindTextureToFrameBuffer=function(h){this.throwIfDisposed(),Ce(this.gl,this.debug,h,this.framebuffer),this.debug&&Re(this.gl)},t.prototype.unbindTextureToFrameBuffer=function(){null!=this.outputTexture?(Ce(this.gl,this.debug,this.outputTexture,this.framebuffer),this.debug&&Re(this.gl)):Ee(this.gl,this.debug,this.framebuffer)},t.prototype.downloadMatrixDriver=function(h,g){this.bindTextureToFrameBuffer(h);var te=g();return this.unbindTextureToFrameBuffer(),te},t.prototype.setOutputMatrixTextureDriver=function(h,g,te){this.throwIfDisposed();var tr=this.gl;Ce(tr,this.debug,h,this.framebuffer),this.debug&&Re(tr),this.outputTexture=h,Jt(tr,this.debug,function(){return tr.viewport(0,0,g,te)}),Jt(tr,this.debug,function(){return tr.scissor(0,0,g,te)})},t.prototype.setOutputMatrixWriteRegionDriver=function(h,g,te,tr){var to=this;this.throwIfDisposed(),Jt(this.gl,this.debug,function(){return to.gl.scissor(h,g,te,tr)})},t.prototype.throwIfDisposed=function(){if(this.disposed)throw Error("Attempted to use disposed GPGPUContext.")},t.prototype.throwIfNoProgram=function(){if(null==this.program)throw Error("No GPU program is currently set.")},t}();function Pi(h,g){if(h.length!==g.length)throw Error("Binary was compiled with "+h.length+" inputs, but was executed with "+g.length+" inputs");h.forEach(function(h,te){var tr=h.logicalShape,to=g[te],tu=to.shape;if(!S(tr,tu))throw Error("Binary was compiled with different shapes than the current args. Shapes "+tr+" and "+tu+" must match");if(!h.isUniform||!to.isUniform){var tc=h.texShape,tl=to.isUniform?null:to.texData.texShape;if(!S(tc,tl))throw Error("Binary was compiled with different texture shapes than the current args. Shape "+tc+" and "+tl+" must match")}})}var Li=function(h,g,te){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=h;for(var tr=te.filterWidth,to=te.inChannels,tu=te.strideWidth,tc=te.strideHeight,tl=te.padInfo,th=te.outWidth,td=te.dilationWidth,tf=te.dilationHeight,tp=te.dataFormat,tv=tl.left,tm=tl.top,tg=to*tr,ty=ua(),tx="channelsLast"===tp,tb=tx?0:1,tC=tx?1:2,tw="",tE=0;tE<=1;tE++)for(var tR=0;tR<=1;tR++)tw+="\n          blockIndex = rc.y + "+tR+";\n          pos = rc.x + "+tE+";\n\n          if(blockIndex < "+h[1]+" && pos < "+h[0]+") {\n            offsetY = int(blockIndex / ("+th+")) * "+tc+" - "+tm+";\n            d0 = offsetY + "+tf+" * (pos / "+tg+");\n\n            if(d0 < "+g[tb]+" && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), "+th+".) * "+tu+". - "+tv+".);\n              d1 = offsetX + "+td+" * (int(mod(float(pos), "+tg+".) / "+to+".));\n\n              if(d1 < "+g[tC]+" && d1 >= 0) {\n\n                ch = int(mod(float(pos), "+to+".));\n\n                if ("+tx+") {\n                  innerDims = vec2(d1, ch);\n                  result["+(2*tE+tR)+"] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result["+(2*tE+tR)+"] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";this.userCode="\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        "+tw+"\n\n        "+ty.output+" = result;\n      }\n    "},Wi=function(h,g,te,tr,to){this.variableNames=["x"],this.outputShape=[];var tu=h[3]-1;this.outputShape=h;var tc="float("+te+") + float("+tr+") * sum";this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -"+g+"; j <= "+g+"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  "+tu+") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * "+(.5===to?"inversesqrt("+tc+")":1===to?"1.0/("+tc+")":"exp(log("+tc+") * float(-"+to+"));")+";\n        setOutput(val);\n      }\n    "},Ui=function(h,g,te,tr,to){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=h,this.depth=h[3],this.depthRadius=g,this.bias=te,this.alpha=tr,this.beta=to,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < "+this.depth+"; ++d) {\n          int depthBegin = int(max(0.0, float(d - "+g+")));\n          int depthEnd = int(min(float("+this.depth+"),\n              float(d + "+g+" + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = "+this.depth+";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float("+tr+") * norm + float("+te+");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float("+tr+")\n                * float("+to+")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * "+to+");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    "},Vi=function(h,g,te,tr,to){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;var tu=h[3]-1;this.outputShape=h;var tc="float("+te+") + float("+tr+") * sum";this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < "+this.outputShape[3]+";\n        bool hasNextRow = c < "+this.outputShape[2]+";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - "+g+";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - "+g+"; j <= "+g+"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2("+tu+"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * "+(.5===to?"inversesqrt("+tc+")":1===to?"1.0/("+tc+")":"exp(log("+tc+") * float(-"+to+"));")+";\n        setOutput(result);\n      }\n    "},zi=function(h){this.variableNames=["dy","maxPos"],this.outputShape=h.inShape;var g=h.strideHeight,te=h.strideWidth,tr=h.dilationHeight,to=h.effectiveFilterHeight,tu=h.effectiveFilterWidth,tc=to-1-h.padInfo.top,tl=tu-1-h.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2("+tc+", "+tl+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+to+";\n          wR += "+tr+") {\n          float dyR = float(dyRCorner + wR) / "+g+".0;\n\n          if (dyR < 0.0 || dyR >= "+h.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+tu+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+te+".0;\n\n            if (dyC < 0.0 || dyC >= "+h.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = "+(to*tu-1)+" - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * "+tu+" + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Gi=function(h){this.variableNames=["dy","maxPos"],this.outputShape=h.inShape;var g=h.strideDepth,te=h.strideHeight,tr=h.strideWidth,to=h.dilationDepth,tu=h.dilationHeight,tc=h.dilationWidth,tl=h.effectiveFilterDepth,th=h.effectiveFilterHeight,td=h.effectiveFilterWidth,tf=tl-1-h.padInfo.front,tp=th-1-h.padInfo.top,tv=td-1-h.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3("+tf+", "+tp+", "+tv+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < "+tl+";\n           wD += "+to+") {\n          float dyD = float(dyDCorner + wD) / "+g+".0;\n\n          if (dyD < 0.0 || dyD >= "+h.outDepth+".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < "+th+";\n              wR += "+tu+") {\n            float dyR = float(dyRCorner + wR) / "+te+".0;\n\n            if (dyR < 0.0 || dyR >= "+h.outHeight+".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < "+td+";\n                wC += "+tc+") {\n              float dyC = float(dyCCorner + wC) / "+tr+".0;\n\n              if (dyC < 0.0 || dyC >= "+h.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = "+(tl*th*td-1)+" -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * "+th+" * "+td+" +\n                  wR * "+td+" + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Hi=function(h,g,te,tr,to,tu,tc){void 0===te&&(te=!1),void 0===tr&&(tr=!1),void 0===to&&(to=!1),void 0===tu&&(tu=null),void 0===tc&&(tc=!1),this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=g;var tl=Math.ceil((te?h[1]:h[2])/2),th=te?"i * 2, rc.y":"rc.y, i * 2",td=tr?"rc.z, i * 2":"i * 2, rc.z",tf=te?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],tp=tr?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],tv="",tm="";tu&&(tv=tc?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          "+tu+"\n        }":"vec4 activation(vec4 x) {\n          "+tu+"\n        }",tm="result = activation(result);");var tg=to?"result += getBiasAtOutCoords();":"";to&&this.variableNames.push("bias"),tc&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+tv+"\n\n      const float sharedDimension = "+tl+".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < "+tl+"; i++) {\n          vec4 a = getMatrixA(rc.x, "+th+");\n          vec4 b = getMatrixB(rc.x, "+td+");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += ("+tf[0]+" * "+tp[0]+");\n          result += ("+tf[1]+" * "+tp[1]+");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        "+tg+"\n\n        "+tm+"\n\n        setOutput(result);\n      }\n    "},n3=function(){function t(h,g,te){this.variableNames=["probs"],this.outputShape=[h,te],this.userCode="\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < "+(g-1)+"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float("+(g-1)+"));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(h){var g=this;return function(te,tr){null==g.seedLoc&&(g.seedLoc=te.getUniformLocation(tr,"seed")),te.gl.uniform1f(g.seedLoc,h)}},t}(),Ki=function(h,g,te,tr){this.variableNames=["indices"],this.outputShape=[h,g],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float("+tr+"), float("+te+"),\n                      float(index == coords.y)));\n      }\n    "},ji=function(h){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=h;var g=h.length;if(0===g)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{var te,tr,to=sa("rc",g),tu=wa(g),tc=function(h,g,te){if(1===h)return"rc > "+g[0];for(var tr="",to=h-2;to<h;to++)tr+=te[to]+" >= "+g[to],to<h-1&&(tr+="||");return tr}(g,h,to),tl=function(h,g,te,tr){if(1===h)return"";var to=tr.slice(-2);return"\n    int r = "+to[0]+";\n    int c = "+to[1]+";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= "+g+";\n    bool rEdge = rp1 >= "+te+";\n  "}(g,h[h.length-1],h[h.length-2],to),th=(tr=function(h,g){for(var te=[],tr=0;tr<=1;tr++)for(var to=0;to<=1;to++){for(var tu=(0===tr?"r":"rp1")+", "+(0===to?"c":"cp1"),tc=2;tc<h;tc++)tu=g[g.length-1-tc]+","+tu;te.push(tu)}return te}(te=h.length,to),1===te?"getA(rc),\n            rc + 1 >= "+h[0]+" ? 0. : getA(rc + 1),\n            0, 0":"getA("+tr[0]+"),\n          cEdge ? 0. : getA("+tr[1]+"),\n          rEdge ? 0. : getA("+tr[2]+"),\n          rEdge || cEdge ? 0. : getA("+tr[3]+")");this.userCode="\n        void main() {\n          "+tu+" rc = getOutputCoords();\n\n          if("+tc+") {\n            setOutput(vec4(0));\n          } else {\n            "+tl+"\n\n            setOutput(vec4("+th+"));\n          }\n        }\n      "}},Xi=function(h,g,te){this.variableNames=["x"],this.outputShape=g.map(function(g,te){return g[0]+h[te]+g[1]});var tr=h.length,to=wa(tr),tu=g.map(function(h){return h[0]}).join(","),tc=g.map(function(g,te){return g[0]+h[te]}).join(","),tl=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,tr);this.userCode=1!==tr?"\n      "+to+" start = "+to+"("+tu+");\n      "+to+" end = "+to+"("+tc+");\n\n      void main() {\n        "+to+" outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float("+te+"));\n        } else {\n          "+to+" coords = outC - start;\n          setOutput(getX("+tl+"));\n        }\n      }\n    ":"\n        int start = "+tu+";\n        int end = "+tc+";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float("+te+"));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      "},Yi=function(h,g,te){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=g.map(function(g,te){return g[0]+h[te]+g[1]});for(var tr=h.length,to=wa(tr),tu=g.map(function(h){return h[0]}).join(","),tc=g.map(function(g,te){return g[0]+h[te]}).join(","),tl=sa("rc",tr),th=sa("source",tr),td=tl[tr-1]+" < "+this.outputShape[tr-1],tf=1===tr?"source":"vec2("+th.slice(-2).join()+")",tp=[to+" rc = outputLoc;",tl[tr-1]+" += 1;\n       if("+td+") {\n      ",1===tr?"":"}\n       rc = outputLoc;\n       "+tl[tr-2]+" += 1;\n       if("+tl[tr-2]+" < "+this.outputShape[tr-2]+") {",1===tr?"":"  "+tl[tr-1]+" += 1;\n         if("+td+") {"],tv=1===tr?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",tm="",tg=0,ty=1===tr?2:4;tg<ty;tg++)tm+="\n        "+tp[tg]+"\n        if ("+tv+") {\n          result["+tg+"] = float("+te+");\n        } else {\n          "+to+" source = rc - start;\n          result["+tg+"] = getChannel(getX("+th.join()+"), "+tf+");\n        }\n      ";tm+=1===tr?"} ":"}}",this.userCode="\n      const "+to+" start = "+to+"("+tu+");\n      const "+to+" end = "+to+"("+tc+");\n\n      void main() {\n        "+to+" outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        "+tm+"\n        setOutput(result);\n      }\n    "},$i=function(h,g,te){if(this.variableNames=["x"],"avg"===g&&te)throw Error("Cannot compute positions for average pool.");var tr=h.filterWidth,to=h.strideHeight,tu=h.strideWidth,tc=h.dilationHeight,tl=h.dilationWidth,th=h.effectiveFilterHeight,td=h.effectiveFilterWidth,tf=h.padInfo.top,tp=h.padInfo.left;this.outputShape=h.outShape;var tv="avg"===g,tm="0.0";if(tv||(tm="-1.0 / 1e-20"),te)this.userCode="\n        const ivec2 strides = ivec2("+to+", "+tu+");\n        const ivec2 pads = ivec2("+tf+", "+tp+");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < "+th+";\n              wR += "+tc+") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+h.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+td+";\n                wC += "+tl+") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= "+h.inWidth+") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * "+td+" + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";else{var tg=g+"("+g+"("+g+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===g&&(tg="avgValue / count");var ty=4*Math.floor(tr/4),tx=tr%4,tb="\n      if ("+tv+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";this.userCode="\n      const ivec2 strides = ivec2("+to+", "+tu+");\n      const ivec2 pads = ivec2("+tf+", "+tp+");\n      const float initializationValue = "+tm+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= "+h.inWidth+") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+tm+");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < "+th+";\n            wR += "+tc+") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= "+h.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+ty+"; wC += 4) {\n            int xC = xCCorner + wC * "+tl+";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+tl+", d),\n              getValue(batch, xR, xC + 2 * "+tl+", d),\n              getValue(batch, xR, xC + 3 * "+tl+", d)\n            );\n\n            "+tb+"\n          }\n\n          int xC = xCCorner + "+ty+";\n          if ("+(1===tx)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            "+tb+"\n          } else if ("+(2===tx)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+tl+", d),\n              initializationValue,\n              initializationValue\n            );\n\n            "+tb+"\n          } else if ("+(3===tx)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+tl+", d),\n              getValue(batch, xR, xC + 2 * "+tl+", d),\n              initializationValue\n            );\n\n            "+tb+"\n          }\n        }\n        setOutput("+tg+");\n      }\n    "}},Qi=function(h,g,te){if(this.variableNames=["x"],"avg"===g&&te)throw Error("Cannot compute positions for average pool.");var tr=h.filterWidth,to=h.strideDepth,tu=h.strideHeight,tc=h.strideWidth,tl=h.dilationDepth,th=h.dilationHeight,td=h.dilationWidth,tf=h.effectiveFilterDepth,tp=h.effectiveFilterHeight,tv=h.effectiveFilterWidth,tm=h.padInfo.front,tg=h.padInfo.top,ty=h.padInfo.left;this.outputShape=h.outShape;var tx="avg"===g,tb="0.0";if(tx||(tb="-1.0 / 1e-20"),te)this.userCode="\n        const ivec3 strides =\n            ivec3("+to+", "+tu+", "+tc+");\n        const ivec3 pads = ivec3("+tm+", "+tg+", "+ty+");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < "+tf+";\n              wD += "+tl+") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= "+h.inDepth+") {\n              continue;\n            }\n\n            for (int wR = 0; wR < "+tp+";\n                wR += "+th+") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= "+h.inHeight+") {\n                continue;\n              }\n\n              for (int wC = 0; wC < "+tv+";\n                  wC += "+td+") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= "+h.inWidth+") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition =\n                      wD * "+tp+" * "+tv+" +\n                      wR * "+tv+" + wC;;\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";else{var tC=g+"("+g+"("+g+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===g&&(tC="avgValue / count");var tw=4*Math.floor(tr/4),tE=tr%4,tR="\n      if ("+tx+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";this.userCode="\n      const ivec3 strides =\n        ivec3("+to+", "+tu+", "+tc+");\n      const ivec3 pads = ivec3("+tm+", "+tg+", "+ty+");\n      const float initializationValue = "+tb+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= "+h.inWidth+") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+tb+");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < "+tf+";\n            wD += "+tl+") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= "+h.inDepth+") {\n            continue;\n          }\n\n          for (int wR = 0; wR < "+tp+";\n            wR += "+th+") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+h.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+tw+"; wC += 4) {\n              int xC = xCCorner + wC * "+td+";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+td+", ch),\n                getValue(batch, xD, xR, xC + 2 * "+td+", ch),\n                getValue(batch, xD, xR, xC + 3 * "+td+", ch)\n              );\n\n              "+tR+"\n            }\n\n            int xC = xCCorner + "+tw+";\n            if ("+(1===tE)+") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              "+tR+"\n            } else if ("+(2===tE)+") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+td+", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              "+tR+"\n            } else if ("+(3===tE)+") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+td+", ch),\n                getValue(batch, xD, xR, xC + 2 * "+td+", ch),\n                initializationValue\n              );\n\n              "+tR+"\n            }\n          }\n          setOutput("+tC+");\n        }\n      }\n    "}},Ji=function(h,g){this.variableNames=["x"];var te=h.windowSize,tr=h.batchSize,to=h.inSize,tu=Math.ceil(to/te);this.outputShape=[tr,tu];var tc="0.0",tl="";"prod"===g?tc="1.0":"min"===g?(tc="1.0 / 1e-20",tl="min"):"max"===g&&(tc="-1.0 / 1e-20",tl="max");var th=g+"("+g+"("+g+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===g?th="sumValue":"prod"===g?th="prodValue":"all"===g?th="allValue":"any"===g&&(th="anyValue");var td=4*Math.floor(te/4),tf=te%4,tp="\n      if ("+("sum"===g)+") {\n        sumValue += dot(values, ones);\n      } else if ("+("prod"===g)+") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = "+tl+"(values, minMaxValue);\n      }\n    ",tv="vec4";"all"===g?(tc="1.0",tp="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",tv="bvec4"):"any"===g&&(tc="0.0",tp="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",tv="bvec4");var tm="";to%te>0&&(tm="\n        if (inIdx < 0 || inIdx >= "+to+") {\n          return initializationValue;\n        }\n      "),this.userCode="\n      const float initializationValue = "+tc+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        "+tm+"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+te+";\n\n        vec4 minMaxValue = vec4("+tc+");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < "+td+"; i += 4) {\n          int inIdx = inOffset + i;\n          "+tv+" values = "+tv+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          "+tp+"\n        }\n\n        int inIdx = inOffset + "+td+";\n        if ("+(1===tf)+") {\n          "+tv+" values = "+tv+"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          "+tp+"\n        } else if ("+(2===tf)+") {\n          "+tv+" values = "+tv+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          "+tp+"\n        } else if ("+(3===tf)+") {\n          "+tv+" values = "+tv+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          "+tp+"\n        }\n        setOutput("+th+");\n      }\n    "},Zi=function(h,g){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=h;for(var te="",tr=0;tr<4;tr++){var to="thisRC = rc;";tr%2==1&&(to+="thisRC.z += 1;"),tr>1&&(to+="thisRC.y += 1;"),te+="\n        "+to+"\n        "+(tr>0?"if(thisRC.y < rows && thisRC.z < cols){":"")+"\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result["+tr+"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        "+(tr>0?"}":"")+"\n      "}this.userCode="\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      "+ca(["r","c","d"],g)+"\n      return ivec3(r, c, d);\n    }\n  \n      "+la(h)+"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = "+h[1]+";\n        int cols = "+h[2]+";\n\n        "+te+"\n\n        setOutput(result);\n      }\n    "},ts=function(h,g,te){this.variableNames=["dy"],this.outputShape=[],this.outputShape=g.shape;var tr=g.shape,to=tr[1],tu=tr[2],tc=h.shape,tl=tc[1],th=tc[2],td=[te&&tl>1?to-1:to,te&&th>1?tu-1:tu],tf=[te&&tl>1?tl-1:tl,te&&th>1?th-1:th],tp=td[0]/tf[0],tv=td[1]/tf[1],tm=1/tp,tg=1/tv,ty=2*Math.ceil(tm)+2,tx=2*Math.ceil(tg)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+tp+");\n        const float widthScale = float("+tv+");\n\n        const float invHeightScale = float("+tm+");\n        const float invWidthScale = float("+tg+");\n\n        const int winHeight = int("+ty+");\n        const int winWidth = int("+tx+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+tl+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+th+") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), "+(to-1)+".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), "+(tu-1)+".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "},es=function(h,g,te,tr){this.variableNames=["A"],this.outputShape=[];var to=h[0],tu=h[1],tc=h[2],tl=h[3];this.outputShape=[to,g,te,tl];var th=[tr&&g>1?tu-1:tu,tr&&te>1?tc-1:tc],td=[tr&&g>1?g-1:g,tr&&te>1?te-1:te];this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+th[0]/td[0]+",\n          "+th[1]/td[1]+");\n      const vec2 inputShapeRC = vec2("+tu+".0, "+tc+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    "},ns=function(h,g,te,tr){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];var to=h[0],tu=h[1],tc=h[2],tl=h[3];this.outputShape=[to,g,te,tl];var th=[tr&&g>1?tu-1:tu,tr&&te>1?tc-1:tc],td=[tr&&g>1?g-1:g,tr&&te>1?te-1:te];this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          "+th[0]/td[0]+",\n          "+th[1]/td[1]+",\n          "+th[1]/td[1]+");\n      const vec3 inputShapeRC = vec3("+tu+".0, "+tc+".0,\n                                     "+tc+".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < "+(tl-1)+";\n        bool hasNextRow = coords.z < "+(te-1)+";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    "},rs=function(h,g,te){this.variableNames=["dy"],this.outputShape=[],this.outputShape=g.shape;var tr=g.shape,to=tr[1],tu=tr[2],tc=h.shape,tl=tc[1],th=tc[2],td=[te&&tl>1?to-1:to,te&&th>1?tu-1:tu],tf=[te&&tl>1?tl-1:tl,te&&th>1?th-1:th],tp=td[0]/tf[0],tv=td[1]/tf[1],tm=1/tp,tg=1/tv,ty=2*Math.ceil(tm)+2,tx=2*Math.ceil(tg)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+tp+");\n        const float widthScale = float("+tv+");\n\n        const float invHeightScale = float("+tm+");\n        const float invWidthScale = float("+tg+");\n\n        const int winHeight = int("+ty+");\n        const int winWidth = int("+tx+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+tl+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+th+") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float("+td[0]+") *\n                (float(dyR) / float("+tf[0]+"));\n\n            float sourceFracCol =\n                float("+td[1]+") *\n                  (float(dyC) / float("+tf[1]+"));\n\n            int sourceNearestRow = int(min(\n                float(int("+to+") - 1),\n                "+te+" ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int("+tu+") - 1),\n                "+te+" ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "},os=function(h,g,te,tr){this.variableNames=["A"],this.outputShape=[];var to=h[0],tu=h[1],tc=h[2],tl=h[3];this.outputShape=[to,g,te,tl];var th=[tr&&g>1?tu-1:tu,tr&&te>1?tc-1:tc],td=[tr&&g>1?g-1:g,tr&&te>1?te-1:te];this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+th[0]/td[0]+",\n          "+th[1]/td[1]+");\n      const vec2 inputShapeRC = vec2("+tu+".0, "+tc+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + "+(tr?"0.5":"0.0")+")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    "},as=function(h,g){this.variableNames=["x"];var te=h.length;if(te>4)throw Error("WebGL backend: Reverse of rank-"+te+" tensor is not yet supported");if(this.outputShape=h,1!==te){var tr=h.map(function(te,tr){return -1!==g.indexOf(tr)&&1!==h[tr]?h[tr]+" - coords["+tr+"] - 1":"coords["+tr+"]"}).join(","),to=wa(te);this.userCode="\n      void main() {\n        "+to+" coords = getOutputCoords();\n        setOutput(getX("+tr+"));\n      }\n    "}else this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX("+h[0]+" - coord - 1));\n        }\n      "},is=function(h,g){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;var te,tr,to,tu=h.length;if(tu>4)throw Error("WebGL backend: Reverse of rank-"+tu+" tensor is not yet supported");this.outputShape=h;var tc=sa("rc",tu),tl=tc[tu-1]+" + 1 < "+this.outputShape[tu-1],th=tc[tu-2]+" + 1 < "+this.outputShape[tu-2],td=wa(tu);function s(te){var tr=h.map(function(tr,to){return -1!==g.indexOf(to)&&1!==h[to]?h[to]+" - "+te[to]+" - 1":""+te[to]});return"getChannel(getX("+tr.join(",")+"), vec2("+tr.slice(-2).join(",")+"))"}this.userCode=1===tu?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX("+h[0]+" - rc - 1),\n            "+h[0]+" - rc - 1);\n          if("+tl+"){\n              result.g = getChannel(getX("+h[0]+" - (rc  + 1) - 1),\n                "+h[0]+" - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      ":"\n        void main() {\n          "+td+" rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = "+s(tc.slice())+";\n          if("+tl+"){\n            result.g = "+((te=tc.slice())[tu-1]="("+te[tu-1]+" + 1)",s(te))+";\n          }\n          if("+th+") {\n            result.b = "+((tr=tc.slice())[tu-2]="("+tr[tu-2]+" + 1)",s(tr))+";\n            if("+tl+") {\n              result.a = "+((to=tc.slice())[tu-1]="("+to[tu-1]+" + 1)",to[tu-2]="("+to[tu-2]+" + 1)",s(to))+";\n            }\n          }\n          setOutput(result);\n        }\n    "},ss=function(h,g,te,tr,to,tu,tc){void 0===tc&&(tc=!0),this.variableNames=["updates","indices","defaultValue"],this.outputShape=tu;var tl=wa(to.length),th=wa(tu.length),td="";1===te?td="i":2===te&&(td="i, j");var tf="getIndices("+td+")",tp="";1===tr?tp="i":2===tr&&(tp="i, coords[1]");var tv="getUpdates("+tp+")";this.userCode="\n        "+tl+" strides = "+tl+"("+to+");\n\n        void main() {\n          "+th+" coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < "+h+"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < "+g+"; j++) {\n              int index = round("+tf+");\n              flattenedIndex += index * "+(g>1?"strides[j]":"strides")+";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += "+tv+";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      "},us=function(h,g){this.variableNames=["x","segmentIds"];var te=h.windowSize,tr=h.batchSize,to=h.inSize,tu=h.numSegments,tc=tu*Math.ceil(to/te);this.outputShape=[tr,tc];var tl=4*Math.floor(te/4),th=te%4,td="\n        sumValue += dot(values, segFilter);\n    ",tf="";to%te>0&&(tf="\n        if (inIdx < 0 || inIdx >= "+to+") {\n          return initializationValue;\n        }\n      ");var tp="";to%te>0&&(tp="\n        if (inIdx < 0 || inIdx >= "+to+") {\n          return -1.0;\n        }\n      "),this.userCode="\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        "+tf+"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        "+tp+"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          "+tu+")) * float("+te+"));\n        int currentSeg = int(mod(float(outIdx), float("+tu+")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < "+tl+"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          "+td+"\n        }\n\n        int inIdx = inOffset + "+tl+";\n        if ("+(1===th)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          "+td+"\n        } else if ("+(2===th)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          "+td+"\n        } else if ("+(3===th)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          "+td+"\n        }\n        setOutput(sumValue);\n      }\n    "},cs=function(h,g,te){if(this.variableNames=["c","a","b"],this.outputShape=g,te>4)throw Error("Where for rank "+te+" is not yet supported");if(1===te)to="resRC",tr="resRC";else{for(var tr,to,tu=["resRC.x","resRC.y","resRC.z","resRC.w"],tc=[],tl=[],th=0;th<g.length;th++)tl.push(""+tu[th]),th<h&&tc.push(""+tu[th]);tr=tc.join(),to=tl.join()}var td=wa(te);this.userCode="\n      void main() {\n        "+td+" resRC = getOutputCoords();\n        float cVal = getC("+tr+");\n        if (cVal >= 1.0) {\n          setOutput(getA("+to+"));\n        } else {\n          setOutput(getB("+to+"));\n        }\n      }\n    "},n4=function(){function t(h){this.variableNames=["source"],this.outputShape=h,this.rank=h.length;var g,te=wa(this.rank),tr="uniform int start["+this.rank+"];",to=function(h){if(1===h)return"sourceLoc";if(h<=6)return n5.slice(0,h).map(function(h){return"sourceLoc."+h}).join(",");throw Error("Slicing for rank "+h+" is not yet supported")}(this.rank);g="\n        "+te+" sourceLoc;\n        "+te+" coords = getOutputCoords();\n        "+h.map(function(h,g){return"sourceLoc."+n5[g]+" = start["+g+"] + coords."+n5[g]+";"}).join("\n")+"\n      ",this.userCode="\n      "+tr+"\n      void main() {\n        "+g+"\n        setOutput(getSource("+to+"));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(h){var g=this;if(h.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+h.length+")");return function(te,tr){null==g.startLoc&&(g.startLoc=te.getUniformLocationNoThrow(tr,"start"),null==g.startLoc)||te.gl.uniform1iv(g.startLoc,h)}},t}(),n5=["x","y","z","w","u","v"],n6=function(){function t(h){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=h,this.rank=h.length;var g=wa(this.rank),te=sa("coords",this.rank),tr=sa("sourceLoc",this.rank),to=1===this.rank?"sourceLoc":"vec2("+tr.slice(-2).join()+")",tu="getChannel(getSource("+tr.join()+"), "+to+")",tc="\n      result.x = "+tu+";\n      if (++"+te[this.rank-1]+" < "+h[this.rank-1]+") {\n        ++"+tr[this.rank-1]+";\n        result.y = "+tu+";\n        --"+tr[this.rank-1]+";\n      }\n    ",tl=1===this.rank?"":"\n      --"+te[this.rank-1]+";\n      if (++"+te[this.rank-2]+" < "+h[this.rank-2]+") {\n        ++"+tr[this.rank-2]+";\n        result.z = "+tu+";\n        if (++"+te[this.rank-1]+" < "+h[this.rank-1]+") {\n          ++"+tr[this.rank-1]+";\n          result.w = "+tu+";\n        }\n      }\n    ",th=this.rank<=4?"sourceLoc = coords +\n            "+g+"("+h.map(function(h,g){return"start["+g+"]"}).join()+");":h.map(function(h,g){return tr[g]+" = "+te[g]+" + start["+g+"];"}).join("\n");this.userCode="\n      uniform int start["+this.rank+"];\n      void main() {\n        "+g+" coords = getOutputCoords();\n        "+g+" sourceLoc;\n        "+th+"\n        vec4 result = vec4(0.);\n        "+tc+"\n        "+tl+"\n        setOutput(result);\n      }\n    "}return t.prototype.getCustomSetupFunc=function(h){var g=this;if(h.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+h.length+")");return function(te,tr){null==g.startLoc&&(g.startLoc=te.getUniformLocationNoThrow(tr,"start"),null==g.startLoc)||te.gl.uniform1iv(g.startLoc,h)}},t}(),ds=function(h,g,te){this.variableNames=["x"],this.outputShape=te;var tr=te.length,to=wa(te.length),tu=wa(te.length),tc="";if(1===tr)tc="coords * strides + begin";else{var tl=0;tc=te.map(function(h,g){return tl++,1===te.length?"coords * strides["+g+"] + begin["+g+"]":"coords["+(tl-1)+"] * strides["+g+"] + begin["+g+"]"}).join(",")}this.userCode="\n      "+to+" begin = "+to+"("+h+");\n      "+to+" strides = "+to+"("+g+");\n\n      void main() {\n        "+tu+" coords = getOutputCoords();\n        setOutput(getX("+tc+"));\n      }\n    "},n8=function(){function t(h){this.gpgpu=h,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}return t.prototype.acquireTexture=function(h,g,te){var tr,to=vs(g,te),tu=ms(h,to,te);if(tu in this.freeTextures||(this.freeTextures[tu]=[]),tu in this.usedTextures||(this.usedTextures[tu]=[]),this.freeTextures[tu].length>0){this.numFreeTextures--,this.numUsedTextures++,this.log();var tc=this.freeTextures[tu].shift();return this.usedTextures[tu].push(tc),tc}return this.numUsedTextures++,this.log(),to===tW.PACKED_2X2_FLOAT32?tr=this.gpgpu.createPackedMatrixTexture(h[0],h[1]):to===tW.PACKED_2X2_FLOAT16?tr=this.gpgpu.createFloat16PackedMatrixTexture(h[0],h[1]):to===tW.UNPACKED_FLOAT32?tr=this.gpgpu.createFloat32MatrixTexture(h[0],h[1]):to===tW.UNPACKED_FLOAT16?tr=this.gpgpu.createFloat16MatrixTexture(h[0],h[1]):to===tW.PACKED_4X1_UNSIGNED_BYTE&&(tr=this.gpgpu.createUnsignedBytesMatrixTexture(h[0],h[1])),this.usedTextures[tu].push(tr),tr},t.prototype.releaseTexture=function(h,g,te,tr){if(null!=this.freeTextures){var to=ms(g,vs(te,tr),tr);to in this.freeTextures||(this.freeTextures[to]=[]),this.freeTextures[to].push(h),this.numFreeTextures++,this.numUsedTextures--;var tu=this.usedTextures[to],tc=tu.indexOf(h);if(tc<0)throw Error("Cannot release a texture that was never provided by this texture manager");tu.splice(tc,1),this.log()}},t.prototype.log=function(){if(this.logEnabled){var h=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",this.numFreeTextures+" / "+this.numUsedTextures,"("+h+")")}},t.prototype.getNumUsedTextures=function(){return this.numUsedTextures},t.prototype.getNumFreeTextures=function(){return this.numFreeTextures},t.prototype.dispose=function(){var h=this;if(null!=this.freeTextures){for(var g in this.freeTextures)this.freeTextures[g].forEach(function(g){h.gpgpu.deleteMatrixTexture(g)});for(var g in this.usedTextures)this.usedTextures[g].forEach(function(g){h.gpgpu.deleteMatrixTexture(g)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0}},t}();function vs(h,g){if(h===tL.UPLOAD)return tW.PACKED_2X2_FLOAT32;if(h===tL.RENDER||null==h)return tl.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?g?tW.PACKED_2X2_FLOAT32:tW.UNPACKED_FLOAT32:g?tW.PACKED_2X2_FLOAT16:tW.UNPACKED_FLOAT16;if(h===tL.DOWNLOAD||h===tL.PIXELS)return tW.PACKED_4X1_UNSIGNED_BYTE;throw Error("Unknown logical texture type "+h)}function ms(h,g,te){return h[0]+"_"+h[1]+"_"+g+"_"+te}var gs=function(h,g){this.variableNames=["A"];for(var te=Array(h.length),tr=0;tr<te.length;tr++)te[tr]=h[tr]*g[tr];this.outputShape=te,this.rank=te.length;var to=wa(this.rank),tu=function(h){var g=h.length;if(g>5)throw Error("Tile for rank "+g+" is not yet supported");if(1===g)return"imod(resRC, "+h[0]+")";for(var te=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],tr=[],to=0;to<h.length;to++)tr.push("imod("+te[to]+", "+h[to]+")");return tr.join()}(h);this.userCode="\n      void main() {\n        "+to+" resRC = getOutputCoords();\n        setOutput(getA("+tu+"));\n      }\n    "},ys=function(h,g){this.variableNames=["A"];for(var te=Array(h.length),tr=0;tr<te.length;tr++)te[tr]=h[g[tr]];this.outputShape=te,this.rank=te.length;var to=wa(this.rank),tu=function(h){var g=h.length;if(g>6)throw Error("Transpose for rank "+g+" is not yet supported");for(var te=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],tr=Array(g),to=0;to<h.length;to++)tr[h[to]]=te[to];return tr.join()}(g);this.userCode="\n    void main() {\n      "+to+" resRC = getOutputCoords();\n      setOutput(getA("+tu+"));\n    }\n    "},xs=function(h,g){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;for(var te=Array(h.length),tr=0;tr<te.length;tr++)te[tr]=h[g[tr]];if(this.outputShape=te,this.rank=te.length,this.rank>6)throw Error("Packed transpose for rank "+this.rank+" is not yet supported.");var to=wa(this.rank),tu=ia("rc",this.rank),tc=Array(this.rank);for(tr=0;tr<g.length;tr++)tc[g[tr]]=tu[tr];var tl="vec2("+tc.slice(-2).join()+")",th="++"+tu[this.rank-1]+" < "+te[this.rank-1],td="getChannel(getA("+tc.join()+"), "+tl+")";this.userCode="\n    void main() {\n      "+to+" rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = "+td+";\n      if("+th+") {\n        result[1] = "+td+";\n      }\n      --"+tu[this.rank-1]+";\n      if(++"+tu[this.rank-2]+" < "+te[this.rank-2]+") {\n        result[2] = "+td+";\n        if("+th+") {\n          result[3] = "+td+";\n        }\n      }\n      setOutput(result);\n    }\n    "},Cs=function(h,g){this.variableNames=["A"],this.outputShape=h,this.userCode="\n      float unaryOperation(float x) {\n        "+g+"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "},n7="if (isnan(x)) return x;",n9="return abs(x);",en=n7+"\n  return (x < 0.0) ? 0.0 : x;\n",eu=n7+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",ec="return (x >= 0.0) ? x : (exp(x) - 1.0);",el="return -x;",eh="return ceil(x);",ed="return floor(x);",ef="return exp(x);",ep="return exp(x) - 1.0;",ev=n7+"\n  return sin(x);\n",em=n7+"\n  return cos(x);\n",eg=n7+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n",ey=n7+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n",ex=n7+"\n  return atan(x);\n",eb=n7+"return log(x + sqrt(x * x + 1.0));",eC=n7+"\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));",ew=n7+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;",eE="return x;",eR="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",eI="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",ek="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",Xs=function(h,g){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=h,this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        "+g+"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "},Ys=function(h){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=h;var g=h.length,te=sa("rc",g),tr=wa(g),to=function(h,g){if(1===h)return"rc";for(var te="",tr=0;tr<h;tr++)te+=g[tr],tr<h-1&&(te+=",");return te}(g,te),tu=te.slice(-2),tc=g<=1?"rc":"vec2("+tu.join(",")+")";this.userCode="\n      void main() {\n        "+tr+" rc = getOutputCoords();\n        vec4 packedInput = getA("+to+");\n\n        setOutput(getChannel(packedInput, "+tc+"));\n      }\n    "},eA={};function Qs(h,g){if(void 0===g&&(g=!1),"linear"===h)return"return x;";if("relu"===h)return g?eR:en;if("elu"===h)return g?ek:ec;if("relu6"===h)return g?eI:eu;if("prelu"===h)return g?nY:n$;throw Error("Activation "+h+" has not been implemented for the WebGL backend.")}var eS=function(h){function o(g){var te,tr=h.call(this)||this;if(tr.pendingRead=new WeakMap,tr.pendingDisposal=new WeakSet,tr.dataRefCount=new WeakMap,tr.numBytesInGPU=0,tr.uploadWaitMs=0,tr.downloadWaitMs=0,tr.warnedAboutMemory=!1,tr.pendingDeletes=0,tr.disposed=!1,!tl.getBool("HAS_WEBGL"))throw Error("WebGL is not supported on this device");if(null==g){var to=jt(tl.getNumber("WEBGL_VERSION"));tr.binaryCache=((te=tl.getNumber("WEBGL_VERSION"))in eA||(eA[te]={}),eA[te]),tr.gpgpu=new n2(to),tr.canvas=to.canvas,tr.gpgpuCreatedLocally=!0}else tr.gpgpu=g,tr.binaryCache={},tr.gpgpuCreatedLocally=!1,tr.canvas=g.gl.canvas;return tr.textureManager=new n8(tr.gpgpu),tr.numMBBeforeWarning=null==tl.global.screen?1024:tl.global.screen.height*tl.global.screen.width*window.devicePixelRatio*600/1024/1024,tr.texData=new nH(tr,tM),tr}return e(o,h),o.prototype.numDataIds=function(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes},o.prototype.write=function(h,g,te){if(tl.getBool("DEBUG")&&this.checkNumericalProblems(h),"complex64"===te&&null!=h)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");var tr={};return this.texData.set(tr,{shape:g,dtype:te,values:h,usage:tL.UPLOAD}),tr},o.prototype.move=function(h,g,te,tr){if(tl.getBool("DEBUG")&&this.checkNumericalProblems(g),"complex64"===tr)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(h,{shape:te,dtype:tr,values:g,usage:tL.UPLOAD})},o.prototype.readSync=function(h){var g=this.texData.get(h),te=g.values,tr=g.dtype,to=g.complexTensors,tu=g.slice,tc=g.shape,tl=g.isPacked;if(null!=tu){var th=void 0;th=tl?new Xs(tc,eE):new Cs(tc,eE);var td=this.runWebGLProgram(th,[{dataId:h,shape:tc,dtype:tr}],tr),tf=this.readSync(td.dataId);return this.disposeData(td.dataId),tf}if(null!=te)return this.convertAndCacheOnCPU(h);if("string"===tr)return te;var tp,tv,tm=null!=this.activeTimers;return tm&&(tp=et()),tv="complex64"===tr?Vo(to.real.dataSync(),to.imag.dataSync()):this.getValuesFromTexture(h),tm&&(this.downloadWaitMs+=et()-tp),this.convertAndCacheOnCPU(h,tv)},o.prototype.read=function(h){return n(this,void 0,void 0,function(){var g,te,tr,to,tu,tc,th,td,tf,tp,tv,tm,tg,ty,tx,tb,tC,tw,tE,tR;return r(this,function(tI){switch(tI.label){case 0:if(this.pendingRead.has(h))return g=this.pendingRead.get(h),[2,new Promise(function(h){return g.push(h)})];if(tr=(te=this.texData.get(h)).values,to=te.shape,tu=te.slice,tc=te.dtype,th=te.complexTensors,td=te.isPacked,null!=tu)return tf=void 0,tf=td?new Xs(to,eE):new Cs(to,eE),tp=this.runWebGLProgram(tf,[{dataId:h,shape:to,dtype:tc}],tc),tv=this.read(tp.dataId),this.disposeData(tp.dataId),[2,tv];if(null!=tr)return[2,this.convertAndCacheOnCPU(h)];if(!tl.getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===tl.getNumber("WEBGL_VERSION"))throw Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");return tm=null,"complex64"!==tc&&tl.get("WEBGL_BUFFER_SUPPORTED")&&(tg=this.decode(h),ty=this.texData.get(tg.dataId),tm=(tR=this.gpgpu).createBufferFromTexture.apply(tR,[ty.texture].concat(Yt(to)))),this.pendingRead.set(h,[]),"complex64"===tc?[3,2]:[4,this.gpgpu.createAndWaitForFence()];case 1:tI.sent(),tI.label=2;case 2:return"complex64"!==tc?[3,4]:[4,Promise.all([th.real.data(),th.imag.data()])];case 3:return tx=Vo((tb=tI.sent())[0],tb[1]),[3,5];case 4:null==tm?tx=this.getValuesFromTexture(h):(tC=k(to),tx=this.gpgpu.downloadFloat32MatrixFromBuffer(tm,tC)),tI.label=5;case 5:return null!=tg&&this.disposeData(tg.dataId),tw=this.convertAndCacheOnCPU(h,tx),tE=this.pendingRead.get(h),this.pendingRead.delete(h),tE.forEach(function(h){return h(tw)}),this.pendingDisposal.has(h)&&(this.pendingDisposal.delete(h),this.disposeData(h),this.pendingDeletes--),[2,tw]}})})},o.prototype.checkNumericalProblems=function(h){if(null!=h)for(var g=0;g<h.length;g++){var te=h[g];if(!ee(te)){if(tl.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value "+te+" cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value "+te+" cannot be represented on this device.")}}},o.prototype.getValuesFromTexture=function(h){var g,te=this.texData.get(h),tr=te.shape,to=te.dtype,tu=te.isPacked,tc=k(tr);if(tl.getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){var th=this.decode(h),td=this.texData.get(th.dataId),tf=(g=this.gpgpu).downloadMatrixFromPackedTexture.apply(g,[td.texture].concat(Yt(tr))).subarray(0,tc);return this.disposeData(th.dataId),tf}var tp=tl.getBool("WEBGL_PACK")&&!0===tu,tv=tp?Te(tr):tr,tm=tp?new ci(tv):new ui(tv),tg=this.runWebGLProgram(tm,[{shape:tv,dtype:to,dataId:h}],"float32"),ty=this.texData.get(tg.dataId),tx=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(ty.texture,ty.texShape[0],ty.texShape[1]).subarray(0,tc);return this.disposeData(tg.dataId),tx},o.prototype.time=function(h){return n(this,void 0,void 0,function(){var g,te,tr,to,tu,tc,th;return r(this,function(td){switch(td.label){case 0:return g=this.activeTimers,te=[],tr=!1,null==this.programTimersStack?(this.programTimersStack=te,tr=!0):this.activeTimers.push(te),this.activeTimers=te,h(),to=I(this.activeTimers.map(function(h){return h.query})).filter(function(h){return null!=h}),tu=I(this.activeTimers.map(function(h){return h.name})).filter(function(h){return null!=h}),this.activeTimers=g,tr&&(this.programTimersStack=null),tc={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},tl.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?[4,Promise.all(to)]:[3,2];case 1:return th=td.sent(),tc.kernelMs=w(th),tc.getExtraProfileInfo=function(){return th.map(function(h,g){return{name:tu[g],ms:h}}).map(function(h){return h.name+": "+h.ms}).join(", ")},[3,3];case 2:tc.kernelMs={error:"WebGL query timers are not supported in this environment."},td.label=3;case 3:return this.uploadWaitMs=0,this.downloadWaitMs=0,[2,tc]}})})},o.prototype.memory=function(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU}},o.prototype.startTimer=function(){return tl.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:et(),endMs:null}},o.prototype.endTimer=function(h){return tl.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.endQuery():h.endMs=et(),h},o.prototype.getQueryTime=function(h){return n(this,void 0,void 0,function(){var g;return r(this,function(te){return tl.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?[2,this.gpgpu.waitForQueryAndGetTime(h)]:[2,(g=h).endMs-g.startMs]})})},o.prototype.disposeData=function(h){if(!this.pendingDisposal.has(h)){if(this.pendingRead.has(h))return this.pendingDisposal.add(h),void this.pendingDeletes++;if(this.texData.has(h)){this.releaseGPUData(h);var g=this.texData.get(h).complexTensors;null!=g&&(g.real.dispose(),g.imag.dispose()),this.texData.delete(h)}}},o.prototype.releaseGPUData=function(h){var g=this.texData.get(h),te=g.texture,tr=g.dtype,to=g.texShape,tu=g.usage,tc=g.isPacked,tl=g.slice,th=tl&&tl.origDataId||h,td=this.dataRefCount.get(th);td>1?this.dataRefCount.set(th,td-1):(this.dataRefCount.delete(th),null!=te&&(this.numBytesInGPU-=this.computeBytes(to,tr),this.textureManager.releaseTexture(te,to,tu,tc)));var tf=this.texData.get(h);tf.texture=null,tf.texShape=null,tf.isPacked=!1,tf.slice=null},o.prototype.getTexture=function(h){return this.uploadToGPU(h),this.texData.get(h).texture},o.prototype.getDataInfo=function(h){return this.texData.get(h)},o.prototype.getCPUBackend=function(){return tl.getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=tM.findBackend("cpu")),this.cpuBackend):null},o.prototype.shouldExecuteOnCPU=function(h,g){var te=this;return void 0===g&&(g=128),null!=this.getCPUBackend()&&h.every(function(h){return null==te.texData.get(h.dataId).texture&&h.size<g})},o.prototype.getGPGPUContext=function(){return this.gpgpu},o.prototype.complex=function(h,g){var te=this.makeOutput(h.shape,"complex64");return this.texData.get(te.dataId).complexTensors={real:tM.keep(h.clone()),imag:tM.keep(g.clone())},te},o.prototype.real=function(h){return this.texData.get(h.dataId).complexTensors.real.clone()},o.prototype.imag=function(h){return this.texData.get(h.dataId).complexTensors.imag.clone()},o.prototype.slice=function(h,g,te){if(this.shouldExecuteOnCPU([h]))return this.cpuBackend.slice(h,g,te);if(0===k(te))return Fn([],te,h.dtype);var tr=this.texData.get(h.dataId).isPacked,to=io(h.shape,g,te);if(tr||!to){var tu=tl.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new n6(te):new n4(te),tc=tu.getCustomSetupFunc(g);return this.compileAndRun(tu,[h],null,tc)}return this.uploadToGPU(h.dataId),this.shallowSlice(h,g,te)},o.prototype.shallowSlice=function(h,g,te){var tr=this.texData.get(h.dataId),to=this.makeOutput(te,h.dtype),tu=this.texData.get(to.dataId);Object.assign(tu,tr),tu.shape=te,tu.dtype=h.dtype;var tc=so(g,h.strides);tr.slice&&(tc+=tr.slice.flatOffset),tu.slice={flatOffset:tc,origDataId:tr.slice&&tr.slice.origDataId||h.dataId};var tl=this.dataRefCount.get(tu.slice.origDataId)||1;return this.dataRefCount.set(tu.slice.origDataId,tl+1),to},o.prototype.stridedSlice=function(h,g,te,tr){if(this.shouldExecuteOnCPU([h]))return this.cpuBackend.stridedSlice(h,g,te,tr);var to=ro(g,te,tr);if(to.some(function(h){return 0===h}))return Fn([],to);var tu=new ds(g,tr,to);return this.compileAndRun(tu,[h])},o.prototype.reverse=function(h,g){var te=tl.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new is(h.shape,g):new as(h.shape,g);return this.compileAndRun(te,[h])},o.prototype.concat=function(h,g){if("complex64"===h[0].dtype){var te=h.map(function(h){return tJ(h)}),tr=h.map(function(h){return tQ(h)});return tY(this.concat(te,g),this.concat(tr,g))}if(this.shouldExecuteOnCPU(h))return this.cpuBackend.concat(h,g);if(1===h.length)return h[0];if(h.length>tl.getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){var to=Math.floor(h.length/2),tu=this.concat(h.slice(0,to),g),tc=this.concat(h.slice(to),g);return this.concat([tu,tc],g)}if(tl.getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&h[0].rank>1){var th=new Ga(h.map(function(h){return h.shape}),g);return this.compileAndRun(th,h)}var td=Sn(h.map(function(h){return h.shape}),g),tf=h.map(function(h){return h.as2D(-1,k(h.shape.slice(g)))}),tp=new za(tf.map(function(h){return h.shape}));return this.compileAndRun(tp,tf).reshape(td)},o.prototype.neg=function(h){if(this.shouldExecuteOnCPU([h]))return this.cpuBackend.neg(h);if(tl.getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(h,el,h.dtype);var g=new Cs(h.shape,el);return this.compileAndRun(g,[h])},o.prototype.batchMatMul=function(h,g,te,tr){var to=te?h.shape[2]:h.shape[1],tu=tr?g.shape[1]:g.shape[2],tc=te?h.shape[1]:h.shape[2],tl=h.shape[0];if((1===to||1===tu)&&tc>1e3){te&&(h=h.transpose([0,2,1])),tr&&(g=g.transpose([0,2,1]));var th=1===tu?h:h.as3D(tl,tc,1),td=1===tu?2:1,tf=1===tu?g.as3D(tl,1,tc):g;return this.multiply(th,tf).sum(td,!0)}var tp=Dt(h.dtype,g.dtype),tv=new Hi(h.shape,[tl,to,tu],te,tr);return this.compileAndRun(tv,[h,g],tp)},o.prototype.fusedBatchMatMul=function(h){var g=h.a,te=h.b,tr=h.transposeA,to=h.transposeB,tu=h.bias,tc=h.activation,tl=h.preluActivationWeights,th=tr?g.shape[2]:g.shape[1],td=to?te.shape[1]:te.shape[2],tf=g.shape[0],tp=Dt(g.dtype,te.dtype),tv=null!=tu,tm=null!=tl,tg=tc?Qs(tc,!0):null,ty=new Hi(g.shape,[tf,th,td],tr,to,tv,tg,tm),tx=[g,te];return tu&&tx.push(tu),tl&&tx.push(tl),this.compileAndRun(ty,tx,tp)},o.prototype.multiply=function(h,g){if("complex64"===h.dtype){var te=this.texData.get(h.dataId),tr=this.texData.get(g.dataId),to=new Na("return areal * breal - aimag * bimag;",h.shape,g.shape),tu=new Na("return areal * bimag + aimag * breal;",h.shape,g.shape),tc=[this.makeComplexComponentTensorInfo(h,te.complexTensors.real),this.makeComplexComponentTensorInfo(h,te.complexTensors.imag),this.makeComplexComponentTensorInfo(g,tr.complexTensors.real),this.makeComplexComponentTensorInfo(g,tr.complexTensors.imag)],th=this.compileAndRun(to,tc),td=this.compileAndRun(tu,tc),tf=this.complex(th,td);return th.dispose(),td.dispose(),tf}if(this.shouldExecuteOnCPU([h,g]))return this.cpuBackend.multiply(h,g);if(tl.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(h,g,nX,h.dtype);var tp=new Ba(nX,h.shape,g.shape);return this.compileAndRun(tp,[h,g],h.dtype)},o.prototype.batchNormalization=function(h,g,te,tr,to,tu){var tc=[h,g,te],th=null;null!=tu&&(th=tu.shape,tc.push(tu));var td=null;if(null!=to&&(td=to.shape,tc.push(to)),tl.getBool("WEBGL_PACK_NORMALIZATION")){var tf=new Aa(h.shape,g.shape,te.shape,th,td,tr);return this.compileAndRun(tf,tc)}var tp=new Sa(h.shape,g.shape,te.shape,th,td,tr);return this.compileAndRun(tp,tc)},o.prototype.localResponseNormalization4D=function(h,g,te,tr,to){var tu=tl.getBool("WEBGL_PACK_NORMALIZATION")?new Vi(h.shape,g,te,tr,to):new Wi(h.shape,g,te,tr,to);return this.compileAndRun(tu,[h])},o.prototype.LRNGrad=function(h,g,te,tr,to,tu,tc){var tl=new Ui(g.shape,tr,to,tu,tc);return this.compileAndRun(tl,[g,te,h])},o.prototype.tile=function(h,g){if("string"===h.dtype){var te=this.readSync(h.dataId).map(function(h){return ot(h)});return ta(dr(h.shape,h.dtype,te),g)}var tr=new gs(h.shape,g);return this.compileAndRun(tr,[h])},o.prototype.pad=function(h,g,te){var tr=tl.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Yi(h.shape,g,te):new Xi(h.shape,g,te);return this.compileAndRun(tr,[h])},o.prototype.transpose=function(h,g){if(this.shouldExecuteOnCPU([h]))return this.cpuBackend.transpose(h,g);var te=tl.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new xs(h.shape,g):new ys(h.shape,g);return this.compileAndRun(te,[h])},o.prototype.gather=function(h,g,te){if(this.shouldExecuteOnCPU([h,g]))return this.cpuBackend.gather(h,g,te);var tr=new mi(h.shape,g.size,te);return this.compileAndRun(tr,[h,g])},o.prototype.batchToSpaceND=function(h,g,te){C(h.rank<=4,function(){return"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"});var tr=g.reduce(function(h,g){return h*g}),to=zr(h.shape,g,tr),tu=Gr(to.length,g.length),tc=Hr(h.shape,g,tr),tl=qr(te,g.length),th=Kr(tc,te,g.length);return h.reshape(to).transpose(tu).reshape(tc).slice(tl,th)},o.prototype.spaceToBatchND=function(h,g,te){C(h.rank<=4,function(){return"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"});var tr=g.reduce(function(h,g){return h*g}),to=[[0,0]];to.push.apply(to,te);for(var tu=1+g.length;tu<h.shape.length;++tu)to.push([0,0]);var tc=h.pad(to),tl=zr(tc.shape,g,tr,!1),th=Gr(tl.length,g.length,!1),td=Hr(tc.shape,g,tr,!1);return tc.reshape(tl).transpose(th).reshape(td)},o.prototype.reduce=function(h,g,te){var tr=h.shape[0],to=h.shape[1],tu=$r(to),tc=new Ji({windowSize:tu,inSize:to,batchSize:tr},g),tl=this.compileAndRun(tc,[h],te);return 1===tl.shape[1]?tl:this.reduce(tl,g,te)},o.prototype.argReduce=function(h,g,te){void 0===te&&(te=null);var tr=h.shape[0],to=h.shape[1];null!=te&&(tr=te.shape[0],to=te.shape[1]);var tu=$r(to),tc=new aa({windowSize:tu,inSize:to,batchSize:tr},g,null==te),tl=[h];null!=te&&tl.push(te);var th=this.compileAndRun(tc,tl,"int32");return 1===th.shape[1]?th:this.argReduce(h,g,th)},o.prototype.argReducePacked=function(h,g,te){void 0===te&&(te=null);var tr=null!=te?te.shape:h.shape,to=$r(tr[tr.length-1]),tu=new Ra(tr,to,g,null==te),tc=null==te?[h]:[h,te],tl=this.compileAndRun(tu,tc,"int32");return tl.rank===h.rank?this.argReducePacked(h,g,tl):tl},o.prototype.sum=function(h,g){Cn("sum",g,h.rank);var te=bn(h.shape,g),tr=te[0],to=k(te[1]),tu=h.as2D(-1,to),tc=Tt(h.dtype);return this.reduce(tu,"sum",tc).reshape(tr)},o.prototype.prod=function(h,g){if(this.shouldExecuteOnCPU([h]))return this.cpuBackend.prod(h,g);var te=bn(h.shape,g),tr=te[0],to=k(te[1]),tu=h.as2D(-1,to),tc=Tt(h.dtype);return this.reduce(tu,"prod",tc).reshape(tr)},o.prototype.unsortedSegmentSum=function(h,g,te){var tr=0,to=En([0],h.rank),tu=h;null!=to&&(tu=h.transpose(to),tr=In(1,h.rank)[0]);var tc=function(h,g,te){for(var tr=[],to=h.length,tu=0;tu<to;tu++)tu!==g?tr.push(h[tu]):tr.push(te);return tr}(tu.shape,tr,te),tl=k([tu.shape[tr]]),th=tu.as2D(-1,tl),td=Tt(h.dtype),tf=this.segOpCompute(th,"unsortedSegmentSum",g,td,te).reshape(tc);return null!=to&&(tf=tf.transpose(Rn(to))),tf},o.prototype.segOpCompute=function(h,g,te,tr,to){var tu=h.shape[0],tc=h.shape[1],tl=function(h,g){var te,tr=!1;for(h<=30?(te=h,tr=!0):te=Y(h,Math.floor(Math.sqrt(h)));!tr;)te>g||te===h?tr=!0:te=Y(h,te+1);return te}(tc,to),th=new us({windowSize:tl,inSize:tc,batchSize:tu,numSegments:to},g),td=this.compileAndRun(th,[h,te],tr);return td.shape[1]===to?td:(te=Kn(0,to).tile([tc/tl]),this.segOpCompute(td,g,te,tr,to))},o.prototype.argMinMaxReduce=function(h,g,te){var tr=[g];if(Cn("arg"+te.charAt(0).toUpperCase()+te.slice(1),tr,h.rank),!tl.getBool("WEBGL_PACK_REDUCE")||h.rank<=2){var to=bn(h.shape,tr),tu=to[0],tc=k(to[1]),th=h.as2D(-1,tc);return this.argReduce(th,te).reshape(tu)}return this.argReducePacked(h,te)},o.prototype.argMin=function(h,g){return this.argMinMaxReduce(h,g,"min")},o.prototype.argMax=function(h,g){return this.argMinMaxReduce(h,g,"max")},o.prototype.cumsum=function(h,g,te,tr){if(g!==h.rank-1)throw Error("WebGL cumsum shader expects an inner-most axis="+(h.rank-1)+" but got axis="+g);var to=new ni(h.shape,te,tr);return this.compileAndRun(to,[h])},o.prototype.equal=function(h,g){if(tl.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(h,g,"\n  return vec4(equal(a, b));\n","bool");var te=new Ba("return float(a == b);",h.shape,g.shape);return this.compileAndRun(te,[h,g],"bool")},o.prototype.notEqual=function(h,g){if(tl.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(h,g,"\n  return vec4(notEqual(a, b));\n","bool");var te=new Ba("return float(a != b);",h.shape,g.shape);return this.compileAndRun(te,[h,g],"bool")},o.prototype.less=function(h,g){if(this.shouldExecuteOnCPU([h,g]))return this.cpuBackend.less(h,g);if(tl.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(h,g,"\n  return vec4(lessThan(a, b));\n","bool");var te=new Ba("return float(a < b);",h.shape,g.shape);return this.compileAndRun(te,[h,g],"bool")},o.prototype.lessEqual=function(h,g){if(tl.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(h,g,"\n  return vec4(lessThanEqual(a, b));\n","bool");var te=new Ba("return float(a <= b);",h.shape,g.shape);return this.compileAndRun(te,[h,g],"bool")},o.prototype.greater=function(h,g){if(this.shouldExecuteOnCPU([h,g]))return this.cpuBackend.greater(h,g);if(tl.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(h,g,"\n  return vec4(greaterThan(a, b));\n","bool");var te=new Ba("return float(a > b);",h.shape,g.shape);return this.compileAndRun(te,[h,g],"bool")},o.prototype.greaterEqual=function(h,g){if(tl.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(h,g,"\n  return vec4(greaterThanEqual(a, b));\n","bool");var te=new Ba("return float(a >= b);",h.shape,g.shape);return this.compileAndRun(te,[h,g],"bool")},o.prototype.logicalNot=function(h){var g=new Cs(h.shape,"return float(!(x >= 1.0));");return this.compileAndRun(g,[h])},o.prototype.logicalAnd=function(h,g){if(tl.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(h,g,"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n","bool");var te=new Ba("return float(a >= 1.0 && b >= 1.0);",h.shape,g.shape);return this.compileAndRun(te,[h,g],"bool")},o.prototype.logicalOr=function(h,g){if(tl.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(h,g,"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n","bool");var te=new Ba("return float(a >= 1.0 || b >= 1.0);",h.shape,g.shape);return this.compileAndRun(te,[h,g],"bool")},o.prototype.select=function(h,g,te){var tr=new cs(h.rank,g.shape,g.rank);return this.compileAndRun(tr,[h,g,te],Dt(g.dtype,te.dtype))},o.prototype.where=function(h){dn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");var g=h.dataSync();return na(h.shape,g)},o.prototype.topk=function(h,g,te){return ea(h.dataSync(),h.shape,h.dtype,g)},o.prototype.min=function(h,g){Cn("min",g,h.rank);var te=bn(h.shape,g),tr=te[0],to=k(te[1]),tu=h.as2D(-1,to);return this.reduce(tu,"min",tu.dtype).reshape(tr)},o.prototype.minimum=function(h,g){if(this.shouldExecuteOnCPU([h,g]))return this.cpuBackend.minimum(h,g);var te=tl.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",h.shape,g.shape):new Ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",h.shape,g.shape);return this.compileAndRun(te,[h,g])},o.prototype.mod=function(h,g){var te=tl.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",h.shape,g.shape):new Ba("if (b == 0.0) return NAN;\n  return mod(a, b);",h.shape,g.shape);return this.compileAndRun(te,[h,g])},o.prototype.max=function(h,g){if(this.shouldExecuteOnCPU([h]))return this.cpuBackend.max(h,g);Cn("max",g,h.rank);var te=bn(h.shape,g),tr=te[0],to=k(te[1]),tu=h.as2D(-1,to);return this.reduce(tu,"max",tu.dtype).reshape(tr)},o.prototype.maximum=function(h,g){if(this.shouldExecuteOnCPU([h,g]))return this.cpuBackend.maximum(h,g);var te=tl.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",h.shape,g.shape):new Ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",h.shape,g.shape);return this.compileAndRun(te,[h,g])},o.prototype.all=function(h,g){Cn("all",g,h.rank);var te=bn(h.shape,g),tr=te[0],to=k(te[1]),tu=h.as2D(-1,to);return this.reduce(tu,"all",tu.dtype).reshape(tr)},o.prototype.any=function(h,g){Cn("any",g,h.rank);var te=bn(h.shape,g),tr=te[0],to=k(te[1]),tu=h.as2D(-1,to);return this.reduce(tu,"any",tu.dtype).reshape(tr)},o.prototype.realDivide=function(h,g){if(tl.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(h,g,"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n","float32",!0);var te=new Ba("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",h.shape,g.shape);return this.compileAndRun(te,[h,g],"float32")},o.prototype.floorDiv=function(h,g){if(tl.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(h,g,"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n","int32");var te=new Ba("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",h.shape,g.shape);return this.compileAndRun(te,[h,g],"int32")},o.prototype.add=function(h,g){if("complex64"===h.dtype&&"complex64"===g.dtype)return this.complexSeparableBinaryOp(h,g,nK);if(this.shouldExecuteOnCPU([h,g]))return this.cpuBackend.add(h,g);var te=Dt(h.dtype,g.dtype);if(tl.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(h,g,nK,te);var tr=new Ba(nK,h.shape,g.shape);return this.compileAndRun(tr,[h,g],te)},o.prototype.packedUnaryOp=function(h,g,te){var tr=new Xs(h.shape,g);return this.compileAndRun(tr,[h],te)},o.prototype.packedBinaryOp=function(h,g,te,tr,to){void 0===to&&(to=!1);var tu=new La(te,h.shape,g.shape,to);return this.compileAndRun(tu,[h,g],tr)},o.prototype.complexSeparableBinaryOp=function(h,g,te){var tr=this,to=this.texData.get(h.dataId),tu=this.texData.get(g.dataId),tc=[[to.complexTensors.real,tu.complexTensors.real],[to.complexTensors.imag,tu.complexTensors.imag]].map(function(to){var tu=to[0],tc=to[1],tl=tr.makeComplexComponentTensorInfo(h,tu),th=tr.makeComplexComponentTensorInfo(g,tc),td=new Ba(te,h.shape,g.shape);return tr.compileAndRun(td,[tl,th],Dt(tu.dtype,tc.dtype))}),tl=tc[0],th=tc[1],td=this.complex(tl,th);return tl.dispose(),th.dispose(),td},o.prototype.makeComplexComponentTensorInfo=function(h,g){return{dataId:g.dataId,dtype:g.dtype,shape:h.shape}},o.prototype.addN=function(h){if(1===h.length)return h[0];if(h.length>tl.get("WEBGL_MAX_TEXTURES_IN_SHADER")){var g=Math.floor(h.length/2),te=this.addN(h.slice(0,g)),tr=this.addN(h.slice(g));return this.addN([te,tr])}var to=h.map(function(h){return h.dtype}).reduce(function(h,g){return Dt(h,g)}),tu=h.map(function(h){return h.shape}),tc=tl.getBool("WEBGL_PACK")?new oa(h[0].shape,tu):new ra(h[0].shape,tu);return this.compileAndRun(tc,h,to)},o.prototype.subtract=function(h,g){if("complex64"===h.dtype&&"complex64"===g.dtype)return this.complexSeparableBinaryOp(h,g,nj);if(this.shouldExecuteOnCPU([h,g]))return this.cpuBackend.subtract(h,g);var te=Dt(h.dtype,g.dtype);if(tl.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(h,g,nj,h.dtype);var tr=new Ba(nj,h.shape,g.shape);return this.compileAndRun(tr,[h,g],te)},o.prototype.pow=function(h,g){var te=tl.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",h.shape,g.shape):new Ba("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",h.shape,g.shape),tr=Dt(h.dtype,g.dtype);return this.compileAndRun(te,[h,g],tr)},o.prototype.ceil=function(h){if(this.shouldExecuteOnCPU([h]))return this.cpuBackend.ceil(h);if(tl.getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(h,eh,h.dtype);var g=new Cs(h.shape,eh);return this.compileAndRun(g,[h])},o.prototype.floor=function(h){if(this.shouldExecuteOnCPU([h]))return this.cpuBackend.floor(h);if(tl.getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(h,ed,h.dtype);var g=new Cs(h.shape,ed);return this.compileAndRun(g,[h])},o.prototype.sign=function(h){var g=new Cs(h.shape,"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");return this.compileAndRun(g,[h])},o.prototype.isNaN=function(h){var g=new Cs(h.shape,"return float(isnan(x));");return this.compileAndRun(g,[h],"bool")},o.prototype.isInf=function(h){var g=new Cs(h.shape,"return float(isinf(x));");return this.compileAndRun(g,[h],"bool")},o.prototype.isFinite=function(h){var g=new Cs(h.shape,"return float(!isnan(x) && !isinf(x));");return this.compileAndRun(g,[h],"bool")},o.prototype.round=function(h){var g=new Cs(h.shape,"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");return this.compileAndRun(g,[h])},o.prototype.exp=function(h){if(this.shouldExecuteOnCPU([h]))return this.cpuBackend.exp(h);if(tl.getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(h,ef,h.dtype);var g=new Cs(h.shape,ef);return this.compileAndRun(g,[h])},o.prototype.expm1=function(h){if(this.shouldExecuteOnCPU([h]))return this.cpuBackend.expm1(h);if(tl.getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(h,ep,h.dtype);var g=new Cs(h.shape,ep);return this.compileAndRun(g,[h])},o.prototype.softmax=function(h,g){var te=O([g],h.shape),tr=this.max(h,te),to=wn(tr.shape,te),tu=this.subtract(h,tr.reshape(to)),tc=this.exp(tu),tl=this.sum(tc,te).reshape(to);return this.realDivide(tc,tl)},o.prototype.log=function(h){if(this.shouldExecuteOnCPU([h]))return this.cpuBackend.log(h);if(tl.getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(h,"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",h.dtype);var g=new Cs(h.shape,"if (x < 0.0) return NAN;\n  return log(x);");return this.compileAndRun(g,[h])},o.prototype.log1p=function(h){var g=new Cs(h.shape,"return log(1.0 + x);");return this.compileAndRun(g,[h])},o.prototype.sqrt=function(h){var g=new Cs(h.shape,"return sqrt(x);");return this.compileAndRun(g,[h])},o.prototype.rsqrt=function(h){if(this.shouldExecuteOnCPU([h]))return this.cpuBackend.rsqrt(h);var g=new Cs(h.shape,"return inversesqrt(x);");return this.compileAndRun(g,[h])},o.prototype.reciprocal=function(h){var g=new Cs(h.shape,"return 1.0 / x;");return this.compileAndRun(g,[h])},o.prototype.relu=function(h){var g;return g=tl.getBool("WEBGL_PACK")?new Xs(h.shape,eR):new Cs(h.shape,en),this.compileAndRun(g,[h])},o.prototype.relu6=function(h){var g;return g=tl.getBool("WEBGL_PACK")?new Xs(h.shape,eI):new Cs(h.shape,eu),this.compileAndRun(g,[h])},o.prototype.prelu=function(h,g){var te=tl.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La(nY,h.shape,g.shape):new Ba(n$,h.shape,g.shape);return this.compileAndRun(te,[h,g])},o.prototype.elu=function(h){if(tl.getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(h,ek,h.dtype);var g=new Cs(h.shape,ec);return this.compileAndRun(g,[h])},o.prototype.eluDer=function(h,g){var te=tl.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",h.shape,g.shape):new Ba("return (b >= 1.0) ? a : a * (b + 1.0);",h.shape,g.shape);return this.compileAndRun(te,[h,g])},o.prototype.selu=function(h){var g=new Cs(h.shape,"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = 1.7580993408473768;\n  float scale = 1.0507009873554805;\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n");return this.compileAndRun(g,[h])},o.prototype.int=function(h){var g=new Cs(h.shape,"return float(int(x));");return this.compileAndRun(g,[h],"int32")},o.prototype.clip=function(h,g,te){var tr,to=(tr=tl.getBool("WEBGL_PACK_CLIP")?new nQ(h.shape):new nJ(h.shape)).getCustomSetupFunc(g,te);return this.compileAndRun(tr,[h],null,to)},o.prototype.abs=function(h){if(this.shouldExecuteOnCPU([h]))return this.cpuBackend.abs(h);if(tl.getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(h,n9,h.dtype);var g=new Cs(h.shape,n9);return this.compileAndRun(g,[h])},o.prototype.complexAbs=function(h){var g=this.texData.get(h.dataId),te=new Va(h.shape),tr=[this.makeComplexComponentTensorInfo(h,g.complexTensors.real),this.makeComplexComponentTensorInfo(h,g.complexTensors.imag)];return this.compileAndRun(te,tr)},o.prototype.sigmoid=function(h){var g=new Cs(h.shape,"return 1.0 / (1.0 + exp(-1.0 * x));");return this.compileAndRun(g,[h])},o.prototype.softplus=function(h){var g=new Cs(h.shape,"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");return this.compileAndRun(g,[h])},o.prototype.sin=function(h){var g=new Cs(h.shape,ev);return this.compileAndRun(g,[h])},o.prototype.cos=function(h){var g=new Cs(h.shape,em);return this.compileAndRun(g,[h])},o.prototype.tan=function(h){var g=new Cs(h.shape,"return tan(x);");return this.compileAndRun(g,[h])},o.prototype.asin=function(h){var g=new Cs(h.shape,eg);return this.compileAndRun(g,[h])},o.prototype.acos=function(h){var g=new Cs(h.shape,ey);return this.compileAndRun(g,[h])},o.prototype.atan=function(h){var g=new Cs(h.shape,ex);return this.compileAndRun(g,[h])},o.prototype.atan2=function(h,g){var te=tl.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",h.shape,g.shape):new Ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",h.shape,g.shape);return this.compileAndRun(te,[h,g])},o.prototype.sinh=function(h){var g=new Cs(h.shape,"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");return this.compileAndRun(g,[h])},o.prototype.cosh=function(h){var g=new Cs(h.shape,"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");return this.compileAndRun(g,[h])},o.prototype.tanh=function(h){var g=new Cs(h.shape,"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");return this.compileAndRun(g,[h])},o.prototype.asinh=function(h){var g=new Cs(h.shape,eb);return this.compileAndRun(g,[h])},o.prototype.acosh=function(h){var g=new Cs(h.shape,eC);return this.compileAndRun(g,[h])},o.prototype.atanh=function(h){var g=new Cs(h.shape,ew);return this.compileAndRun(g,[h])},o.prototype.erf=function(h){var g=new Cs(h.shape,'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n');return this.compileAndRun(g,[h])},o.prototype.step=function(h,g){var te,tr=new Cs(h.shape,(void 0===(te=g)&&(te=0),n7+"\n    return x > 0.0 ? 1.0 : float("+te+");\n  "));return this.compileAndRun(tr,[h])},o.prototype.conv2dByMatMul=function(h,g,te,tr,to,tu){var tc=h.shape,th=this.texData.get(h.dataId),td=te.inChannels,tf=tc[0]*tc[1]*tc[2],tp=te.outChannels,tv="channelsLast"===te.dataFormat,tm=tc[2]%2!=0&&!!th.isPacked;if((1===tf||1===tp)&&td>1e3||!tl.getBool("WEBGL_LAZILY_UNPACK")||!tl.getBool("WEBGL_PACK_BINARY_OPERATIONS")||!tm){var tg=tv?tc[0]*tc[1]*tc[2]:tc[0]*tc[2]*tc[3],ty=this.reshape(h,[1,tg,te.inChannels]),tx=this.reshape(g,[1,te.inChannels,te.outChannels]);return this.reshape(this.fusedBatchMatMul({a:ty,b:tx,transposeA:!1,transposeB:!1,bias:tr,activation:to,preluActivationWeights:tu}),te.outShape)}var tb=tv?tc[0]*tc[1]*(tc[2]+1):tc[0]*tc[2]*(tc[3]+1),tC={dataId:h.dataId,shape:[1,tb,te.inChannels],dtype:h.dtype},tw=th.shape;th.shape=th.shape.slice(),th.shape[th.shape.length-2]++,C(_e(th.shape,tC.shape),function(){return"packed reshape "+th.shape+" to "+tC.shape+" isn't free"});var tE=this.reshape(g,[1,te.inChannels,te.outChannels]),tR=this.fusedBatchMatMul({a:tC,b:tE,transposeA:!1,transposeB:!1,bias:tr,activation:to,preluActivationWeights:tu}),tI=this.texData.get(tR.dataId);return C(tI.isPacked,function(){return"batchMatMul result is expected to be packed"}),th.shape=tw,tI.shape=te.outShape,tM.makeTensorFromDataId(tR.dataId,te.outShape,tR.dtype)},o.prototype.conv2dWithIm2Row=function(h,g,te,tr,to,tu){var tc=te.filterWidth,tl=te.filterHeight,th=te.inChannels,td=te.outWidth,tf=te.outHeight,tp="channelsLast"===te.dataFormat,tv=tc*tl*th,tm=tf*td,tg=[tv,tm],ty=h.squeeze([0]),tx=g.reshape([1,tv,-1]),tb=new Li(tg,ty.shape,te),tC=this.compileAndRun(tb,[ty]).reshape([1,tg[0],tg[1]]),tw=null!=tr,tE=null!=tu,tR=to?Qs(to,!0):null,tI=new Hi(tC.shape,[1,tm,te.outChannels],!0,!1,tw,tR,tE),tk=[tC,tx];tr&&tk.push(tr),tE&&tk.push(tu);var tA=this.compileAndRun(tI,tk);return tp?tA.reshape([1,tf,td,te.outChannels]):tA.reshape([1,te.outChannels,tf,td])},o.prototype.fusedConv2d=function(h){var g=h.input,te=h.filter,tr=h.convInfo,to=h.bias,tu=h.activation,tc=h.preluActivationWeights;if(1===tr.filterHeight&&1===tr.filterWidth&&1===tr.dilationHeight&&1===tr.dilationWidth&&1===tr.strideHeight&&1===tr.strideWidth&&("SAME"===tr.padInfo.type||"VALID"===tr.padInfo.type))return this.conv2dByMatMul(g,te,tr,to,tu,tc);if(tl.getBool("WEBGL_CONV_IM2COL")&&1===g.shape[0])return this.conv2dWithIm2Row(g,te,tr,to,tu,tc);var th=null!=to,td=null!=tc,tf=tu?Qs(tu,!1):null,tp=new Qa(tr,th,tf,td),tv=[g,te];return to&&tv.push(to),tc&&tv.push(tc),this.compileAndRun(tp,tv)},o.prototype.conv2d=function(h,g,te){if(1===te.filterHeight&&1===te.filterWidth&&1===te.dilationHeight&&1===te.dilationWidth&&1===te.strideHeight&&1===te.strideWidth&&("SAME"===te.padInfo.type||"VALID"===te.padInfo.type))return this.conv2dByMatMul(h,g,te);if(tl.getBool("WEBGL_CONV_IM2COL")&&1===h.shape[0])return this.conv2dWithIm2Row(h,g,te);var tr=new Qa(te);return this.compileAndRun(tr,[h,g])},o.prototype.conv2dDerInput=function(h,g,te){var tr=new Ka(te);return this.compileAndRun(tr,[h,g])},o.prototype.conv2dDerFilter=function(h,g,te){var tr=new qa(te);return this.compileAndRun(tr,[h,g])},o.prototype.fusedDepthwiseConv2D=function(h){var g,te=h.input,tr=h.filter,to=h.convInfo,tu=h.bias,tc=h.activation,th=h.preluActivationWeights,td=tl.getBool("WEBGL_PACK_DEPTHWISECONV")&&to.strideWidth<=2&&to.outChannels/to.inChannels==1,tf=tc?Qs(tc,td):null,tp=[te,tr],tv=null!=tu,tm=null!=th;return tv&&tp.push(tu),tm&&tp.push(th),g=td?new ti(to,tv,tf,tm):new Za(to,tv,tf,tm),this.compileAndRun(g,tp)},o.prototype.depthwiseConv2D=function(h,g,te){var tr;return tr=tl.getBool("WEBGL_PACK_DEPTHWISECONV")&&te.strideWidth<=2&&te.outChannels/te.inChannels==1?new ti(te):new Za(te),this.compileAndRun(tr,[h,g])},o.prototype.depthwiseConv2DDerInput=function(h,g,te){var tr=new $a(te);return this.compileAndRun(tr,[h,g])},o.prototype.depthwiseConv2DDerFilter=function(h,g,te){var tr=new Ya(te);return this.compileAndRun(tr,[h,g])},o.prototype.conv3d=function(h,g,te){var tr=new Ja(te);return this.compileAndRun(tr,[h,g])},o.prototype.conv3dDerInput=function(h,g,te){var tr=new Xa(te);return this.compileAndRun(tr,[h,g])},o.prototype.conv3dDerFilter=function(h,g,te){var tr=new ja(te);return this.compileAndRun(tr,[h,g])},o.prototype.maxPool=function(h,g){var te=new $i(g,"max",!1);return this.compileAndRun(te,[h])},o.prototype.avgPool=function(h,g){var te=new $i(g,"avg",!1);return this.compileAndRun(te,[h],"float32")},o.prototype.maxPoolBackprop=function(h,g,te,tr){var to=new $i(tr,"max",!0),tu=this.compileAndRun(to,[g]),tc=new zi(tr),tl=this.compileAndRun(tc,[h,tu],g.dtype);return tu.dispose(),tl},o.prototype.avgPoolBackprop=function(h,g,te){var tr=new Ia(te);return this.compileAndRun(tr,[h],g.dtype)},o.prototype.cast=function(h,g){return Po(h,g,this)},o.prototype.unstack=function(h,g){for(var te=h.shape[g],tr=Array(h.rank-1),to=0,tu=0;tu<h.rank;tu++)tu!==g&&(tr[to++]=h.shape[tu]);var tc=Array(h.rank).fill(0),tl=h.shape.slice();tl[g]=1;var th=Array(te);for(tu=0;tu<th.length;tu++)tc[g]=tu,th[tu]=this.slice(h,tc,tl).reshape(tr);return th},o.prototype.avgPool3d=function(h,g){var te=new Qi(g,"avg",!1);return this.compileAndRun(te,[h],"float32")},o.prototype.avgPool3dBackprop=function(h,g,te){var tr=new ka(te);return this.compileAndRun(tr,[h],g.dtype)},o.prototype.maxPool3d=function(h,g){var te=new Qi(g,"max",!1);return this.compileAndRun(te,[h],"float32")},o.prototype.maxPool3dBackprop=function(h,g,te,tr){var to=new Qi(tr,"max",!0),tu=this.compileAndRun(to,[g]),tc=new Gi(tr),tl=this.compileAndRun(tc,[h,tu],g.dtype);return tu.dispose(),tl},o.prototype.reshape=function(h,g){var te=this.texData.get(h.dataId);if(te.isPacked&&!_e(h.shape,g)&&(null===te.texture||!_e(te.shape,g))){var tr=this.packedReshape(h,g);return tM.makeTensorFromDataId(tr.dataId,tr.shape,tr.dtype)}return Lo(h,g)},o.prototype.resizeBilinear=function(h,g,te,tr){var to=tl.getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ns(h.shape,g,te,tr):new es(h.shape,g,te,tr);return this.compileAndRun(to,[h],"float32")},o.prototype.resizeBilinearBackprop=function(h,g,te){var tr=new ts(h,g,te);return this.compileAndRun(tr,[h])},o.prototype.resizeNearestNeighbor=function(h,g,te,tr){var to=new os(h.shape,g,te,tr);return this.compileAndRun(to,[h])},o.prototype.resizeNearestNeighborBackprop=function(h,g,te){var tr=new rs(h,g,te);return this.compileAndRun(tr,[h])},o.prototype.multinomial=function(h,g,te,tr){var to=g?h:nU(h),tu=to.shape[0],tc=to.shape[1],tl=new n3(tu,tc,te),th=tl.getCustomSetupFunc(tr);return this.compileAndRun(tl,[to],"int32",th)},o.prototype.oneHot=function(h,g,te,tr){var to=new Ki(h.size,g,te,tr);return this.compileAndRun(to,[h])},o.prototype.diag=function(h){var g=new si(h.size);return this.compileAndRun(g,[h])},o.prototype.nonMaxSuppression=function(h,g,te,tr,to){return dn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"),jo(h.dataSync(),g.dataSync(),te,tr,to)},o.prototype.cropAndResize=function(h,g,te,tr,to,tu){var tc=new ei(h.shape,g.shape,tr,to,tu);return this.compileAndRun(tc,[h,g,te],"float32")},o.prototype.depthToSpace=function(h,g,te){C(g>1,function(){return"blockSize should be > 1 for depthToSpace, but was: "+g});var tr=h.shape[0],to="NHWC"===te?h.shape[1]:h.shape[2],tu="NHWC"===te?h.shape[2]:h.shape[3],tc="NHWC"===te?h.shape[3]:h.shape[1],tl=to*g,th=tu*g,td=tc/(g*g),tf=new nZ("NHWC"===te?[tr,tl,th,td]:[tr,td,tl,th],g,te);return this.compileAndRun(tf,[h])},o.prototype.split=function(h,g,te){return Zo(h,g,te)},o.prototype.scatterND=function(h,g,te){var tr=Zr(0,h,te),to=tr.sliceRank,tu=tr.numUpdates,tc=tr.sliceSize,tl=tr.strides,th=tr.outputSize,td=[th/tc,tc],tf=h.reshape([tu,to]),tp=g.reshape([tu,tc]);if(0===th)return Lo(Fn([]),te);var tv=On(0),tm=new ss(tu,to,tf.rank,tp.rank,tl,td);return this.compileAndRun(tm,[tp,tf,tv]).reshape(te)},o.prototype.sparseToDense=function(h,g,te,tr){var to=Zr(0,h,te),tu=to.sliceRank,tc=to.numUpdates,tl=to.strides,th=to.outputSize,td=new ss(tc,tu,h.rank,g.rank,tl,[th,1],!1);return this.compileAndRun(td,[g,h,tr]).reshape(te)},o.prototype.fft=function(h){return this.fftImpl(h,!1)},o.prototype.ifft=function(h){return this.fftImpl(h,!0)},o.prototype.fftImpl=function(h,g){var te=this.texData.get(h.dataId),tr=new pi("return real * expR - imag * expI;",h.shape,g),to=new pi("return real * expI + imag * expR;",h.shape,g),tu=[this.makeComplexComponentTensorInfo(h,te.complexTensors.real),this.makeComplexComponentTensorInfo(h,te.complexTensors.imag)],tc=this.compileAndRun(tr,tu),tl=this.compileAndRun(to,tu),th=this.complex(tc,tl).as2D(h.shape[0],h.shape[1]);return tc.dispose(),tl.dispose(),th},o.prototype.gatherND=function(h,g){var te=g.shape,tr=te[te.length-1],to=jr(h,g),tu=to[0],tc=to[1],tl=to[2],th=to[3],td=g.reshape([tc,tr]),tf=h.reshape([h.size/tl,tl]),tp=new gi(tr,th,[tc,tl]);return this.compileAndRun(tp,[tf,td]).reshape(tu)},o.prototype.fill=function(h,g,te){if("string"===(te=te||j(g))){var tr=P(te,k(h));return tr.fill(g),tM.makeTensor(tr,h,te,this)}var to=new n0(h,g),tu=to.getCustomSetupFunc(g);return this.compileAndRun(to,[],te,tu)},o.prototype.onesLike=function(h){if("string"===h.dtype)throw Error("onesLike is not supported under string dtype");return this.fill(h.shape,1,h.dtype)},o.prototype.zerosLike=function(h){return this.fill(h.shape,"string"===h.dtype?"":0,h.dtype)},o.prototype.linspace=function(h,g,te){return Wo(h,g,te)},o.prototype.makeTensorInfo=function(h,g){var te=this.write(null,h,g);return this.texData.get(te).usage=null,{dataId:te,shape:h,dtype:g}},o.prototype.makeOutput=function(h,g){var te=this.makeTensorInfo(h,g).dataId;return tM.makeTensorFromDataId(te,h,g,this)},o.prototype.unpackTensor=function(h){var g=new Ys(h.shape);return this.runWebGLProgram(g,[h],h.dtype)},o.prototype.packTensor=function(h){var g=new ji(h.shape);return this.runWebGLProgram(g,[h],h.dtype,null,!0)},o.prototype.packedReshape=function(h,g){var te=[Ae(h.shape)].concat(De(h.shape)),tr={dtype:h.dtype,shape:te,dataId:h.dataId},to=[Ae(g)].concat(De(g)),tu=new Zi(to,te),tc=this.runWebGLProgram(tu,[tr],h.dtype,null,!0);return{dataId:tc.dataId,shape:g,dtype:tc.dtype}},o.prototype.decode=function(h){var g,te=this.texData.get(h),tr=te.isPacked,to=te.shape,tu=te.dtype,tc=Te(to);return g=tr?new ai(tc):new oi(tc),{dtype:tu,shape:to,dataId:this.runWebGLProgram(g,[{shape:tc,dtype:tu,dataId:h}],tu,null,!0).dataId}},o.prototype.runWebGLProgram=function(h,g,te,tr,to){var tu,tc,th,td=this;void 0===to&&(to=!1);var tf=this.makeTensorInfo(h.outputShape,te),tp=this.texData.get(tf.dataId);if(h.packedOutput&&(tp.isPacked=!0),h.outPackingScheme===tP.DENSE){var tv=Yt(h.outputShape);tp.texShape=tv.map(function(h){return 2*h})}if(null!=h.outTexUsage&&(tp.usage=h.outTexUsage),0===k(tf.shape))return tp.values=B(tf.dtype,0),tf;var tm=[],tg=g.map(function(g){if("complex64"===g.dtype)throw Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");var te=td.texData.get(g.dataId);if(null==te.texture){if(!h.packedInputs&&k(g.shape)<=tl.getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:g.shape,texData:null,isUniform:!0,uniformValues:te.values};h.packedInputs&&(te.isPacked=!0,te.shape=g.shape)}else if(!!te.isPacked!=!!h.packedInputs)g=te.isPacked?td.unpackTensor(g):td.packTensor(g),tm.push(g),te=td.texData.get(g.dataId);else if(te.isPacked&&!_e(te.shape,g.shape)){var tr=g,to=g.shape;g.shape=te.shape,g=td.packedReshape(g,to),tm.push(g),te=td.texData.get(g.dataId),tr.shape=to}return td.uploadToGPU(g.dataId),{shape:g.shape,texData:te,isUniform:!1}});this.uploadToGPU(tf.dataId);var ty,tx={shape:tf.shape,texData:tp,isUniform:!1},tb=function(h,g,te){var tr="";g.concat(te).forEach(function(h){var g=null!=h.texData&&null!=h.texData.slice&&h.texData.slice.flatOffset>0,te=h.isUniform?"uniform":h.texData.texShape;tr+=h.shape+"_"+te+"_"+g});var to=h.userCode;return h.constructor.name+("_"+tr)+"_"+to}(h,tg,tx),tC=this.getAndSaveBinary(tb,function(){return function(h,g,te,tr){var to=g.userCode,tu=te.map(function(h,te){var tr={logicalShape:h.shape,texShape:h.isUniform?null:h.texData.texShape,isUniform:h.isUniform,isPacked:!h.isUniform&&h.texData.isPacked,flatOffset:null};return null!=h.texData&&null!=h.texData.slice&&h.texData.slice.flatOffset>0&&(tr.flatOffset=h.texData.slice.flatOffset),{name:g.variableNames[te],shapeInfo:tr}}),tc=tu.map(function(h){return h.shapeInfo}),th={logicalShape:tr.shape,texShape:tr.texData.texShape,isUniform:!1,isPacked:tr.texData.isPacked,flatOffset:null},td=function(h,g,te,tr){var to=[];h.forEach(function(h){var g=k(h.shapeInfo.logicalShape);h.shapeInfo.isUniform?to.push("uniform float "+h.name+(g>1?"["+g+"]":"")+";"):(to.push("uniform sampler2D "+h.name+";"),to.push("uniform int offset"+h.name+";"))});var tu,tc,tl=to.join("\n"),th=h.map(function(h){var te,to,tu,tc;return void 0===(te=tr)&&(te=!1),to=""+(te?function pa(h){var g,te,tr,to;switch(h.shapeInfo.logicalShape.length){case 0:return"\n    vec4 get"+(g=h.name).charAt(0).toUpperCase()+g.slice(1)+"() {\n      return "+ua().texture2D+"("+g+", halfCR);\n    }\n  ";case 1:return"\n    vec4 get"+(te=h.name).charAt(0).toUpperCase()+te.slice(1)+"(int index) {\n      vec2 uv = packedUVfrom1D(\n        "+(to=[Math.ceil((tr=h.shapeInfo.texShape)[0]/2),Math.ceil(tr[1]/2)])[0]+", "+to[1]+", index);\n      return "+ua().texture2D+"("+te+", uv);\n    }\n  ";case 2:return function(h){var g=h.shapeInfo.logicalShape,te=h.name,tr="get"+te.charAt(0).toUpperCase()+te.slice(1),to=h.shapeInfo.texShape,tu=to[0],tc=to[1],tl=ua();if(null!=to&&S(g,to))return"\n      vec4 "+tr+"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2("+tc+".0, "+tu+".0);\n\n        return "+tl.texture2D+"("+te+", uv);\n      }\n    ";var th=[Math.ceil(to[0]/2),Math.ceil(to[1]/2)];return"\n    vec4 "+tr+"(int row, int col) {\n      vec2 uv = packedUVfrom2D("+Math.ceil(g[1]/2)+", "+th[0]+", "+th[1]+", row, col);\n      return "+tl.texture2D+"("+te+", uv);\n    }\n  "}(h);case 3:return function(h){var g=h.shapeInfo.logicalShape,te=h.name,tr="get"+te.charAt(0).toUpperCase()+te.slice(1),to=h.shapeInfo.texShape,tu=[Math.ceil(to[0]/2),Math.ceil(to[1]/2)];if(1===g[0])return"\n        "+pa(Ca(h,g.slice(1)))+"\n        vec4 "+tr+"(int b, int row, int col) {\n          return "+tr+"("+Ea(["b","row","col"],[1,2])+");\n        }\n      ";var tc=tu[0],tl=tu[1],th=Math.ceil(g[2]/2);return"\n    vec4 "+tr+"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        "+tc+", "+tl+", "+th*Math.ceil(g[1]/2)+", "+th+", b, row, col);\n      return "+ua().texture2D+"("+te+", uv);\n    }\n  "}(h);default:return function(h){for(var g=h.shapeInfo.logicalShape,te=g.length,tr=h.name,to="get"+tr.charAt(0).toUpperCase()+tr.slice(1),tu=h.shapeInfo.texShape,tc=[Math.ceil(tu[0]/2),Math.ceil(tu[1]/2)],tl=tc[0],th=tc[1],td=Math.ceil(g[te-1]/2),tf=td*Math.ceil(g[te-2]/2),tp="int b, int row, int col",tv="b * "+tf+" + (row / 2) * "+td+" + (col / 2)",tm=2;tm<te-1;tm++)tp="int b"+tm+", "+tp,tf*=g[te-tm-1],tv="b"+tm+" * "+tf+" + "+tv;return"\n    vec4 "+to+"("+tp+") {\n      int index = "+tv+";\n      int texR = index / "+th+";\n      int texC = index - texR * "+th+";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+th+", "+tl+");\n      return "+ua().texture2D+"("+tr+", uv);\n    }\n  "}(h)}}(h):function da(h){var g=h.shapeInfo.logicalShape;switch(g.length){case 0:return function(h){var g=h.name,te="get"+g.charAt(0).toUpperCase()+g.slice(1);if(h.shapeInfo.isUniform)return"float "+te+"() {return "+g+";}";var tr=h.shapeInfo.texShape,to=tr[0],tu=tr[1];if(1===to&&1===tu)return"\n      float "+te+"() {\n        return sampleTexture("+g+", halfCR);\n      }\n    ";var tc=h.shapeInfo.texShape;return"\n    float "+te+"() {\n      vec2 uv = uvFromFlat("+tc[0]+", "+tc[1]+", "+xa(g)+");\n      return sampleTexture("+g+", uv);\n    }\n  "}(h);case 1:return function(h){var g=h.name,te="get"+g.charAt(0).toUpperCase()+g.slice(1);if(h.shapeInfo.isUniform)return"\n      float "+te+"(int index) {\n        "+ba(h)+"\n      }\n    ";var tr=h.shapeInfo.texShape,to=tr[0],tu=tr[1];if(1===tu&&1===to)return"\n      float "+te+"(int index) {\n        return sampleTexture("+g+", halfCR);\n      }\n    ";var tc=xa(g);return 1===tu?"\n      float "+te+"(int index) {\n        vec2 uv = vec2(0.5, (float(index + "+tc+") + 0.5) / "+to+".0);\n        return sampleTexture("+g+", uv);\n      }\n    ":1===to?"\n      float "+te+"(int index) {\n        vec2 uv = vec2((float(index + "+tc+") + 0.5) / "+tu+".0, 0.5);\n        return sampleTexture("+g+", uv);\n      }\n    ":"\n    float "+te+"(int index) {\n      vec2 uv = uvFromFlat("+to+", "+tu+", index + "+tc+");\n      return sampleTexture("+g+", uv);\n    }\n  "}(h);case 2:return function(h){var g=h.shapeInfo.logicalShape,te=h.name,tr="get"+te.charAt(0).toUpperCase()+te.slice(1),to=h.shapeInfo.texShape;if(null!=to&&S(g,to)){var tu=to[0];return"\n    float "+tr+"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2("+to[1]+".0, "+tu+".0);\n      return sampleTexture("+te+", uv);\n    }\n  "}var tc=M(g),tl=tc.newShape,th=tc.keptDims;if(tl.length<g.length)return"\n      "+da(Ca(h,tl))+"\n      float "+tr+"(int row, int col) {\n        return "+tr+"("+Ea(["row","col"],th)+");\n      }\n    ";if(h.shapeInfo.isUniform)return"\n      float "+tr+"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2("+g[1]+", 1)));\n        "+ba(h)+"\n      }\n    ";var td=to[0],tf=to[1],tp=xa(te);return 1===tf?"\n    float "+tr+"(int row, int col) {\n      float index = dot(vec3(row, col, "+tp+"), vec3("+g[1]+", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / "+td+".0);\n      return sampleTexture("+te+", uv);\n    }\n  ":1===td?"\n    float "+tr+"(int row, int col) {\n      float index = dot(vec3(row, col, "+tp+"), vec3("+g[1]+", 1, 1));\n      vec2 uv = vec2((index + 0.5) / "+tf+".0, 0.5);\n      return sampleTexture("+te+", uv);\n    }\n  ":"\n  float "+tr+"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * "+g[1]+" + col + "+tp+";\n    vec2 uv = uvFromFlat("+td+", "+tf+", index);\n    return sampleTexture("+te+", uv);\n  }\n"}(h);case 3:return function(h){var g=h.shapeInfo.logicalShape,te=h.name,tr="get"+te.charAt(0).toUpperCase()+te.slice(1),to=g[1]*g[2],tu=g[2],tc=M(g),tl=tc.newShape,th=tc.keptDims;if(tl.length<g.length)return"\n        "+da(Ca(h,tl))+"\n        float "+tr+"(int row, int col, int depth) {\n          return "+tr+"("+Ea(["row","col","depth"],th)+");\n        }\n      ";if(h.shapeInfo.isUniform)return"\n      float "+tr+"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3("+to+", "+tu+", 1)));\n        "+ba(h)+"\n      }\n    ";var td=h.shapeInfo.texShape,tf=td[0],tp=td[1],tv=h.shapeInfo.flatOffset;return tp===to&&null==tv?"\n        float "+tr+"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2("+tu+", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2("+tp+".0, "+tf+".0);\n          return sampleTexture("+te+", uv);\n        }\n      ":tp===tu&&null==tv?"\n    float "+tr+"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2("+g[1]+", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+tp+".0, "+tf+".0);\n      return sampleTexture("+te+", uv);\n    }\n  ":"\n      float "+tr+"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * "+to+" + col * "+tu+" + depth + "+xa(te)+";\n        vec2 uv = uvFromFlat("+tf+", "+tp+", index);\n        return sampleTexture("+te+", uv);\n      }\n  "}(h);case 4:return function(h){var g=h.shapeInfo.logicalShape,te=h.name,tr="get"+te.charAt(0).toUpperCase()+te.slice(1),to=g[3],tu=g[2]*to,tc=g[1]*tu,tl=M(g),th=tl.newShape,td=tl.keptDims;if(th.length<g.length)return"\n      "+da(Ca(h,th))+"\n      float "+tr+"(int row, int col, int depth, int depth2) {\n        return "+tr+"("+Ea(["row","col","depth","depth2"],td)+");\n      }\n    ";if(h.shapeInfo.isUniform)return"\n      float "+tr+"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4("+tc+", "+tu+", "+to+", 1)));\n        "+ba(h)+"\n      }\n    ";var tf=h.shapeInfo.flatOffset,tp=h.shapeInfo.texShape,tv=tp[0],tm=tp[1];return tm===tc&&null==tf?"\n      float "+tr+"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3("+tu+", "+to+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+tm+".0, "+tv+".0);\n        return sampleTexture("+te+", uv);\n      }\n    ":tm===to&&null==tf?"\n      float "+tr+"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3("+g[1]*g[2]+", "+g[2]+", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+tm+".0, "+tv+".0);\n        return sampleTexture("+te+", uv);\n      }\n    ":"\n    float "+tr+"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+tc+" + col * "+tu+" +\n          depth * "+to+" + depth2;\n      vec2 uv = uvFromFlat("+tv+", "+tm+", index + "+xa(te)+");\n      return sampleTexture("+te+", uv);\n    }\n  "}(h);case 5:return function(h){var g=h.shapeInfo.logicalShape,te=h.name,tr="get"+te.charAt(0).toUpperCase()+te.slice(1),to=g[4],tu=g[3]*to,tc=g[2]*tu,tl=g[1]*tc,th=M(g),td=th.newShape,tf=th.keptDims;if(td.length<g.length)return"\n      "+da(Ca(h,td))+"\n      float "+tr+"(int row, int col, int depth, int depth2, int depth3) {\n        return "+tr+"("+Ea(["row","col","depth","depth2","depth3"],tf)+");\n      }\n    ";if(h.shapeInfo.isUniform)return"\n      float "+tr+"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+tl+", "+tc+", "+tu+", "+to+")) +\n          depth3;\n        "+ba(h)+"\n      }\n    ";var tp=h.shapeInfo.flatOffset,tv=h.shapeInfo.texShape,tm=tv[0],tg=tv[1];return tg===tl&&null==tp?"\n      float "+tr+"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4("+tc+", "+tu+", "+to+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+tg+".0, "+tm+".0);\n        return sampleTexture("+te+", uv);\n      }\n    ":tg===to&&null==tp?"\n      float "+tr+"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+g[1]*g[2]*g[3]+",\n               "+g[2]*g[3]+", "+g[3]+", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+tg+".0, "+tm+".0);\n        return sampleTexture("+te+", uv);\n      }\n    ":"\n    float "+tr+"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+tl+" + col * "+tc+" + depth * "+tu+" +\n          depth2 * "+to+" + depth3 + "+xa(te)+";\n      vec2 uv = uvFromFlat("+tm+", "+tg+", index);\n      return sampleTexture("+te+", uv);\n    }\n  "}(h);case 6:return function(h){var g=h.shapeInfo.logicalShape,te=h.name,tr="get"+te.charAt(0).toUpperCase()+te.slice(1),to=M(g),tu=to.newShape,tc=to.keptDims;if(tu.length<g.length)return"\n      "+da(Ca(h,tu))+"\n      float "+tr+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return "+tr+"("+Ea(["row","col","depth","depth2","depth3","depth4"],tc)+");\n      }\n    ";var tl=g[5],th=g[4]*tl,td=g[3]*th,tf=g[2]*td,tp=g[1]*tf;if(h.shapeInfo.isUniform)return"\n      float "+tr+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4("+tp+", "+tf+", "+td+", "+th+")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2("+tl+", 1)));\n        "+ba(h)+"\n      }\n    ";var tv=h.shapeInfo.flatOffset,tm=h.shapeInfo.texShape,tg=tm[0],ty=tm[1];return ty===tp&&null==tv?"\n      float "+tr+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4("+tf+", "+td+", "+th+", "+tl+")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+ty+".0, "+tg+".0);\n        return sampleTexture("+te+", uv);\n      }\n    ":ty===tl&&null==tv?"\n      float "+tr+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4("+g[1]*g[2]*g[3]*g[4]+",\n               "+g[2]*g[3]*g[4]+",\n               "+g[3]*g[4]+",\n               "+g[4]+")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+ty+".0, "+tg+".0);\n        return sampleTexture("+te+", uv);\n      }\n    ":"\n    float "+tr+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+tp+" + col * "+tf+" + depth * "+td+" +\n          depth2 * "+th+" + depth3 * "+tl+" + depth4 + "+xa(te)+";\n      vec2 uv = uvFromFlat("+tg+", "+ty+", index);\n      return sampleTexture("+te+", uv);\n    }\n  "}(h);default:throw Error(g.length+"-D input sampling is not yet supported")}}(h)),tu=h.shapeInfo.logicalShape,tc=g.logicalShape,tu.length<=tc.length&&(to+=te?function(h,g){var te,tr=h.name,to=tr.charAt(0).toUpperCase()+tr.slice(1),tu=h.shapeInfo.logicalShape.length,tc=g.logicalShape.length,tl=Co(h.shapeInfo.logicalShape,g.logicalShape),th=wa(tc),td=tc-tu,tf=["x","y","z","w","u","v"];te=0===tu?"":tc<2&&tl.length>=1?"coords = 0;":tl.map(function(h){return"coords."+tf[h+td]+" = 0;"}).join("\n");var tp="";tp=tc<2&&tu>0?"coords":h.shapeInfo.logicalShape.map(function(h,g){return"coords."+tf[g+td]}).join(", ");var tv="return outputValue;",tm=1===k(h.shapeInfo.logicalShape),tg=1===k(g.logicalShape);if(1!==tu||tm||tg){if(tm&&!tg)tv=1===tc?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(tl.length){var ty=tu-2,tx=tu-1;tl.indexOf(ty)>-1&&tl.indexOf(tx)>-1?tv="return vec4(outputValue.x);":tl.indexOf(ty)>-1?tv="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":tl.indexOf(tx)>-1&&(tv="return vec4(outputValue.xx, outputValue.zz);")}}else tv="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 get"+to+"AtOutCoords() {\n      "+th+" coords = getOutputCoords();\n      "+te+"\n      vec4 outputValue = get"+to+"("+tp+");\n      "+tv+"\n    }\n  "}(h,g):function(h,g){var te=h.name,tr=te.charAt(0).toUpperCase()+te.slice(1),to="get"+tr+"AtOutCoords",tu=g.texShape,tc=h.shapeInfo.texShape,tl=h.shapeInfo.logicalShape.length,th=g.logicalShape.length;if(!h.shapeInfo.isUniform&&tl===th&&null==h.shapeInfo.flatOffset&&S(tc,tu))return"\n      float "+to+"() {\n        return sampleTexture("+te+", resultUV);\n      }\n    ";var td,tf=wa(th),tp=Co(h.shapeInfo.logicalShape,g.logicalShape),tv=th-tl,tm=["x","y","z","w","u","v"];return td=0===tl?"":th<2&&tp.length>=1?"coords = 0;":tp.map(function(h){return"coords."+tm[h+tv]+" = 0;"}).join("\n"),"\n    float "+to+"() {\n      "+tf+" coords = getOutputCoords();\n      "+td+"\n      return get"+tr+"("+(th<2&&tl>0?"coords":h.shapeInfo.logicalShape.map(function(h,g){return"coords."+tm[g+tv]}).join(", "))+");\n    }\n  "}(h,g)),to}).join("\n"),td=g.texShape,tf=ua(),tp="\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return "+tf.texture2D+"(textureSampler, uv).r;\n    }\n  ",tv=tf.version+"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    "+tf.varyingFs+" vec2 resultUV;\n    "+tf.defineOutput+"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    "+tf.defineSpecialNaN+"\n    "+tf.defineSpecialInf+"\n    "+tf.defineRound+"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    \nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n\n    \nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n\n    \nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n\n  ";return g.isPacked?(tu=function(h,g){var te,tr,to,tu;switch(h.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return 1===(tu=[Math.ceil(g[0]/2),Math.ceil(g[1]/2)])[0]?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * "+tu[1]+".0);\n      }\n    ":1===tu[1]?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * "+tu[0]+".0);\n      }\n    ":"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+tu[0]+", "+tu[1]+"));\n      return 2 * (resTexRC.x * "+tu[1]+" + resTexRC.y);\n    }\n  ";case 2:return function(h,g){var te=[Math.ceil(g[0]/2),Math.ceil(g[1]/2)];if(S(h,g))return"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2("+te[0]+", "+te[1]+"));\n      }\n    ";var tr=Math.ceil(h[1]/2);return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+te[0]+", "+te[1]+"));\n\n      int index = resTexRC.x * "+te[1]+" + resTexRC.y;\n      int r = 2 * (index / "+tr+");\n      int c = imod(index, "+tr+") * 2;\n\n      return ivec2(r, c);\n    }\n  "}(h,g);case 3:return te=[Math.ceil(g[0]/2),Math.ceil(g[1]/2)],to=(tr=Math.ceil(h[2]/2))*Math.ceil(h[1]/2),"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+te[0]+", "+te[1]+"));\n      int index = resTexRC.x * "+te[1]+" + resTexRC.y;\n\n      int b = index / "+to+";\n      index -= b * "+to+";\n\n      int r = 2 * (index / "+tr+");\n      int c = imod(index, "+tr+") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";default:return function(h,g){for(var te=[Math.ceil(g[0]/2),Math.ceil(g[1]/2)],tr=Math.ceil(h[h.length-1]/2),to=tr*Math.ceil(h[h.length-2]/2),tu=to,tc="",tl="b, r, c",th=2;th<h.length-1;th++)tu*=h[h.length-th-1],tc="\n      int b"+th+" = index / "+tu+";\n      index -= b"+th+" * "+tu+";\n    "+tc,tl="b"+th+", "+tl;return"\n    ivec"+h.length+" getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+te[0]+", "+te[1]+"));\n      int index = resTexRC.x * "+te[1]+" + resTexRC.y;\n\n      "+tc+"\n\n      int b = index / "+to+";\n      index -= b * "+to+";\n\n      int r = 2 * (index / "+tr+");\n      int c = imod(index, "+tr+") * 2;\n\n      return ivec"+h.length+"("+tl+");\n    }\n  "}(h,g)}}(g.logicalShape,td),tc="\n    void setOutput(vec4 val) {\n      "+tf.output+" = val;\n    }\n  "):(tu=function(h,g){var te,tr,to,tu;switch(h.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return 1===g[0]?"\n      int getOutputCoords() {\n        return int(resultUV.x * "+g[1]+".0);\n      }\n    ":1===g[1]?"\n      int getOutputCoords() {\n        return int(resultUV.y * "+g[0]+".0);\n      }\n    ":"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+g[0]+", "+g[1]+"));\n      return resTexRC.x * "+g[1]+" + resTexRC.y;\n    }\n  ";case 2:return S(h,g)?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2("+g[0]+", "+g[1]+"));\n      }\n    ":1===h[1]?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+g[0]+", "+g[1]+"));\n        int index = resTexRC.x * "+g[1]+" + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":1===h[0]?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+g[0]+", "+g[1]+"));\n        int index = resTexRC.x * "+g[1]+" + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+g[0]+", "+g[1]+"));\n      int index = resTexRC.x * "+g[1]+" + resTexRC.y;\n      int r = index / "+h[1]+";\n      int c = index - r * "+h[1]+";\n      return ivec2(r, c);\n    }\n  ";case 3:return te=ca(["r","c","d"],h),"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+g[0]+", "+g[1]+"));\n      int index = resTexRC.x * "+g[1]+" + resTexRC.y;\n      "+te+"\n      return ivec3(r, c, d);\n    }\n  ";case 4:return tr=ca(["r","c","d","d2"],h),"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+g[0]+", "+g[1]+"));\n      int index = resTexRC.x * "+g[1]+" + resTexRC.y;\n      "+tr+"\n      return ivec4(r, c, d, d2);\n    }\n  ";case 5:return to=ca(["r","c","d","d2","d3"],h),"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2("+g[0]+",\n                             "+g[1]+"));\n\n      int index = resTexRC.x * "+g[1]+" + resTexRC.y;\n\n      "+to+"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ";case 6:return tu=ca(["r","c","d","d2","d3","d4"],h),"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+g[0]+", "+g[1]+"));\n      int index = resTexRC.x * "+g[1]+" + resTexRC.y;\n\n      "+tu+"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ";default:throw Error(h.length+"-D output sampling is not yet supported")}}(g.logicalShape,td),tc="\n    void setOutput(float val) {\n      "+tf.output+" = vec4(val, 0, 0, 0);\n    }\n  "),tr&&(tv+="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n"),[tv,tp,tc,tl,tu,th,te].join("\n")}(tu,th,to,g.packedInputs),tf=h.createProgram(td),tp=null,tv=h.getUniformLocation(tf,"NAN",!1);1===tl.getNumber("WEBGL_VERSION")&&(tp=h.getUniformLocation(tf,"INFINITY",!1));for(var tm={},tg=0;tg<g.variableNames.length;tg++){var ty=g.variableNames[tg];tm[ty]=h.getUniformLocation(tf,ty,!1),tm["offset"+ty]=h.getUniformLocation(tf,"offset"+ty,!1)}return{program:g,source:td,webGLProgram:tf,uniformLocations:tm,inShapeInfos:tc,outShapeInfo:th,infLoc:tp,nanLoc:tv}}(td.gpgpu,h,tg,tx)}),tw=null!=this.activeTimers;if(tw&&(ty=this.startTimer()),tu=this.gpgpu,Pi(tC.inShapeInfos,tg),Pi([tC.outShapeInfo],[tx]),tc=tx.texData.texture,th=tx.texData.texShape,tx.texData.isPacked?tu.setOutputPackedMatrixTexture(tc,th[0],th[1]):tu.setOutputMatrixTexture(tc,th[0],th[1]),tu.setProgram(tC.webGLProgram),1===tl.getNumber("WEBGL_VERSION")&&null!==tC.infLoc&&tu.gl.uniform1f(tC.infLoc,1/0),null!==tC.nanLoc&&tu.gl.uniform1f(tC.nanLoc,NaN),tg.forEach(function(h,g){var te=tC.program.variableNames[g],tr=tC.uniformLocations[te],to=tC.uniformLocations["offset"+te];if(null!=tr){if(h.isUniform){if(2>k(h.shape))tu.gl.uniform1f(tr,h.uniformValues[0]);else{var tc=h.uniformValues;tc instanceof Float32Array||(tc=new Float32Array(tc)),tu.gl.uniform1fv(tr,tc)}}else null!=h.texData.slice&&null!=to&&tu.gl.uniform1i(to,h.texData.slice.flatOffset),tu.setInputMatrixTexture(h.texData.texture,tr,g)}}),null!=tr&&tr(tu,tC.webGLProgram),tu.executeProgram(),tm.forEach(function(h){return td.disposeData(h.dataId)}),tw&&(ty=this.endTimer(ty),this.activeTimers.push({name:h.constructor.name,query:this.getQueryTime(ty)})),!tl.getBool("WEBGL_LAZILY_UNPACK")&&tp.isPacked&&!1===to){var tE=this.unpackTensor(tf);return this.disposeData(tf.dataId),tE}return tf},o.prototype.compileAndRun=function(h,g,te,tr,to){void 0===to&&(to=!1),te=te||g[0].dtype;var tu=this.runWebGLProgram(h,g,te,tr,to);return tM.makeTensorFromDataId(tu.dataId,tu.shape,tu.dtype)},o.prototype.getAndSaveBinary=function(h,g){return h in this.binaryCache||(this.binaryCache[h]=g()),this.binaryCache[h]},o.prototype.getTextureManager=function(){return this.textureManager},o.prototype.dispose=function(){var h=this;this.disposed||(tl.getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(function(g){h.gpgpu.deleteProgram(h.binaryCache[g].webGLProgram),delete h.binaryCache[g]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)},o.prototype.floatPrecision=function(){var h=this;return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Ze(function(){if(!tl.get("WEBGL_RENDER_FLOAT32_ENABLED")){var g=tl.getBool("DEBUG");tl.set("DEBUG",!1);var te=h.abs(On(1e-8)).dataSync()[0];if(tl.set("DEBUG",g),te>0)return 32}return 16})),this.floatPrecisionValue},o.prototype.epsilon=function(){return 32===this.floatPrecision()?1e-7:1e-4},o.prototype.uploadToGPU=function(h){var g,te=this.texData.get(h),tr=te.shape,to=te.dtype,tu=te.values,tc=te.texture,tl=te.usage,th=te.isPacked;if(null==tc){var td,tf=null!=this.activeTimers;tf&&(td=et());var tp=te.texShape;if(null==tp&&(tp=Ne(tr,th),te.texShape=tp),null!=tu){var tv=Te(tr),tm=void 0,tg=tp[1],ty=tp[0],tx=tu instanceof Uint8Array;th?(tg=(g=$t(tp[0],tp[1]))[0],ty=g[1],tm=new hi(tv,[ty,tg],tx)):tm=new li(tv,[ty,tg],tx);var tb=this.makeTensorInfo([ty,tg],to);this.texData.get(tb.dataId).usage=tx?tL.PIXELS:tL.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(tb.dataId),tg,ty,tu);var tC=this.runWebGLProgram(tm,[tb],to,null,!0),tw=this.texData.get(tC.dataId);te.texture=tw.texture,te.texShape=tw.texShape,te.isPacked=tw.isPacked,te.usage=tw.usage,this.disposeData(tb.dataId),this.texData.delete(tC.dataId),te.values=null,tf&&(this.uploadWaitMs+=et()-td)}else{var tE=this.acquireTexture(tp,tl,to,th);te.texture=tE}}},o.prototype.convertAndCacheOnCPU=function(h,g){var te=this.texData.get(h),tr=te.dtype;return this.releaseGPUData(h),null!=g&&(te.values=function(h,g){if("float32"===g||"complex64"===g)return h;if("int32"===g||"bool"===g){for(var te="int32"===g?new Int32Array(h.length):new Uint8Array(h.length),tr=0;tr<te.length;++tr)te[tr]=Math.round(h[tr]);return te}throw Error("Unknown dtype "+g)}(g,tr)),te.values},o.prototype.acquireTexture=function(h,g,te,tr){if(this.numBytesInGPU+=this.computeBytes(h,te),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){var to=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: "+to+" MB, most likely due to a memory leak")}return this.textureManager.acquireTexture(h,g,tr)},o.prototype.computeBytes=function(h,g){return h[0]*h[1]*z(g)},o}(nG);Wt()&&tM.registerBackend("webgl",function(){return new eS},2);var eD=An({square_:function(h){var g=mn(h,"x","square"),te=[g];return tM.runKernelFunc(function(h,te){return te([g]),h.square(g)},{x:g},null,"Square",{},te,[])}}),eN="SquaredDifference",eT=An({squaredDifference_:function(h,g){var te,tr=mn(h,"a","squaredDifference"),to=mn(g,"b","squaredDifference");tr=(te=Nt(tr,to))[0],to=te[1],Ro(tr.shape,to.shape);var tu={a:tr,b:to},tc=[tr,to];return tM.runKernelFunc(function(h,g){var te=h.squaredDifference(tr,to);return g([tr,to]),te},tu,function(h,g){var te=g[0],tr=g[1],to=On(2);return{a:function(){return h.mul(te.sub(tr).mul(to))},b:function(){return h.mul(tr.sub(te).mul(to))}}},eN,{},tc,[])}}),eF=An({abs_:function(h){var g=mn(h,"x","abs");return"complex64"===g.dtype?tM.runKernelFunc(function(h){return h.complexAbs(g)},{$x:g}):tM.runKernelFunc(function(h,te){var tr=h.abs(g);return te([g]),tr},{x:g},function(h,g){var te=g[0];return{x:function(){return h.mul(te.toFloat().step(-1))}}},"Abs")}}),eO=An({acos_:function(h){var g=mn(h,"x","acos");return tM.runKernelFunc(function(h,te){var tr=h.acos(g);return te([g]),tr},{$x:g},function(h,g){var te=g[0];return{$x:function(){return h.divStrict(On(1).sub(te.toFloat().square()).sqrt()).neg()}}})}}),e_=An({acosh_:function(h){var g=mn(h,"x","acosh");return tM.runKernelFunc(function(h,te){var tr=h.acosh(g);return te([g]),tr},{$x:g},function(h,g){var te=g[0];return{$x:function(){return h.divStrict(te.toFloat().square().sub(1).sqrt())}}})}}),eM=An({asin_:function(h){var g=mn(h,"x","asin");return tM.runKernelFunc(function(h,te){var tr=h.asin(g);return te([g]),tr},{$x:g},function(h,g){var te=g[0];return{$x:function(){return h.divStrict(On(1).sub(te.toFloat().square()).sqrt())}}})}}),eB=An({asinh_:function(h){var g=mn(h,"x","asinh");return tM.runKernelFunc(function(h,te){var tr=h.asinh(g);return te([g]),tr},{$x:g},function(h,g){var te=g[0];return{$x:function(){return h.divStrict(On(1).add(te.toFloat().square()).sqrt())}}})}}),eP=An({atan_:function(h){var g=mn(h,"x","atan");return tM.runKernelFunc(function(h,te){var tr=h.atan(g);return te([g]),tr},{$x:g},function(h,g){var te=g[0];return{$x:function(){return h.div(te.toFloat().square().add(1))}}})}}),eL=An({atanh_:function(h){var g=mn(h,"x","atanh");return tM.runKernelFunc(function(h,te){var tr=h.atanh(g);return te([g]),tr},{$x:g},function(h,g){var te=g[0];return{$x:function(){return h.div(On(1).sub(te.toFloat().square()))}}})}}),eW=An({ceil_:function(h){var g=mn(h,"x","ceil");return tM.runKernelFunc(function(h){return h.ceil(g)},{$x:g},function(h){return{$x:function(){return t0(h)}}})}}),eV=An({clipByValue_:function(h,g,te){var tr=mn(h,"x","clipByValue");C(g<=te,function(){return"Error in clip: min ("+g+") must be less than or equal to max ("+te+")."});var to=[tr];return tM.runKernelFunc(function(h,to){var tu=h.clip(tr,g,te);return to([tr]),tu},{x:tr},function(h,tr){var to=tr[0];return{x:function(){return h.where(to.greaterEqual(g).logicalAnd(to.lessEqual(te)),t0(h))}}},"ClipByValue",{min:g,max:te},to)}}),eU=An({cos_:function(h){var g=mn(h,"x","cos"),te=[g];return tM.runKernelFunc(function(h,te){var tr=h.cos(g);return te([g]),tr},{x:g},function(h,g){var te=g[0];return{x:function(){return te.toFloat().sin().neg().mul(h)}}},"Cos",{},te)}}),ez=An({cosh_:function(h){var g=mn(h,"x","cosh");return tM.runKernelFunc(function(h,te){var tr=h.cosh(g);return te([g]),tr},{$x:g},function(h,g){var te=g[0];return{$x:function(){return te.toFloat().sinh().mulStrict(h)}}})}}),eH=An({erf_:function(h){var g=mn(h,"x","erf");return C("int32"===g.dtype||"float32"===g.dtype,function(){return"Input dtype must be `int32` or `float32`."}),"int32"===g.dtype&&(g=g.toFloat()),tM.runKernelFunc(function(h,te){var tr=h.erf(g);return te([g]),tr},{$x:g},function(h,g){var te=g[0];return{$x:function(){return h.mul(te.square().neg().exp().mul(2/Math.sqrt(Math.PI)))}}})}}),eG=An({exp_:function(h){var g=mn(h,"x","exp");return tM.runKernelFunc(function(h,te){var tr=h.exp(g);return te([tr]),tr},{x:g},function(h,g){return{x:function(){return h.mulStrict(g[0])}}},"Exp",{},[],[!0])}}),eq=An({expm1_:function(h){var g=mn(h,"x","expm1");return tM.runKernelFunc(function(h,te){var tr=h.expm1(g);return te([g]),tr},{$x:g},function(h,g){var te=g[0];return{$x:function(){return h.mul(te.exp())}}})}}),eK=An({floor_:function(h){var g=mn(h,"x","floor");return tM.runKernelFunc(function(h){return h.floor(g)},{$x:g},function(h){return{$x:function(){return t0(h)}}})}}),ej=An({log_:function(h){var g=mn(h,"x","log"),te=[g];return tM.runKernelFunc(function(h,te){var tr=h.log(g);return te([g]),tr},{x:g},function(h,g){var te=g[0];return{x:function(){return h.div(te.toFloat())}}},"Log",{},te)}}),eX=An({log1p_:function(h){var g=mn(h,"x","log1p");return tM.runKernelFunc(function(h,te){var tr=h.log1p(g);return te([g]),tr},{$x:g},function(h,g){var te=g[0];return{$x:function(){return h.div(te.add(1))}}})}}),e$=An({logSigmoid_:function(h){var g=mn(h,"x","logSigmoid");return tM.runKernelFunc(function(h,te){var tr=h.softplus(g.neg()).neg();return te([g]),tr},{$x:g},function(h,g){var te=g[0];return{$x:function(){return h.mul(te.neg().sigmoid())}}})}}),eY=An({neg_:function(h){var g=mn(h,"x","neg"),te=[g];return tM.runKernelFunc(function(h){return h.neg(g)},{x:g},function(h){return{x:function(){return h.neg()}}},"Neg",{},te)}}),eJ=An({reciprocal_:function(h){var g=mn(h,"x","reciprocal");return tM.runKernelFunc(function(h,te){var tr=h.reciprocal(g);return te([g]),tr},{$x:g},function(h,g){var te=g[0];return{$x:function(){return h.div(te.square().neg())}}})}}),eQ=An({round_:function(h){var g=mn(h,"x","round");return tM.runKernelFunc(function(h){return h.round(g)},{$x:g},function(h){return{$x:function(){return t0(h)}}})}}),eZ=An({rsqrt_:function(h){var g=mn(h,"x","rsqrt"),te=[g];return tM.runKernelFunc(function(h,te){var tr=h.rsqrt(g);return te([g]),tr},{x:g},function(h,g){var te=g[0];return{x:function(){return h.div(te.pow(1.5).mul(2)).neg()}}},"Rsqrt",{},te)}}),e0=An({sigmoid_:function(h){var g=mn(h,"x","sigmoid");return tM.runKernelFunc(function(h,te){var tr=h.sigmoid(g);return te([tr]),tr},{x:g},function(h,g){var te=g[0];return{x:function(){return h.mul(te.mul(On(1).sub(te)))}}},"Sigmoid")}}),e1=An({sign_:function(h){var g=mn(h,"x","sign");return tM.runKernelFunc(function(h){return h.sign(g)},{$x:g},function(h){return{$x:function(){return t0(h)}}})}}),e2=An({isNaN_:function(h){var g=mn(h,"x","isNaN");return tM.runKernelFunc(function(h){return h.isNaN(g)},{$x:g},function(h){return{$x:function(){return t0(h)}}})}}),e3=An({isInf_:function(h){var g=mn(h,"x","isInf");return tM.runKernelFunc(function(h){return h.isInf(g)},{$x:g},function(h){return{$x:function(){return t0(h)}}})}}),e4=An({isFinite_:function(h){var g=mn(h,"x","isFinite");return tM.runKernelFunc(function(h){return h.isFinite(g)},{$x:g},function(h){return{$x:function(){return t0(h)}}})}}),e5=An({sin_:function(h){var g=mn(h,"x","sin"),te=[g];return tM.runKernelFunc(function(h,te){var tr=h.sin(g);return te([g]),tr},{x:g},function(h,g){var te=g[0];return{x:function(){return te.toFloat().cos().mul(h)}}},"Sin",{},te)}}),e6=An({sinh_:function(h){var g=mn(h,"x","sinh");return tM.runKernelFunc(function(h,te){var tr=h.sinh(g);return te([g]),tr},{$x:g},function(h,g){var te=g[0];return{$x:function(){return te.toFloat().cosh().mulStrict(h)}}})}}),e8=An({softplus_:function(h){var g=mn(h,"x","softplus");return tM.runKernelFunc(function(h,te){var tr=h.softplus(g);return te([g]),tr},{$x:g},function(h,g){var te=g[0];return{$x:function(){return h.mul(te.sigmoid())}}})}}),e7=An({sqrt_:function(h){var g=mn(h,"x","sqrt");return tM.runKernelFunc(function(h,te){var tr=h.sqrt(g);return te([g]),tr},{$x:g},function(h,g){var te=g[0];return{$x:function(){return h.div(te.toFloat().sqrt().mul(2))}}})}}),e9=An({step_:function(h,g){void 0===g&&(g=0);var te=mn(h,"x","step");return tM.runKernelFunc(function(h){return h.step(te,g)},{$x:te},function(h){return{$x:function(){return t0(h)}}})}}),rn=An({tan_:function(h){var g=mn(h,"x","tan");return tM.runKernelFunc(function(h,te){var tr=h.tan(g);return te([g]),tr},{$x:g},function(h,g){var te=g[0];return{$x:function(){return h.div(te.cos().square())}}})}}),rr=An({tanh_:function(h){var g=mn(h,"x","tanh");return tM.runKernelFunc(function(h,te){var tr=h.tanh(g);return te([tr]),tr},{x:g},function(h,g){var te=g[0];return{x:function(){return On(1).sub(te.square()).mulStrict(h)}}},"Tanh",{},null,[!0])}});function Pu(h,g,te,tr,to,tu){var tc,tl,th=mn(h,"x","batchNorm"),td=mn(g,"mean","batchNorm"),tf=mn(te,"variance","batchNorm");return null!=to&&(tc=mn(to,"scale","batchNorm")),null!=tr&&(tl=mn(tr,"offset","batchNorm")),C(2===th.rank,function(){return"Error in batchNorm3D: x must be rank 3 but got rank "+th.rank+"."}),C(2===td.rank||1===td.rank,function(){return"Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank "+td.rank+"."}),C(2===tf.rank||1===tf.rank,function(){return"Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank "+tf.rank+"."}),null!=tc&&C(2===tc.rank||1===tc.rank,function(){return"Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank "+tc.rank+"."}),null!=tl&&C(2===tl.rank||1===tl.rank,function(){return"Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank "+tl.rank+"."}),Uu(th,td,tf,tl,tc,tu)}function Lu(h,g,te,tr,to,tu){var tc,tl,th=mn(h,"x","batchNorm"),td=mn(g,"mean","batchNorm"),tf=mn(te,"variance","batchNorm");return null!=to&&(tc=mn(to,"scale","batchNorm")),null!=tr&&(tl=mn(tr,"offset","batchNorm")),C(3===th.rank,function(){return"Error in batchNorm3D: x must be rank 3 but got rank "+th.rank+"."}),C(3===td.rank||1===td.rank,function(){return"Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank "+td.rank+"."}),C(3===tf.rank||1===tf.rank,function(){return"Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank "+tf.rank+"."}),null!=tc&&C(3===tc.rank||1===tc.rank,function(){return"Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank "+tc.rank+"."}),null!=tl&&C(3===tl.rank||1===tl.rank,function(){return"Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank "+tl.rank+"."}),Uu(th,td,tf,tl,tc,tu)}function Wu(h,g,te,tr,to,tu){var tc,tl,th=mn(h,"x","batchNorm"),td=mn(g,"mean","batchNorm"),tf=mn(te,"variance","batchNorm");return null!=to&&(tc=mn(to,"scale","batchNorm")),null!=tr&&(tl=mn(tr,"offset","batchNorm")),C(4===th.rank,function(){return"Error in batchNorm4D: x must be rank 4 but got rank "+th.rank+"."}),C(4===td.rank||1===td.rank,function(){return"Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank "+td.rank+"."}),C(4===tf.rank||1===tf.rank,function(){return"Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank "+tf.rank+"."}),null!=tc&&C(4===tc.rank||1===tc.rank,function(){return"Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank "+tc.rank+"."}),null!=tl&&C(4===tl.rank||1===tl.rank,function(){return"Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank "+tl.rank+"."}),Uu(th,td,tf,tl,tc,tu)}function Uu(h,g,te,tr,to,tu){null==tu&&(tu=.001);var tc,tl,th,td=mn(h,"x","batchNorm"),tf=mn(g,"mean","batchNorm"),tp=mn(te,"variance","batchNorm");null!=to&&(tc=mn(to,"scale","batchNorm")),null!=tr&&(tl=mn(tr,"offset","batchNorm")),C(tf.rank===tp.rank,function(){return"Batch normalization gradient requires mean and variance to have equal ranks."}),C(null==tl||tf.rank===tl.rank,function(){return"Batch normalization gradient requires mean and offset to have equal ranks."}),C(null==tc||tf.rank===tc.rank,function(){return"Batch normalization gradient requires mean and scale to have equal ranks."}),th=0===td.rank||1===td.rank?td.as4D(1,1,1,td.size):2===td.rank?td.as4D(1,1,td.shape[0],td.shape[1]):3===td.rank?td.as4D(1,td.shape[0],td.shape[1],td.shape[2]):td;var tv=[td,tf,tp,tc];return tM.runKernelFunc(function(h,g){var te=h.batchNormalization(th,Vu(tf),Vu(tp),tu,Vu(tc),Vu(tl));return g([td,tf,tp,tc]),te},{x:td,mean:tf,variance:tp,scale:tc,offset:tl},function(h,g){var te=g[0],tr=g[1],to=g[2],tc=g[3],tl=null==tc?On(1):tc,td=Eo(tr.shape,th.shape),tf=[];if(1===tr.rank){for(var tp=0;tp<th.shape.length-1;++tp)tf.push(th.shape[tp]);tf.push(1)}var tv=te.sub(tr),tm=h.mul(tl),tg=eZ(to.add(On(tu))),ty=tg.mul(tg).mul(tg).mul(On(-.5));return{x:function(){return 1===tr.rank?h.mul(nL(tg.as4D(1,1,1,tr.shape[0]),tf)).mul(tl).reshape(te.shape):h.mul(tg).mul(tl).reshape(te.shape)},mean:function(){var h=tg.mul(On(-1)).mul(tm);return 1===tr.rank&&(h=h.sum(td)),h.reshape(tr.shape)},variance:function(){var h=ty.mul(tv).mul(tm);return 1===tr.rank&&(h=h.sum(td)),h.reshape(tr.shape)},scale:function(){var g=tv.mul(tg),te=h.mul(g);return 1===tr.rank&&(te=te.sum(td)),te.reshape(tr.shape)},offset:function(){var g=h;return 1===tr.rank&&(g=g.sum(td)),g.reshape(tr.shape)}}},"BatchNormalization",{varianceEpsilon:tu},tv).reshape(td.shape)}function Vu(h){return null==h?null:0===h.rank?h.as1D():1===h.rank?h:2===h.rank?h.as4D(1,1,h.shape[0],h.shape[1]):3===h.rank?h.as4D(1,h.shape[0],h.shape[1],h.shape[2]):h}function zu(){Xe("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon")}var ru=An({batchNormalization2d_:function(h,g,te,tr,to,tu){return void 0===tr&&(tr=.001),zu(),Pu(h,g,te,tu,to,tr)}}),rc=An({batchNormalization3d_:function(h,g,te,tr,to,tu){return void 0===tr&&(tr=.001),zu(),Lu(h,g,te,tu,to,tr)}}),rl=An({batchNormalization4d_:function(h,g,te,tr,to,tu){return void 0===tr&&(tr=.001),zu(),Wu(h,g,te,tu,to,tr)}}),rd=An({batchNormalization_:function(h,g,te,tr,to,tu){return void 0===tr&&(tr=.001),zu(),Uu(h,g,te,tu,to,tr)}}),rf=An({batchNorm_:Uu}),rp=An({batchNorm2d_:Pu}),rv=An({batchNorm3d_:Lu}),rm=An({batchNorm4d_:Wu}),rg=An({logicalAnd_:function(h,g){var te=mn(h,"a","logicalAnd","bool"),tr=mn(g,"b","logicalAnd","bool");return Ro(te.shape,tr.shape),tM.runKernelFunc(function(h){return h.logicalAnd(te,tr)},{a:te,b:tr},null,"LogicalAnd")}}),ry=An({logicalNot_:function(h){var g=mn(h,"x","logicalNot","bool");return tM.runKernelFunc(function(h){return h.logicalNot(g)},{$x:g})}}),rx=An({logicalOr_:function(h,g){var te=mn(h,"a","logicalOr","bool"),tr=mn(g,"b","logicalOr","bool");return Ro(te.shape,tr.shape),tM.runKernelFunc(function(h){return h.logicalOr(te,tr)},{$a:te,$b:tr})}}),rb=An({logicalXor_:function(h,g){var te=mn(h,"a","logicalXor","bool"),tr=mn(g,"b","logicalXor","bool");return Ro(te.shape,tr.shape),rx(h,g).logicalAnd(rg(h,g).logicalNot())}}),rC=An({where_:function(h,g,te){var tr=mn(g,"a","where"),to=mn(te,"b","where"),tu=mn(h,"condition","where","bool");return E(tr.shape,to.shape,"Error in where: "),1===tu.rank?C(tu.shape[0]===tr.shape[0],function(){return"The first dimension of `a` must match the size of `condition`."}):E(tu.shape,to.shape,"Error in where: "),tM.runKernelFunc(function(h,g){var te=h.select(tu,tr,to);return g([tu]),te},{$condition:tu,$a:tr,$b:to},function(h,g){var te=g[0];return{$condition:function(){return t0(te).toFloat()},$a:function(){return h.mul(te.cast(h.dtype))},$b:function(){return h.mul(te.logicalNot().cast(h.dtype))}}})}}),nc=function(h){return n(this,void 0,void 0,function(){var g,te,tr;return r(this,function(to){switch(to.label){case 0:return[4,(g=mn(h,"condition","whereAsync","bool")).data()];case 1:return te=to.sent(),tr=na(g.shape,te),h!==g&&g.dispose(),[2,tr]}})})},rw=An({add_:function(h,g){var te,tr=mn(h,"a","add"),to=mn(g,"b","add");tr=(te=Nt(tr,to))[0],to=te[1];var tu=Ro(tr.shape,to.shape);return tM.runKernelFunc(function(h){return h.add(tr,to)},{a:tr,b:to},function(h){return{a:function(){var g=h,te=Eo(tr.shape,tu);return te.length>0&&(g=g.sum(te)),g.reshape(tr.shape)},b:function(){var g=h,te=Eo(to.shape,tu);return te.length>0&&(g=g.sum(te)),g.reshape(to.shape)}}},"Add")}}),rE=An({addN_:function(h){C(Array.isArray(h),function(){return"The argument passed to tf.addN() must be a list of tensors"}),C(h.length>=1,function(){return"Must pass at least one tensor to tf.addN(), but got "+h.length});var g=h.map(function(h,g){return mn(h,"tensors"+g,"addN")}),te=g[0];return g.forEach(function(h){if(h.dtype!==te.dtype)throw Error("All tensors passed to tf.addN() must have the same dtype")}),g.forEach(function(h){if(!S(h.shape,te.shape))throw Error("All tensors passed to tf.addN() must have the same shape")}),tM.runKernelFunc(function(h){return h.addN(g)},g,function(h){var te={};return g.forEach(function(g,tr){te[tr]=function(){return h.clone()}}),te},"AddN")}}),rR=An({addStrict_:function(h,g){var te=mn(h,"a","addStrict"),tr=mn(g,"b","addStrict");return E(te.shape,tr.shape,"Error in addStrict: "),te.add(tr)}}),rI=An({atan2_:function(h,g){var te,tr=mn(h,"a","atan2"),to=mn(g,"b","atan2");tr=(te=Nt(tr,to))[0],to=te[1];var tu=Ro(tr.shape,to.shape);return tM.runKernelFunc(function(h,g){var te=h.atan2(tr,to);return g([tr,to]),te},{$a:tr,$b:to},function(h,g){var te=g[0],tr=g[1];return{$a:function(){var g=rw(te.square(),tr.square()),to=h.mul(tr.div(g)),tc=Eo(te.shape,tu);return tc.length>0&&(to=to.sum(tc)),to.reshape(te.shape)},$b:function(){var g=rw(te.square(),tr.square()),to=eY(h.mul(te.div(g))),tc=Eo(tr.shape,tu);return tc.length>0&&(to=to.sum(tc)),to.reshape(tr.shape)}}})}}),rk=An({div_:function(h,g){var te,tr=mn(h,"a","div"),to=mn(g,"b","div");if(tr=(te=Nt(tr,to))[0],to=te[1],"int32"===tr.dtype&&"int32"===to.dtype)return rD(tr,to);var tu=Ro(tr.shape,to.shape);return tM.runKernelFunc(function(h,g){var te=h.realDivide(tr,to);return g([tr,to]),te},{a:tr,b:to},function(h,g){var te=g[0],tr=g[1];return{a:function(){var g=h.div(tr.toFloat()),to=Eo(te.shape,tu);return to.length>0?g.sum(to).reshape(te.shape):g},b:function(){var g=h.mul(te.toFloat()),to=Eo(tr.shape,tu);to.length>0&&(g=g.sum(to).reshape(tr.shape));var tc=tr.square();return g.div(tc.toFloat()).neg()}}},"Div")}}),rA=An({divNoNan_:function(h,g){var te,tr=mn(h,"a","div"),to=mn(g,"b","div"),tu=rk(tr=(te=Nt(tr,to))[0],to=te[1]),tc=t0(tu);return rC(to.equal(tc),tc,tu)}}),rS=An({divStrict_:function(h,g){var te=mn(h,"a","div"),tr=mn(g,"b","div");return E(te.shape,tr.shape,"Error in divideStrict: "),te.div(tr)}}),rD=An({floorDiv_:function(h,g){var te,tr=mn(h,"a","floorDiv"),to=mn(g,"b","floorDiv");tr=(te=Nt(tr,to))[0],to=te[1];var tu=Ro(tr.shape,to.shape);return tM.runKernelFunc(function(h,g){var te=h.floorDiv(tr,to);return g([tr,to]),te},{a:tr,b:to},function(h,g){var te=g[0],tr=g[1];return{a:function(){var g=h.div(tr.toFloat()),to=Eo(te.shape,tu);return to.length>0?g.sum(to).reshape(te.shape):g},b:function(){var g=h.mul(te.toFloat()),to=Eo(tr.shape,tu);to.length>0&&(g=g.sum(to).reshape(tr.shape));var tc=tr.square();return g.div(tc.toFloat()).neg()}}},"FloorDiv")}}),rN=An({maximum_:function(h,g){var te,tr=mn(h,"a","maximum"),to=mn(g,"b","maximum");return tr=(te=Nt(tr,to))[0],to=te[1],"bool"===tr.dtype&&(tr=tr.toInt(),to=to.toInt()),Ro(tr.shape,to.shape),tM.runKernelFunc(function(h,g){var te=h.maximum(tr,to);return g([tr,to]),te},{a:tr,b:to},function(h,g){var te=g[0],tr=g[1];return{a:function(){return h.mul(te.greaterEqual(tr).toFloat())},b:function(){return h.mul(te.less(tr).toFloat())}}},"Maximum")}}),rT=An({maximumStrict_:function(h,g){var te=mn(h,"a","maximumStrict"),tr=mn(g,"b","maximumStrict");return E(te.shape,tr.shape,"Error in maximumStrict: "),te.maximum(tr)}}),rF=An({minimum_:function(h,g){var te,tr=mn(h,"a","minimum"),to=mn(g,"b","minimum");return tr=(te=Nt(tr,to))[0],to=te[1],"bool"===tr.dtype&&(tr=tr.toInt(),to=to.toInt()),Ro(tr.shape,to.shape),tM.runKernelFunc(function(h,g){var te=h.minimum(tr,to);return g([tr,to]),te},{a:tr,b:to},function(h,g){var te=g[0],tr=g[1];return{a:function(){return h.mul(te.lessEqual(tr).toFloat())},b:function(){return h.mul(te.greater(tr).toFloat())}}},"Minimum")}}),rO=An({minimumStrict_:function(h,g){var te=mn(h,"a","minimumStrict"),tr=mn(g,"b","minimumStrict");return E(te.shape,tr.shape,"Error in minimumStrict: "),te.minimum(tr)}}),r_=An({mod_:function(h,g){var te,tr=mn(h,"a","mod"),to=mn(g,"b","mod");tr=(te=Nt(tr,to))[0],to=te[1];var tu=Ro(tr.shape,to.shape);return tM.runKernelFunc(function(h,g){var te=h.mod(tr,to);return g([tr,to]),te},{$a:tr,$b:to},function(h,g){var te=g[0],tr=g[1];return{$a:function(){var g=Eo(te.shape,tu);return g.length>0?h.sum(g).reshape(te.shape):h},$b:function(){var g=h.mul(te.div(tr).floor().neg()),to=Eo(tr.shape,tu);return to.length>0?g.sum(to).reshape(tr.shape):g}}})}}),rM=An({modStrict_:function(h,g){var te=mn(h,"a","modStrict"),tr=mn(g,"b","modStrict");return E(te.shape,tr.shape,"Error in modStrict: "),te.mod(tr)}}),rB=An({mul_:function(h,g){var te,tr=mn(h,"a","mul"),to=mn(g,"b","mul");tr=(te=Nt(tr,to))[0],to=te[1];var tu=Ro(tr.shape,to.shape);return tM.runKernelFunc(function(h,g){var te=h.multiply(tr,to);return g([tr,to]),te},{a:tr,b:to},function(h,g){var te=g[0],tr=g[1];return{a:function(){var g=h.mul(tr.toFloat()),to=Eo(te.shape,tu);return to.length>0?g.sum(to).reshape(te.shape):g},b:function(){var g=h.mul(te.toFloat()),to=Eo(tr.shape,tu);return to.length>0?g.sum(to).reshape(tr.shape):g}}},"Mul")}}),rP=An({mulStrict_:function(h,g){var te=mn(h,"a","mul"),tr=mn(g,"b","mul");return E(te.shape,tr.shape,"Error in multiplyStrict: "),te.mul(tr)}}),rL=An({pow_:function(h,g){var te,tr=mn(h,"base","pow"),to=mn(g,"exp","pow");tr=(te=Nt(tr,to))[0],to=te[1];var tu=Ro(tr.shape,to.shape),tc=[tr,to];return tM.runKernelFunc(function(h,g){var te=h.pow(tr,to);return g([tr,to,te]),te},{a:tr,b:to},function(h,g){var te=g[0],tr=g[1],to=g[2];return{a:function(){var g=tr.toFloat(),to=h.mul(g.mul(te.pow(g.sub(On(1))))),tc=Eo(te.shape,tu);return tc.length>0&&(to=to.sum(tc)),to.reshape(te.shape)},b:function(){var g=te.greater(0),tc=te.log().where(g,t0(te)),tl=h.mul(to.mul(tc)),th=Eo(tr.shape,tu);return th.length>0&&(tl=tl.sum(th)),tl.reshape(tr.shape)}}},"Pow",{},tc,[!0])}}),rW=An({powStrict_:function(h,g){return E(h.shape,g.shape,"Error in powStrict: "),h.pow(g)}}),rV=An({squaredDifferenceStrict_:function(h,g){var te=mn(h,"a","squaredDifferenceStrict"),tr=mn(g,"b","squaredDifferenceStrict");return E(te.shape,tr.shape,"Error in squaredDifferenceStrict: "),te.squaredDifference(tr)}}),rU=An({sub_:function(h,g){var te,tr=mn(h,"a","sub"),to=mn(g,"b","sub");tr=(te=Nt(tr,to))[0],to=te[1];var tu=Ro(tr.shape,to.shape);return tM.runKernelFunc(function(h){return h.subtract(tr,to)},{a:tr,b:to},function(h){return{a:function(){var g=h,te=Eo(tr.shape,tu);return te.length>0&&(g=g.sum(te)),g.reshape(tr.shape)},b:function(){var g=h,te=Eo(to.shape,tu);return te.length>0&&(g=g.sum(te)),g.neg().reshape(to.shape)}}},"Sub")}}),rz=An({subStrict_:function(h,g){var te=mn(h,"a","subStrict"),tr=mn(g,"b","subStrict");return E(te.shape,tr.shape,"Error in subStrict: "),te.sub(tr)}}),rH=An({equal_:function(h,g){var te,tr=mn(h,"a","equal"),to=mn(g,"b","equal");return tr=(te=Nt(tr,to))[0],to=te[1],Ro(tr.shape,to.shape),tM.runKernelFunc(function(h){return h.equal(tr,to)},{$a:tr,$b:to})}}),rG=An({equalStrict_:function(h,g){var te=mn(h,"a","equalStrict"),tr=mn(g,"b","equalStrict");return E(te.shape,tr.shape,"Error in equalStrict: "),te.equal(tr)}}),rq=An({greater_:function(h,g){var te,tr=mn(h,"a","greater"),to=mn(g,"b","greater");return tr=(te=Nt(tr,to))[0],to=te[1],Ro(tr.shape,to.shape),tM.runKernelFunc(function(h){return h.greater(tr,to)},{a:tr,b:to},null,"Greater")}}),rK=An({greaterEqual_:function(h,g){var te,tr=mn(h,"a","greaterEqual"),to=mn(g,"b","greaterEqual");return tr=(te=Nt(tr,to))[0],to=te[1],Ro(tr.shape,to.shape),tM.runKernelFunc(function(h,g){var te=h.greaterEqual(tr,to);return g([tr,to]),te},{a:tr,b:to},function(h,g){var te=g[0],tr=g[1];return{a:function(){return t0(te)},b:function(){return t0(tr)}}},"GreaterEqual")}}),rj=An({greaterEqualStrict_:function(h,g){var te=mn(h,"a","greaterEqualStrict"),tr=mn(g,"b","greaterEqualStrict");return E(te.shape,tr.shape,"Error in greaterEqualStrict: "),te.greaterEqual(tr)}}),rX=An({greaterStrict_:function(h,g){var te=mn(h,"a","greaterStrict"),tr=mn(g,"b","greaterStrict");return E(te.shape,tr.shape,"Error in greaterStrict: "),te.greater(tr)}}),r$=An({less_:function(h,g){var te,tr=mn(h,"a","less"),to=mn(g,"b","less");return tr=(te=Nt(tr,to))[0],to=te[1],Ro(tr.shape,to.shape),tM.runKernelFunc(function(h){return h.less(tr,to)},{a:tr,b:to},null,"Less")}}),rY=An({lessEqual_:function(h,g){var te,tr=mn(h,"a","lessEqual"),to=mn(g,"b","lessEqual");return tr=(te=Nt(tr,to))[0],to=te[1],Ro(tr.shape,to.shape),tM.runKernelFunc(function(h,g){var te=h.lessEqual(tr,to);return g([tr,to]),te},{a:tr,b:to},null,"LessEqual")}}),rJ=An({lessEqualStrict_:function(h,g){var te=mn(h,"a","lessEqualStrict"),tr=mn(g,"b","lessEqualStrict");return E(te.shape,tr.shape,"Error in lessEqualStrict: "),te.lessEqual(tr)}}),rQ=An({lessStrict_:function(h,g){var te=mn(h,"a","lessStrict"),tr=mn(g,"b","lessStrict");return E(te.shape,tr.shape,"Error in lessStrict: "),te.less(tr)}}),rZ=An({notEqual_:function(h,g){var te,tr=mn(h,"a","notEqual"),to=mn(g,"b","notEqual");return tr=(te=Nt(tr,to))[0],to=te[1],Ro(tr.shape,to.shape),tM.runKernelFunc(function(h){return h.notEqual(tr,to)},{a:tr,b:to},null,"NotEqual")}}),r0=An({notEqualStrict_:function(h,g){var te=mn(h,"a","notEqualStrict"),tr=mn(g,"b","notEqualStrict");return E(te.shape,tr.shape,"Error in notEqualStrict: "),te.notEqual(tr)}});function Bc(h,g){for(var te=[],tr=h;tr<g;++tr)te.push(tr);return te}function Pc(h){for(var g=[],te=0;te<h.length;++te)for(var tr=0;tr<h[te].length;++tr)g.push(h[te][tr]);return g}var r1=An({gather_:function(h,g,te){void 0===te&&(te=0);var tr=mn(h,"x","gather"),to=mn(g,"indices","gather","int32");te=O(te,tr.shape)[0];var tu=function(h,g,te){for(var tr=h.shape[te],to=[],tu=1,tc=1,tl=0;tl<te;tl++)to.push(h.shape[tl]),tu*=h.shape[tl];for(tl=0;tl<g.rank;tl++)to.push(g.shape[tl]);for(tl=te+1;tl<h.rank;tl++)to.push(h.shape[tl]),tc*=h.shape[tl];return{batchSize:tu,sliceSize:tc,dimSize:tr,outputShape:to}}(tr,to,te);return tM.runKernelFunc(function(h,g){var tu=h.gather(tr,to.flatten(),te);return g([to]),tu},{x:tr,indices:to},function(h,g){var to=g[0];return{x:function(){var g=tr.shape,tu=to.size,tc=g.slice(0,te),tl=tc.length,th=g.slice(te,g.length).slice(1),td=th.length,tf=Bc(0,tl),tp=Bc(tl+1,tl+1+td),tv=Pc([tc,[tu],th]),tm=h.reshape(tv),tg=to.reshape([tu]),ty=Pc([[tl],tf,tp]),tx=r2(tm.transpose(ty),tg,tr.shape[te]),tb=Rn(ty);return tx.transpose(tb)},indices:function(){return to}}},"Gather",{axis:te}).reshape(tu.outputShape)}}),r2=An({unsortedSegmentSum_:function(h,g,te){var tr=mn(h,"x","unsortedSegmentSum"),to=mn(g,"segmentIds","unsortedSegmentSum","int32");return C(A(te),function(){return"numSegments must be of dtype int"}),tM.runKernelFunc(function(h,g){var tu=h.unsortedSegmentSum(tr,to,te);return g([to]),tu},{$x:tr},function(h,g){var te=g[0];return{$x:function(){return function(h,g){for(var te=rN(g,t0(g)),tr=r1(h,te),to=rK(g,On(0,"int32")),tu=tr.rank-to.rank,tc=0;tc<tu;++tc)to=nC(to,tc+1);to=rg(to,zn(tr.shape,"bool"));var tl=t0(tr);return rC(to,tr,tl)}(h,te)}}})}});function Vc(h,g,te,tr,to,tu,tc){void 0===tu&&(tu="NHWC"),C(h.length===g.rank,function(){return"Length of inShape ("+h.length+") and rank of dy ("+g.rank+") must match"});var tl=h,th=g,td=!1;3===g.rank&&(td=!0,th=g.as4D(1,g.shape[0],g.shape[1],g.shape[2]),tl=[1,h[0],h[1],h[2]]),C(4===tl.length,function(){return"Error in conv2dDerInput: inShape must be length 4, but got length "+tl.length+"."}),C(4===th.rank,function(){return"Error in conv2dDerInput: dy must be rank 4, but got rank "+th.rank}),C(4===te.rank,function(){return"Error in conv2dDerInput: filter must be rank 4, but got rank "+te.rank});var tf="NHWC"===tu?tl[3]:tl[1],tp="NHWC"===tu?th.shape[3]:th.shape[1];C(tf===te.shape[2],function(){return"Error in conv2dDerInput: depth of input ("+tf+") must match input depth for filter "+te.shape[2]+"."}),C(tp===te.shape[3],function(){return"Error in conv2dDerInput: depth of output ("+tp+") must match output depth for filter "+te.shape[3]+"."}),null!=tc&&C(A(to),function(){return"Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode "+tc+" but got pad "+to+"."});var tv=Bo(tu),tm=So(tl,te.shape,tr,1,to,tc,!1,tv),tg=tM.runKernelFunc(function(h,g){var tr=h.conv2dDerInput(th,te,tm);return g([te,th]),tr},{dy4D:th,filter:te},function(h,g){var te=g[0],tl=g[1];return{dy4D:function(){return r4(h,te,tr,to,tu,1,tc)},filter:function(){return r6(h,tl,te.shape,tr,to,tu,tc)}}});return td?tg.as3D(tg.shape[1],tg.shape[2],tg.shape[3]):tg}function zc(h){var g="number"==typeof h?[h,h,h]:2===h.length?[h[0],h[1],1]:h,te=g[0],tr=g[1],to=g[2];return 1===te&&1===tr&&1===to}function Gc(h,g,te,tr,to){C(h.length===g.rank,function(){return"Length of inShape ("+h.length+") and rank of dy ("+g.rank+") must match"});var tu=h,tc=g,tl=!1;4===g.rank&&(tl=!0,tc=g.as5D(1,g.shape[0],g.shape[1],g.shape[2],g.shape[3]),tu=[1,h[0],h[1],h[2],h[3]]);var th=tu[4],td=tc.shape[4];C(5===tu.length,function(){return"Error in conv3dDerInput: inShape must be length 5, but got length "+tu.length+"."}),C(5===tc.rank,function(){return"Error in conv3dDerInput: dy must be rank 5, but got rank "+tc.rank}),C(5===te.rank,function(){return"Error in conv3dDerInput: filter must be rank 5, but got rank "+te.rank}),C(th===te.shape[3],function(){return"Error in conv3dDerInput: depth of input ("+th+") must match input depth for filter "+te.shape[3]+"."}),C(td===te.shape[4],function(){return"Error in conv3dDerInput: depth of output ("+td+") must match output depth for filter "+te.shape[4]+"."});var tf=Ao(tu,te.shape,tr,1,to),tp=tM.runKernelFunc(function(h){return h.conv3dDerInput(tc,te,tf)},{dy5D:tc});return tl?tp.as4D(tp.shape[1],tp.shape[2],tp.shape[3],tp.shape[4]):tp}var r3=An({conv1d_:function(h,g,te,tr,to,tu,tc){void 0===to&&(to="NWC"),void 0===tu&&(tu=1);var tl=mn(h,"x","conv1d"),th=mn(g,"filter","conv1d"),td=tl,tf=!1;2===tl.rank&&(tf=!0,td=tl.as3D(1,tl.shape[0],tl.shape[1])),C(3===td.rank,function(){return"Error in conv1d: input must be rank 3, but got rank "+td.rank+"."}),C(3===th.rank,function(){return"Error in conv1d: filter must be rank 3, but got rank "+th.rank+"."}),null!=tc&&C(A(tr),function(){return"Error in conv1d: pad must be an integer when using, dimRoundingMode "+tc+" but got pad "+tr+"."}),C(td.shape[2]===th.shape[1],function(){return"Error in conv1d: depth of input ("+td.shape[2]+") must match input depth for filter "+th.shape[1]+"."}),C(Mo(te,tu),function(){return"Error in conv1D: Either stride or dilation must be 1. Got stride "+te+" and dilation '"+tu+"'"}),C("NWC"===to,function(){return"Error in conv1d: got dataFormat of "+to+" but only NWC is currently supported."});var tp=th.as4D(1,th.shape[0],th.shape[1],th.shape[2]),tv=r4(td.as4D(td.shape[0],1,td.shape[1],td.shape[2]),tp,[1,te],tr,"NHWC",[1,tu],tc);return tf?tv.as2D(tv.shape[2],tv.shape[3]):tv.as3D(tv.shape[0],tv.shape[2],tv.shape[3])}}),r4=An({conv2d_:function(h,g,te,tr,to,tu,tc){void 0===to&&(to="NHWC"),void 0===tu&&(tu=[1,1]);var tl=mn(h,"x","conv2d"),th=mn(g,"filter","conv2d"),td=tl,tf=!1;3===tl.rank&&(tf=!0,td=tl.as4D(1,tl.shape[0],tl.shape[1],tl.shape[2])),C(4===td.rank,function(){return"Error in conv2d: input must be rank 4, but got rank "+td.rank+"."}),C(4===th.rank,function(){return"Error in conv2d: filter must be rank 4, but got rank "+th.rank+"."}),null!=tc&&C(A(tr),function(){return"Error in conv2d: pad must be an integer when using, dimRoundingMode "+tc+" but got pad "+tr+"."});var tp="NHWC"===to?td.shape[3]:td.shape[1];C(tp===th.shape[2],function(){return"Error in conv2d: depth of input ("+tp+") must match input depth for filter "+th.shape[2]+"."}),C(Mo(te,tu),function(){return"Error in conv2D: Either strides or dilations must be 1. Got strides "+te+" and dilations '"+tu+"'"});var tv=Bo(to),tm=So(td.shape,th.shape,te,tu,tr,tc,!1,tv),tg=[th,td],ty=tM.runKernelFunc(function(h,g){var te=h.conv2d(td,th,tm);return g([th,td]),te},{x:td,filter:th},function(h,g){var tc=g[0],tl=g[1];return C(Oo(tu),function(){return"Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+tu+"'"}),{x:function(){return r8(tl.shape,h,tc,te,tr,to)},filter:function(){return r6(tl,h,tc.shape,te,tr,to)}}},"Conv2D",tm,tg);return tf?ty.as3D(ty.shape[1],ty.shape[2],ty.shape[3]):ty}}),r5=An({conv3d_:function(h,g,te,tr,to,tu){void 0===to&&(to="NDHWC"),void 0===tu&&(tu=[1,1,1]);var tc,tl=mn(h,"x","conv3d"),th=mn(g,"filter","conv3d"),td=tl,tf=!1;4===tl.rank&&(tf=!0,td=tl.as5D(1,tl.shape[0],tl.shape[1],tl.shape[2],tl.shape[3])),C(5===td.rank,function(){return"Error in conv3d: input must be rank 5, but got rank "+td.rank+"."}),C(5===th.rank,function(){return"Error in conv3d: filter must be rank 5, but got rank "+th.rank+"."}),C(td.shape[4]===th.shape[3],function(){return"Error in conv3d: depth of input ("+td.shape[4]+") must match input depth for filter "+th.shape[3]+"."}),C((tc=tu,zc(te)||zc(tc)),function(){return"Error in conv3D: Either strides or dilations must be 1. Got strides "+te+" and dilations '"+tu+"'"}),C("NDHWC"===to,function(){return"Error in conv3d: got dataFormat of "+to+" but only NDHWC is currently supported."});var tp=Ao(td.shape,th.shape,te,tu,tr),tv=tM.runKernelFunc(function(h,g){var te=h.conv3d(td,th,tp);return g([td,th]),te},{x:td,$filter:th},function(h,g){C(zc(tu),function(){return"Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+tu+"'"});var to=g[0],tc=g[1];return{x:function(){return Gc(to.shape,h,tc,te,tr)},$filter:function(){var g,tu,tl,th;return g=tc.shape,tu=to,4===to.rank&&(tu=to.as5D(1,to.shape[0],to.shape[1],to.shape[2],to.shape[3])),4===(tl=h).rank&&(tl=h.as5D(1,h.shape[0],h.shape[1],h.shape[2],h.shape[3])),C(5===tu.rank,function(){return"Error in conv3dDerFilter: input must be rank 5, but got shape "+tu.shape+"."}),C(5===tl.rank,function(){return"Error in conv3dDerFilter: dy must be rank 5, but got shape "+tl.shape+"."}),C(5===g.length,function(){return"Error in conv3dDerFilter: filterShape must be length 5, but got "+g+"."}),C(tu.shape[4]===g[3],function(){return"Error in conv3dDerFilter: depth of input "+tu.shape[4]+") must match input depth in filter ("+g[3]+"."}),C(tl.shape[4]===g[4],function(){return"Error in conv3dDerFilter: depth of dy ("+tl.shape[4]+") must match output depth for filter ("+g[4]+")."}),th=Ao(tu.shape,g,te,1,tr),tM.runKernelFunc(function(h){return h.conv3dDerFilter(tu,tl,th)},{x5D:tu,dy5D:tl})}}});return tf?tv.as4D(tv.shape[1],tv.shape[2],tv.shape[3],tv.shape[4]):tv}}),r6=An({conv2dDerFilter_:function(h,g,te,tr,to,tu,tc){void 0===tu&&(tu="NHWC");var tl=h;3===h.rank&&(tl=h.as4D(1,h.shape[0],h.shape[1],h.shape[2]));var th=g;3===th.rank&&(th=g.as4D(1,g.shape[0],g.shape[1],g.shape[2])),C(4===tl.rank,function(){return"Error in conv2dDerFilter: input must be rank 4, but got shape "+tl.shape+"."}),C(4===th.rank,function(){return"Error in conv2dDerFilter: dy must be rank 4, but got shape "+th.shape+"."}),C(4===te.length,function(){return"Error in conv2dDerFilter: filterShape must be length 4, but got "+te+"."});var td="NHWC"===tu?tl.shape[3]:tl.shape[1],tf="NHWC"===tu?th.shape[3]:th.shape[1];C(td===te[2],function(){return"Error in conv2dDerFilter: depth of input "+td+") must match input depth in filter ("+te[2]+"."}),C(tf===te[3],function(){return"Error in conv2dDerFilter: depth of dy ("+tf+") must match output depth for filter ("+te[3]+")."}),null!=tc&&C(A(to),function(){return"Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode "+tc+" but got pad "+to+"."});var tp=Bo(tu),tv=So(tl.shape,te,tr,1,to,tc,!1,tp);return tM.runKernelFunc(function(h){return h.conv2dDerFilter(tl,th,tv)},{x4D:tl,dy4D:th})}}),r8=An({conv2dDerInput_:Vc}),r7=An({depthwiseConv2d_:function(h,g,te,tr,to,tu,tc){void 0===to&&(to="NHWC"),void 0===tu&&(tu=[1,1]);var tl=mn(h,"x","depthwiseConv2d"),th=mn(g,"filter","depthwiseConv2d"),td=tl,tf=!1;3===tl.rank&&(tf=!0,td=tl.as4D(1,tl.shape[0],tl.shape[1],tl.shape[2])),C(4===td.rank,function(){return"Error in depthwiseConv2d: input must be rank 4, but got rank "+td.rank+"."}),C(4===th.rank,function(){return"Error in depthwiseConv2d: filter must be rank 4, but got rank "+th.rank+"."}),C(td.shape[3]===th.shape[2],function(){return"Error in depthwiseConv2d: number of input channels ("+td.shape[3]+") must match the inChannels dimension in filter "+th.shape[2]+"."}),null==tu&&(tu=[1,1]),C(Mo(te,tu),function(){return"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+te+" and dilations '"+tu+"'"}),null!=tc&&C(A(tr),function(){return"Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode "+tc+" but got pad "+tr+"."});var tp=So(td.shape,th.shape,te,tu,tr,tc,!0),tv=[td,th],tm=tM.runKernelFunc(function(h,g){var te=h.depthwiseConv2D(td,th,tp);return g([td,th]),te},{x:td,filter:th},function(h,g){C(Oo(tu),function(){return"Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+tu+"'"});var te=g[0],tr=g[1];return{x:function(){return r9(te.shape,h,tr,tp)},filter:function(){return on(te,h,tr.shape,tp)}}},"DepthwiseConv2dNative",tp,tv);return tf?tm.as3D(tm.shape[1],tm.shape[2],tm.shape[3]):tm}}),r9=An({depthwiseConv2dDerInput_:function(h,g,te,tr){var to=g,tu=!1;3===g.rank&&(tu=!0,to=g.as4D(1,g.shape[0],g.shape[1],g.shape[2]));var tc=tM.runKernelFunc(function(h){return h.depthwiseConv2DDerInput(to,te,tr)},{dy4D:to});return tu?tc.as3D(tc.shape[1],tc.shape[2],tc.shape[3]):tc}}),on=An({depthwiseConv2dDerFilter_:function(h,g,te,tr){var to=h;3===h.rank&&(to=h.as4D(1,h.shape[0],h.shape[1],h.shape[2]));var tu=g;return 3===tu.rank&&(tu=g.as4D(1,g.shape[0],g.shape[1],g.shape[2])),tM.runKernelFunc(function(h){return h.depthwiseConv2DDerFilter(to,tu,tr)},{x4D:to,dy4D:tu})}}),or=An({separableConv2d_:function(h,g,te,tr,to,tu,tc){void 0===tu&&(tu=[1,1]),void 0===tc&&(tc="NHWC");var tl=mn(h,"x","separableConv2d"),th=mn(g,"depthwiseFilter","separableConv2d"),td=mn(te,"pointwiseFilter","separableConv2d"),tf=tl,tp=!1;if(3===tl.rank&&(tp=!0,tf=tl.as4D(1,tl.shape[0],tl.shape[1],tl.shape[2])),"NCHW"===tc)throw Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");C(4===tf.rank,function(){return"Error in separableConv2d: input must be rank 4, but got rank "+tf.rank+"."}),C(4===th.rank,function(){return"Error in separableConv2d: depthwise filter must be rank 4, but got rank "+th.rank+"."}),C(4===td.rank,function(){return"Error in separableConv2d: pointwise filter must be rank 4, but got rank "+th.rank+"."}),C(1===td.shape[0],function(){return"Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got "+td.shape[0]+"."}),C(1===td.shape[1],function(){return"Error in separableConv2d: the second dimension of pointwise filter must be 1, but got "+td.shape[1]+"."});var tv=th.shape[2],tm=th.shape[3];C(td.shape[2]===tv*tm,function(){return"Error in separableConv2d: the third dimension of pointwise filter must be "+tv*tm+", but got "+td.shape[2]+"."});var tg=r4(r7(tf,th,tr,to,tc,tu),td,1,"valid",tc);return tp?tg.as3D(tg.shape[1],tg.shape[2],tg.shape[3]):tg}}),ou=An({conv2dTranspose_:function(h,g,te,tr,to,tu){return Vc(te,mn(h,"x","conv2dTranspose"),mn(g,"filter","conv2dTranspose"),tr,to,"NHWC",tu)}}),oc=An({conv3dTranspose_:function(h,g,te,tr,to){return Gc(te,mn(h,"x","conv3dTranspose"),mn(g,"filter","conv3dTranspose"),tr,to)}}),ol=An({matMul_:function(h,g,te,tr){void 0===te&&(te=!1),void 0===tr&&(tr=!1);var to,tu=mn(h,"a","matMul"),tc=mn(g,"b","matMul");tu=(to=Nt(tu,tc))[0],tc=to[1];var tl=te?tu.shape[tu.rank-2]:tu.shape[tu.rank-1],th=tr?tc.shape[tc.rank-1]:tc.shape[tc.rank-2],td=te?tu.shape[tu.rank-1]:tu.shape[tu.rank-2],tf=tr?tc.shape[tc.rank-2]:tc.shape[tc.rank-1],tp=tu.shape.slice(0,-2),tv=tc.shape.slice(0,-2),tm=k(tp),tg=k(tv);C(tu.rank>=2&&tc.rank>=2&&tu.rank===tc.rank,function(){return"Error in matMul: inputs must have the same rank of at least 2, got ranks "+tu.rank+" and "+tc.rank+"."}),C(S(tp,tv),function(){return"Error in matMul: outer dimensions ("+tp+") and ("+tv+") of Tensors with shapes "+tu.shape+" and "+tc.shape+" must match."}),C(tl===th,function(){return"Error in matMul: inner shapes ("+tl+") and ("+th+") of Tensors with shapes "+tu.shape+" and "+tc.shape+" and transposeA="+te+" and transposeB="+tr+" must match."});var ty=tu.shape.slice(0,-2).concat([td,tf]),tx=te?tu.as3D(tm,tl,td):tu.as3D(tm,td,tl),tb=tr?tc.as3D(tg,tf,th):tc.as3D(tg,th,tf),tC={transposeA:te,transposeB:tr};return tM.runKernelFunc(function(h,g){var to=h.batchMatMul(tx,tb,te,tr);return g([tx,tb]),to},{a:tx,b:tb},function(h,g){var to=g[0],tu=g[1];return te||tr?!te&&tr?{a:function(){return h.matMul(tu,!1,!1)},b:function(){return h.matMul(to,!0,!1)}}:te&&!tr?{a:function(){return tu.matMul(h,!1,!0)},b:function(){return to.matMul(h,!1,!1)}}:{a:function(){return tu.matMul(h,!0,!0)},b:function(){return h.matMul(to,!0,!0)}}:{a:function(){return h.matMul(tu,!1,!0)},b:function(){return to.matMul(h,!0,!1)}}},"BatchMatMul",tC).reshape(ty)}}),oh=An({dot_:function(h,g){var te=mn(h,"t1","dot"),tr=mn(g,"t2","dot");C(!(1!==te.rank&&2!==te.rank||1!==tr.rank&&2!==tr.rank),function(){return"Error in dot: inputs must all be rank 1 or 2, but got ranks "+te.rank+" and "+tr.rank+"."});var to=1===te.rank?te.size:te.shape[1],tu=1===tr.rank?tr.size:tr.shape[0];return C(to===tu,function(){return"Error in dot: inner dimensions of inputs must match, but got "+to+" and "+tu+"."}),1===te.rank&&1===tr.rank?te.as2D(1,-1).matMul(tr.as2D(-1,1)).asScalar():1===te.rank&&2===tr.rank?te.as2D(1,-1).matMul(tr.as2D(tr.shape[0],tr.shape[1])).as1D():2===te.rank&&1===tr.rank?te.matMul(tr.as2D(-1,1)).as1D():te.matMul(tr.as2D(tr.shape[0],tr.shape[1]))}}),od=An({outerProduct_:function(h,g){var te=mn(h,"v1","outerProduct"),tr=mn(g,"v2","outerProduct");return C(1===te.rank&&1===tr.rank,function(){return"Error in outerProduct: inputs must be rank 1, but got ranks "+te.rank+" and "+tr.rank+"."}),te.as2D(-1,1).matMul(tr.as2D(1,-1))}}),of=An({reverse_:function(h,g){var te=mn(h,"x","reverse");if(0===te.rank)return te.clone();var tr=O(g,te.shape);return tM.runKernelFunc(function(h){return h.reverse(te,tr)},{$x:te},function(h){return{$x:function(){return h.reverse(tr)}}}).reshapeAs(te)}}),op=An({reverse1d_:function(h){var g=mn(h,"x","reverse");return C(1===g.rank,function(){return"Error in reverse1D: x must be rank 1 but got rank "+g.rank+"."}),of(g,0)}}),ov=An({reverse2d_:function(h,g){var te=mn(h,"x","reverse");return C(2===te.rank,function(){return"Error in reverse2D: x must be rank 2 but got rank "+te.rank+"."}),of(te,g)}}),om=An({reverse3d_:function(h,g){var te=mn(h,"x","reverse");return C(3===te.rank,function(){return"Error in reverse3D: x must be rank 3 but got rank "+te.rank+"."}),of(te,g)}}),og=An({reverse4d_:function(h,g){var te=mn(h,"x","reverse");return C(4===te.rank,function(){return"Error in reverse4D: x must be rank 4 but got rank "+te.rank+"."}),of(te,g)}});function cl(h,g,te,tr,to,tu){var tc=mn(h,"x","maxPool"),tl=tc,th=!1;3===tc.rank&&(th=!0,tl=tc.as4D(1,tc.shape[0],tc.shape[1],tc.shape[2])),null==tr&&(tr=[1,1]),C(4===tl.rank,function(){return"Error in maxPool: input must be rank 4 but got rank "+tl.rank+"."}),C(Mo(te,tr),function(){return"Error in maxPool: Either strides or dilations must be 1. Got strides "+te+" and dilations '"+tr+"'"}),null!=tu&&C(A(to),function(){return"Error in maxPool: pad must be an integer when using, dimRoundingMode "+tu+" but got pad "+to+"."});var td=Io(tl.shape,g,te,tr,to,tu);if(1===td.filterWidth&&1===td.filterHeight&&S(td.inShape,td.outShape))return tc.clone();var tf=[tl],tp=tM.runKernelFunc(function(h,g){var te=h.maxPool(tl,td);return g([tl,te]),te},{x:tl},function(h,tu){var tc=tu[0],tl=tu[1];return{x:function(){var tu,th,td,tf,tp,tv;return tu=tr,td=mn(h,"dy","maxPoolBackprop"),tf=mn(tc,"input","maxPoolBackprop"),tp=mn(tl,"output","maxPoolBackprop"),C(tf.rank===td.rank,function(){return"Rank of input ("+tf.rank+") does not match rank of dy ("+td.rank+")"}),null==tu&&(tu=[1,1]),C(Mo(te,tu),function(){return"Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides "+te+" and dilations '"+tu+"'"}),C(4===td.rank,function(){return"Error in maxPoolBackprop: dy must be rank 4 but got rank "+td.rank+"."}),C(4===tf.rank,function(){return"Error in maxPoolBackprop: input must be rank 4 but got rank "+tf.rank+"."}),null!=th&&C(A(to),function(){return"Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode "+th+" but got pad "+to+"."}),tv=Io(tf.shape,g,te,tu,to,th),tM.runKernelFunc(function(h){return h.maxPoolBackprop(td,tf,tp,tv)},{$dy:td,$input:tf})}}},"MaxPool",td,tf);return th?tp.as3D(tp.shape[1],tp.shape[2],tp.shape[3]):tp}function ll(h,g,te,tr,to,tu){var tc=mn(h,"x","avgPool","float32");null==tr&&(tr=[1,1]),C(Mo(te,tr),function(){return"Error in avgPool: Either strides or dilations must be 1. Got strides "+te+" and dilations '"+tr+"'"});var tl=tc,th=!1;3===tc.rank&&(th=!0,tl=tc.as4D(1,tc.shape[0],tc.shape[1],tc.shape[2])),C(4===tl.rank,function(){return"Error in avgPool: x must be rank 4 but got rank "+tl.rank+"."}),null!=tu&&C(A(to),function(){return"Error in avgPool: pad must be an integer when using, dimRoundingMode "+tu+" but got pad "+to+"."});var td=Io(tl.shape,g,te,tr,to,tu);if(1===td.filterWidth&&1===td.filterHeight&&S(td.inShape,td.outShape))return tc.clone();var tf=tM.runKernelFunc(function(h){return h.avgPool(tl,td)},{x:tl},function(h){return{x:function(){var tu,tc,th,td,tf,tp,tv,tm,tg;return tu=tl,tc=tr,th=mn(h,"dy","avgPoolBackprop"),C((td=mn(tu,"input","avgPoolBackprop")).rank===th.rank,function(){return"Rank of input ("+td.rank+") does not match rank of dy ("+th.rank+")"}),null==tc&&(tc=[1,1]),C(Mo(te,tc),function(){return"Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides "+te+" and dilations '"+tc+"'"}),tf=td,tp=th,tv=!1,3===td.rank&&(tv=!0,tf=td.as4D(1,td.shape[0],td.shape[1],td.shape[2]),tp=th.as4D(1,th.shape[0],th.shape[1],th.shape[2])),C(4===tp.rank,function(){return"Error in avgPoolBackprop: dy must be rank 4 but got rank "+tp.rank+"."}),C(4===tf.rank,function(){return"Error in avgPoolBackprop: input must be rank 4 but got rank "+tf.rank+"."}),tm=Io(tf.shape,g,te,tc,to),tg=tM.runKernelFunc(function(h){return h.avgPoolBackprop(tp,tf,tm)},{dy4D:tp,input4D:tf}),tv?tg.as3D(tg.shape[1],tg.shape[2],tg.shape[3]):tg}}},"AvgPool",td);return tf=tf.cast(tc.dtype),th?tf.as3D(tf.shape[1],tf.shape[2],tf.shape[3]):tf}var oy=An({maxPool_:function(h,g,te,tr,to){return cl(h,g,te,1,tr,to)}}),ox=An({avgPool_:function(h,g,te,tr,to){return ll(h,g,te,1,tr,to)}}),ob=An({pool_:function(h,g,te,tr,to,tu){null==to&&(to=[1,1]),null==tu&&(tu=1),0===tr&&(tr="valid");var tc,tl,th,td,tf,tp,tv,tm,tg,ty=mn(h,"x","maxPool"),tx=ty,tb=!1;3===ty.rank&&(tb=!0,tx=ty.as4D(1,ty.shape[0],ty.shape[1],ty.shape[2])),C(Mo(tu,to),function(){return"Error in pool: Either strides or dilations must be 1. Got strides "+tu+" and dilations '"+to+"'"});var tC,tw=Io(tx.shape,g,tu,to,tr),tE=[tw.dilationHeight,tw.dilationWidth];tC="same"===tr?(tl=(tc=[tw.filterHeight,tw.filterWidth].map(function(h,g){return h+(h-1)*(tE[g]-1)}).map(function(h){return h-1})).map(function(h){return Math.floor(h/2)}),th=tc.map(function(h,g){return h-tl[g]}),tc.map(function(h,g){return[tl[g],th[g]]})):[[0,0],[0,0]];var tR=1===tE[0]&&1===tE[1],tI=(td=[tw.inHeight,tw.inWidth],tf=tC.map(function(h){return h[0]}),tv=td.concat(tf,tp=tC.map(function(h){return h[1]})),tm=tE.map(function(h,g){return(h-tv[g]%h)%h}),tg=tp.map(function(h,g){return h+tm[g]}),[tE.map(function(h,g){return[tf[g],tg[g]]}),tE.map(function(h,g){return[0,tm[g]]})]),tk=tI[0],tA=tI[1],tS=tR?tr:"valid",tD=tR?tx:nM(tx,tE,tk),tN=("avg"===te?function(){return ll(tD,g,tu,1,tS)}:function(){return cl(tD,g,tu,1,tS)})(),tT=tR?tN:nv(tN,tE,tA);return tb?tT.as3D(tT.shape[1],tT.shape[2],tT.shape[3]):tT}}),oC=An({maxPool3d_:function(h,g,te,tr,to,tu,tc){void 0===tu&&(tu="NDHWC");var tl=mn(h,"x","maxPool3d"),th=tl,td=!1;4===tl.rank&&(td=!0,th=tl.as5D(1,tl.shape[0],tl.shape[1],tl.shape[2],tl.shape[3])),null==tc&&(tc=[1,1,1]),C(5===th.rank,function(){return"Error in maxPool3d: x must be rank 5 but got rank "+th.rank+"."}),C("NDHWC"===tu,function(){return"Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of "+tu}),C(Mo(te,tc),function(){return"Error in maxPool3d: Either strides or dilations must be 1. Got strides "+te+" and dilations '"+tc+"'"}),null!=to&&C(A(tr),function(){return"Error in maxPool3d: pad must be an integer when using, dimRoundingMode "+to+" but got pad "+tr+"."});var tf=ko(th.shape,g,te,tc,tr,to,tu),tp=tM.runKernelFunc(function(h,g){var te=h.maxPool3d(th,tf);return g([th,te]),te},{x:th},function(h,tu){var tl=tu[0],th=tu[1];return{x:function(){var tu,td,tf,tp,tv,tm,tg,ty,tx,tb;return tu=tc,td=mn(h,"dy","maxPool3dBackprop"),tf=mn(tl,"input","maxPool3dBackprop"),tp=mn(th,"output","maxPool3dBackprop"),tv=td,tm=tf,tg=tp,ty=!1,4===tf.rank&&(ty=!0,tv=td.as5D(1,td.shape[0],td.shape[1],td.shape[2],td.shape[3]),tm=tf.as5D(1,tf.shape[0],tf.shape[1],tf.shape[2],tf.shape[3]),tg=tp.as5D(1,tp.shape[0],tp.shape[1],tp.shape[2],tp.shape[3])),C(5===tv.rank,function(){return"Error in maxPool3dBackprop: dy must be rank 5 but got rank "+tv.rank+"."}),C(5===tm.rank,function(){return"Error in maxPool3dBackprop: input must be rank 5 but got rank "+tm.rank+"."}),C(5===tg.rank,function(){return"Error in maxPool3dBackprop: output must be rank 5 but got rank "+tg.rank+"."}),null==tu&&(tu=[1,1,1]),C(Mo(te,tu),function(){return"Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides "+te+" and dilations '"+tu+"'"}),null!=to&&C(A(tr),function(){return"Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode "+to+" but got pad "+tr+"."}),tx=ko(tm.shape,g,te,tu,tr,to),tb=tM.runKernelFunc(function(h){return h.maxPool3dBackprop(tv,tm,tg,tx)},{dy5D:tv,input5D:tm}),ty?tb.as4D(tb.shape[1],tb.shape[2],tb.shape[3],tb.shape[4]):tb}}});return td?tp.as4D(tp.shape[1],tp.shape[2],tp.shape[3],tp.shape[4]):tp}}),ow=An({avgPool3d_:function(h,g,te,tr,to,tu,tc){void 0===tu&&(tu="NDHWC");var tl=mn(h,"x","avgPool3d","float32"),th=tl,td=!1;4===tl.rank&&(td=!0,th=tl.as5D(1,tl.shape[0],tl.shape[1],tl.shape[2],tl.shape[3])),null==tc&&(tc=[1,1,1]),C(5===th.rank,function(){return"Error in avgPool3d: x must be rank 5 but got rank "+th.rank+"."}),C("NDHWC"===tu,function(){return"Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of "+tu}),C(Mo(te,tc),function(){return"Error in avgPool3d: Either strides or dilations must be 1. Got strides "+te+" and dilations '"+tc+"'"}),null!=to&&C(A(tr),function(){return"Error in avgPool3d: pad must be an integer when using, dimRoundingMode "+to+" but got pad "+tr+"."});var tf=ko(th.shape,g,te,tc,tr,to,tu),tp=tM.runKernelFunc(function(h){return h.avgPool3d(th,tf)},{x:th},function(h){return{x:function(){var tu,tl,td,tf,tp,tv,tm,tg,ty;return tu=th,tl=tc,td=mn(h,"dy","avgPool3dBackprop"),tf=mn(tu,"input","avgPool3dBackprop"),tp=td,tv=tf,tm=!1,4===tf.rank&&(tm=!0,tp=td.as5D(1,td.shape[0],td.shape[1],td.shape[2],td.shape[3]),tv=tf.as5D(1,tf.shape[0],tf.shape[1],tf.shape[2],tf.shape[3])),C(5===tp.rank,function(){return"Error in avgPool3dBackprop: dy must be rank 5 but got rank "+tp.rank+"."}),C(5===tv.rank,function(){return"Error in avgPool3dBackprop: input must be rank 5 but got rank "+tv.rank+"."}),null==tl&&(tl=[1,1,1]),C(Mo(te,tl),function(){return"Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides "+te+" and dilations '"+tl+"'"}),null!=to&&C(A(tr),function(){return"Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode "+to+" but got pad "+tr+"."}),tg=ko(tv.shape,g,te,tl,tr,to),ty=tM.runKernelFunc(function(h){return h.avgPool3dBackprop(tp,tv,tg)},{dy5D:tp,input5D:tv}),tm?ty.as4D(ty.shape[1],ty.shape[2],ty.shape[3],ty.shape[4]):ty}}});return tp=tp.cast(th.dtype),td?tp.as4D(tp.shape[1],tp.shape[2],tp.shape[3],tp.shape[4]):tp}}),oE=An({slice_:function(h,g,te){var tr,to,tu=mn(h,"x","slice");if(0===tu.rank)throw Error("Slicing scalar is not possible");(tr="number"==typeof g?[g].concat(Array(tu.rank-1).fill(0)):g.length<tu.rank?g.concat(Array(tu.rank-g.length).fill(0)):g.slice()).forEach(function(h){C(-1!==h,function(){return"slice() does not support negative begin indexing."})}),to=(to=null==te?Array(tu.rank).fill(-1):"number"==typeof te?[te].concat(Array(tu.rank-1).fill(-1)):te.length<tu.rank?te.concat(Array(tu.rank-te.length).fill(-1)):te).map(function(h,g){return h>=0?h:(C(-1===h,function(){return"Negative size values should be exactly -1 but got "+h+" for the slice() size at index "+g+"."}),tu.shape[g]-tr[g])}),eo(tu,tr,to);var tc=tu.shape,tl={begin:tr,size:to};return tM.runKernelFunc(function(h){return h.slice(tu,tr,to)},{x:tu},function(h){for(var g=[],te=0;te<h.rank;te++)g.push([tr[te],tc[te]-tr[te]-to[te]]);return{x:function(){return h.pad(g)}}},"Slice",tl)}}),oR=An({slice1d_:function(h,g,te){var tr=mn(h,"x","slice1d");return C(1===tr.rank,function(){return"slice1d expects a rank-1 tensor, but got a rank-"+tr.rank+" tensor"}),oE(tr,[g],[te])}}),oI=An({slice2d_:function(h,g,te){var tr=mn(h,"x","slice2d");return C(2===tr.rank,function(){return"slice2d expects a rank-2 tensor, but got a rank-"+tr.rank+" tensor"}),oE(tr,g,te)}}),ok=An({slice3d_:function(h,g,te){var tr=mn(h,"x","slice3d");return C(3===tr.rank,function(){return"slice3d expects a rank-3 tensor, but got a rank-"+tr.rank+" tensor"}),oE(tr,g,te)}}),oA=An({slice4d_:function(h,g,te){var tr=mn(h,"x","slice4d");return C(4===tr.rank,function(){return"slice4d expects a rank-4 tensor, but got a rank-"+tr.rank+" tensor"}),oE(tr,g,te)}});function wl(h,g,te,tr,to){return g.rank<te.rank&&(g=g.reshape(wn(g.shape,tr))),h.rank<te.rank&&(h=h.reshape(wn(h.shape,tr))),{x:function(){var tr=h.mul(te.equal(g).cast(h.dtype));return null==to?tr:tr.transpose(to)}}}var oS=An({all_:function(h,g,te){void 0===g&&(g=null),void 0===te&&(te=!1);var tr=mn(h,"x","all","bool"),to=O(g,tr.shape),tu=to,tc=En(tu,tr.rank);null!=tc&&(tr=tr.transpose(tc),tu=In(tu.length,tr.rank));var tl=tM.runKernelFunc(function(h){return h.all(tr,tu)},{$x:tr});if(te){var th=wn(tl.shape,to);return tl.reshape(th)}return tl}}),oD=An({any_:function(h,g,te){void 0===g&&(g=null),void 0===te&&(te=!1);var tr=mn(h,"x","any","bool"),to=O(g,tr.shape),tu=to,tc=En(tu,tr.rank);null!=tc&&(tr=tr.transpose(tc),tu=In(tu.length,tr.rank));var tl=tM.runKernelFunc(function(h){return h.any(tr,tu)},{$x:tr});if(te){var th=wn(tl.shape,to);return tl.reshape(th)}return tl}}),oN=An({argMax_:function(h,g){void 0===g&&(g=0);var te=mn(h,"x","argMax");null==g&&(g=0);var tr=O(g,te.shape),to=En(tr,te.rank);null!=to&&(te=te.transpose(to),tr=In(tr.length,te.rank));var tu={axis:tr[0]},tc=[te];return tM.runKernelFunc(function(h,g){var to=h.argMax(te,tr[0]);return g([te]),to},{x:te},function(h,g){var te=g[0];return{x:function(){return t0(te)}}},"ArgMax",tu,tc)}}),oT=An({argMin_:function(h,g){void 0===g&&(g=0);var te=mn(h,"x","argMin");null==g&&(g=0);var tr=O(g,te.shape),to=En(tr,te.rank);return null!=to&&(te=te.transpose(to),tr=In(tr.length,te.rank)),tM.runKernelFunc(function(h,g){var to=h.argMin(te,tr[0]);return g([te]),to},{$x:te},function(h,g){var te=g[0];return{$x:function(){return t0(te)}}})}}),oF=An({logSumExp_:function(h,g,te){void 0===g&&(g=null),void 0===te&&(te=!1);var tr=mn(h,"x","logSumExp"),to=O(g,tr.shape),tu=tr.max(to,!0),tc=tr.sub(tu).exp().sum(to).log(),tl=tu.reshape(tc.shape).add(tc);if(te){var th=wn(tl.shape,to);return tl.reshape(th)}return tl}}),oO=An({max_:function(h,g,te){void 0===g&&(g=null),void 0===te&&(te=!1);var tr=mn(h,"x","max"),to=tr,tu=O(g,tr.shape),tc=tu,tl=En(tc,tr.rank);null!=tl&&(tr=tr.transpose(tl),tc=In(tc.length,tr.rank));var th=[tr],td=tM.runKernelFunc(function(h,g){var te=h.max(tr,tc);return g([to,te]),te},{x:tr},function(h,g){return wl(h,g[1],g[0],tu,tl)},"Max",{axes:tc},th,[!0]);if(te){var tf=wn(td.shape,tu);td=td.reshape(tf)}return td}}),o_=An({mean_:function(h,g,te){void 0===g&&(g=null),void 0===te&&(te=!1);var tr=mn(h,"x","mean"),to=O(g,tr.shape),tu=k(bn(tr.shape,to)[1]);return vo(function(h){var tr=On(tu);return{value:(tr.dtype===h.dtype?h:h.cast(tr.dtype)).div(tr).sum(g,te),gradFunc:function(g){var te=h.shape.slice();return to.forEach(function(h){te[h]=1}),g.reshape(te).mul(zn(h.shape,"float32")).div(tu)}}})(tr)}}),oM=An({min_:function(h,g,te){void 0===g&&(g=null),void 0===te&&(te=!1);var tr=mn(h,"x","min"),to=tr,tu=O(g,tr.shape),tc=tu,tl=En(tc,tr.rank);null!=tl&&(tr=tr.transpose(tl),tc=In(tc.length,tr.rank));var th=[tr],td=tM.runKernelFunc(function(h,g){var te=h.min(tr,tc);return g([to,te]),te},{x:tr},function(h,g){return wl(h,g[1],g[0],tu,tl)},"Min",{axes:tc},th,[!0]);if(te){var tf=wn(td.shape,tu);td=td.reshape(tf)}return td}}),oB=An({moments_:function(h,g,te){void 0===g&&(g=null),void 0===te&&(te=!1);var tr=O(g,(h=mn(h,"x","moments")).shape),to=h.mean(tr,te),tu=to.shape;te||(tu=wn(to.shape,tr));var tc=h.toFloat().sub(to.reshape(tu)).square();return{mean:to,variance:tc.mean(tr,te)}}}),oP=An({sum_:function(h,g,te){void 0===g&&(g=null),void 0===te&&(te=!1);var tr=mn(h,"x","sum");"bool"===tr.dtype&&(tr=tr.toInt());var to=O(g,tr.shape);return vo(function(h){var g=En(to,h.rank),tr=to,tu=h;null!=g&&(tu=h.transpose(g),tr=In(tr.length,h.rank));var i=function(g){var te=h.shape.slice();return to.forEach(function(h){te[h]=1}),g.reshape(te).mul(zn(h.shape,"float32"))},tc={axes:tr},tl=tM.runKernelFunc(function(h){return h.sum(tu,tr)},{x:tu},function(h){return{x:function(){return i(h)}}},"Sum",tc);if(te){var th=wn(tl.shape,to);tl=tl.reshape(th)}return{value:tl,gradFunc:i}})(tr)}}),oL=An({prod_:function(h,g,te){void 0===g&&(g=null),void 0===te&&(te=!1);var tr=mn(h,"x","prod");"bool"===tr.dtype&&(tr=tr.toInt());var to=O(g,tr.shape),tu=En(to,tr.rank),tc=to,tl=tr;null!=tu&&(tl=tr.transpose(tu),tc=In(tc.length,tr.rank));var th=tM.runKernelFunc(function(h){return h.prod(tl,tc)},{permutedX:tl});if(te){var td=wn(th.shape,to);th=th.reshape(td)}return th}}),oW=An({elu_:function(h){var g=mn(h,"x","elu");return tM.runKernelFunc(function(h,te){var tr=h.elu(g);return te([tr]),tr},{$x:g},function(h,g){var te=g[0];return{$x:function(){return tM.runKernelFunc(function(g){return g.eluDer(h,te)},{dy:h,y:te})}}})}}),oV=An({leakyRelu_:function(h,g){void 0===g&&(g=.2);var te=mn(h,"x","leakyRelu");return rN(On(g).mul(te),te)}}),oU=An({prelu_:function(h,g){var te=mn(h,"x","prelu"),tr=mn(g,"alpha","prelu");return tM.runKernelFunc(function(h,g){var to=h.prelu(te,tr);return g([te,tr]),to},{x:te,alpha:tr},function(h,g){var te=g[0],tr=g[1],to=te.greater(0);return{x:function(){return rC(to,h,h.mul(tr))},alpha:function(){var g=rC(to,t0(h),h.mul(te)),tu=Eo(tr.shape,h.shape);return tu.length>0&&(g=g.sum(tu)),g.reshape(tr.shape)}}},"Prelu")}}),oz=An({relu_:function(h){var g=mn(h,"x","relu");return"bool"===g.dtype?g.toInt():tM.runKernelFunc(function(h,te){var tr=h.relu(g);return te([g]),tr},{x:g},function(h,g){var te=g[0];return{x:function(){return h.mulStrict(te.step().toFloat())}}},"Relu")}}),oH=An({relu6_:function(h){var g=mn(h,"x","relu6");return"bool"===g.dtype?g.toInt():tM.runKernelFunc(function(h,te){var tr=h.relu6(g);return te([g]),tr},{x:g},function(h,g){var te=g[0],tr=te.lessEqual(6).mul(te.step());return{x:function(){return h.mulStrict(tr.toFloat())}}},"Relu6")}}),oG=An({selu_:function(h){var g=mn(h,"x","selu");return tM.runKernelFunc(function(h,te){var tr=h.selu(g);return te([g]),tr},{$x:g},function(h,g){var te=g[0];return{$x:function(){var g=te.greater(On(0)),tr=On(1.7580993408473768),to=On(1.0507009873554805);return rC(g,h.mul(to),h.mul(tr).mul(te.toFloat().exp()))}}})}}),oq=An({transpose_:function(h,g){var te=mn(h,"x","transpose");if(null==g&&(g=te.shape.map(function(h,g){return g}).reverse()),C(te.rank===g.length,function(){return"Error in transpose: rank of input "+te.rank+" must match length of perm "+g+"."}),g.forEach(function(h){C(h>=0&&h<te.rank,function(){return"All entries in 'perm' must be between 0 and "+(te.rank-1)+" but got "+g})}),te.rank<=1)return te.clone();var tr={perm:g};return tM.runKernelFunc(function(h){return h.transpose(te,g)},{x:te},function(h){var te=Rn(g);return{x:function(){return h.transpose(te)}}},"Transpose",tr)}}),oK=An({localResponseNormalization_:function(h,g,te,tr,to){void 0===g&&(g=5),void 0===te&&(te=1),void 0===tr&&(tr=1),void 0===to&&(to=.5);var tu=mn(h,"x","localResponseNormalization");C(4===tu.rank||3===tu.rank,function(){return"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank "+tu.rank+"."}),C(A(g),function(){return"Error in localResponseNormalization: depthRadius must be an integer but got depthRadius "+g+"."});var tc=tu,tl=!1;3===tu.rank&&(tl=!0,tc=tu.as4D(1,tu.shape[0],tu.shape[1],tu.shape[2]));var th=tM.runKernelFunc(function(h,tu){var tl=h.localResponseNormalization4D(tc,g,te,tr,to);return tu([tc,tl]),tl},{x4D:tc},function(h,tu){var tc=tu[0],tl=tu[1];return{x4D:function(){return tM.runKernelFunc(function(tu){return tu.LRNGrad(h,tc,tl,g,te,tr,to)},{})}}});return tl?th.as3D(th.shape[1],th.shape[2],th.shape[3]):th}}),oj=An({norm_:function(h,g,te,tr){void 0===g&&(g="euclidean"),void 0===te&&(te=null),void 0===tr&&(tr=!1);var to=function t(h,g,te){if(void 0===te&&(te=null),0===h.rank)return h.abs();if(1!==h.rank&&null===te)return t(h.reshape([-1]),g,te);if(1===h.rank||"number"==typeof te||Array.isArray(te)&&1===te.length){if(1===g)return h.abs().sum(te);if(g===1/0)return h.abs().max(te);if(g===-1/0)return h.abs().min(te);if("euclidean"===g||2===g)return h.abs().pow(On(2,"int32")).sum(te).sqrt();throw Error("Error in norm: invalid ord value: "+g)}if(Array.isArray(te)&&2===te.length){if(1===g)return h.abs().sum(te[0]).max(te[1]-1);if(g===1/0)return h.abs().sum(te[1]).max(te[0]);if(g===-1/0)return h.abs().sum(te[1]).min(te[0]);if("fro"===g||"euclidean"===g)return h.square().sum(te).sqrt();throw Error("Error in norm: invalid ord value: "+g)}throw Error("Error in norm: invalid axis: "+te)}(h=mn(h,"x","norm"),g,te),tu=to.shape;if(tr){var tc=O(te,h.shape);tu=wn(to.shape,tc)}return to.reshape(tu)}}),oX=An({basicLSTMCell_:function(h,g,te,tr,to,tu){var tc=mn(h,"forgetBias","basicLSTMCell"),tl=mn(g,"lstmKernel","basicLSTMCell"),th=mn(te,"lstmBias","basicLSTMCell"),td=mn(tr,"data","basicLSTMCell"),tf=mn(to,"c","basicLSTMCell"),tp=mn(tu,"h","basicLSTMCell"),tv=td.concat(tp,1).matMul(tl).add(th),tm=tv.shape[0],tg=tv.shape[1]/4,ty=[tm,tg],tx=tv.slice([0,0],ty),tb=tv.slice([0,tg],ty),tC=tv.slice([0,2*tg],ty),tw=tv.slice([0,3*tg],ty),tE=tx.sigmoid().mulStrict(tb.tanh()).addStrict(tf.mulStrict(tc.add(tC).sigmoid())),tR=tE.tanh().mulStrict(tw.sigmoid());return[tE,tR]}}),o$=An({multiRNNCell_:function(h,g,te,tr){for(var to=mn(g,"data","multiRNNCell"),tu=gn(te,"c","multiRNNCell"),tc=gn(tr,"h","multiRNNCell"),tl=to,th=[],td=0;td<h.length;td++){var tf=h[td](tl,tu[td],tc[td]);th.push(tf[0]),th.push(tf[1]),tl=tf[1]}var tp=[],tv=[];for(td=0;td<th.length;td+=2)tp.push(th[td]),tv.push(th[td+1]);return[tp,tv]}}),oY=An({movingAverage_:function(h,g,te,tr,to){void 0===to&&(to=!0);var tu=mn(h,"v","movingAverage"),tc=mn(g,"x","movingAverage"),tl=mn(te,"decay","movingAverage");Ft(tu,tc),C(S(tu.shape,tc.shape),function(){return"Shape mismatch in v and x"});var th=On(1),td=th.sub(tl),tf=tc.sub(tu).mul(td);if(to){C(null!=tr,function(){return"When using zeroDebias: true, step is required."});var tp=mn(tr,"step","movingAverage");tf=tf.div(th.sub(rL(tl,tp)))}return tu.add(tf)}}),oJ=An({stridedSlice_:function(h,g,te,tr,to,tu,tc,tl,th){if(void 0===to&&(to=0),void 0===tu&&(tu=0),void 0===tc&&(tc=0),void 0===tl&&(tl=0),void 0===th&&(th=0),null==tr&&(tr=Array(g.length)),0!==tc)throw Error("ellipsis mask is not yet supported");var td=mn(h,"x","stridedSlice"),tf=no(tl),tp=td.shape.slice();tf.forEach(function(h){g[h]=0,te[h]=1,tp.splice(h,0,1)}),td=td.reshape(tp);for(var tv=0;tv<td.rank;tv++)g[tv]=oo(to,g,tr,td.shape,tv),te[tv]=ao(tu,te,tr,td.shape,tv),tr[tv]=tr[tv]||1;var tm=no(th);tm.forEach(function(h){te[h]=g[h]+1,tr[h]=1});var tg=ro(g,te,tr),ty=tg.filter(function(h,g){return -1===tm.indexOf(g)});return tr.every(function(h){return 1===h})?oE(td,g,tg).reshape(ty):tM.runKernelFunc(function(h){return h.stridedSlice(td,g,te,tr)},{$x:td}).reshape(ty)}}),oQ=An({topk_:function(h,g,te){void 0===g&&(g=1),void 0===te&&(te=!0);var tr=mn(h,"x","topk");if(0===tr.rank)throw Error("topk() expects the input to be of rank 1 or higher");var to=tr.shape[tr.shape.length-1];if(g>to)throw Error("'k' passed to topk() must be <= the last dimension ("+to+") but got "+g);var tu=tM.runKernelFunc(function(h){return h.topk(tr,g,te)},{$x:tr});return{values:tu[0],indices:tu[1]}}}),oZ=An({scatterND_:function(h,g,te){var tr=mn(h,"indices","scatterND","int32"),to=mn(g,"updates","scatterND");return Jr(to,tr,te),tM.runKernelFunc(function(h){return h.scatterND(tr,to,te)},{indices:tr,updates:to},null,"ScatterNd",{shape:te})}}),o0=An({fft_:function(h){C("complex64"===h.dtype,function(){return"The dtype for tf.spectral.fft() must be complex64 but got "+h.dtype+"."});var g=h.shape[h.shape.length-1],te=h.size/g,tr=h.as2D(te,g);return tM.runKernelFunc(function(h){return h.fft(tr)},{input:h}).reshape(h.shape)}}),o1=An({ifft_:function(h){C("complex64"===h.dtype,function(){return"The dtype for tf.spectral.ifft() must be complex64 but got "+h.dtype+"."});var g=h.shape[h.shape.length-1],te=h.size/g,tr=h.as2D(te,g);return tM.runKernelFunc(function(h){return h.ifft(tr)},{input:h}).reshape(h.shape)}}),o2=An({rfft_:function(h,g){C("float32"===h.dtype,function(){return"The dtype for rfft() must be real value but got "+h.dtype});var te,tr=h.shape[h.shape.length-1],to=h.size/tr;if(null!=g&&g<tr){var tu=h.shape.map(function(h){return 0}),tc=h.shape.map(function(h){return h});tc[h.shape.length-1]=g,te=h.slice(tu,tc),tr=g}else if(null!=g&&g>tr){var tl=h.shape.map(function(h){return h});tl[h.shape.length-1]=g-tr,te=h.concat(Gn(tl),h.shape.length-1),tr=g}else te=h;var th=te.zerosLike(),td=o0(tY(te,th).as2D(to,tr)),tf=Math.floor(tr/2)+1,tp=tJ(td),tv=tQ(td),tm=tp.split([tf,tr-tf],tp.shape.length-1),tg=tv.split([tf,tr-tf],tv.shape.length-1),ty=te.shape.slice();return ty[te.shape.length-1]=tf,tY(tm[0],tg[0]).reshape(ty)}}),o3=An({irfft_:function(h){var g=h.shape[h.shape.length-1],te=h.size/g;if(g<=2){var tr=h.as2D(te,g),to=o1(tr);return tJ(to)}var tu=[te,2*(g-1)],tc=tJ(h).as2D(te,g),tl=tQ(h).as2D(te,g),th=tc.slice([0,1],[te,g-2]).reverse(1),td=tl.slice([0,1],[te,g-2]).reverse(1).mul(On(-1));return tJ(to=o1(tr=tY(tc.concat(th,1),tl.concat(td,1)).as2D(tu[0],tu[1])))}}),o4=Object.freeze({fft:o0,ifft:o1,rfft:o2,irfft:o3}),o5=An({sparseToDense_:function(h,g,te,tr){void 0===tr&&(tr=0);var to=mn(h,"sparseIndices","sparseToDense","int32"),tu=mn(g,"sparseValues","sparseToDense"),tc=mn(tr,"defaultValue","sparseToDense",tu.dtype);return function(h,g,te,tr){if("int32"!==h.dtype)throw Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was "+h.dtype+".");if(h.rank>2)throw Error("sparseIndices should be a scalar, vector, or matrix, but got shape "+h.shape+".");var to=h.rank>0?h.shape[0]:1,tu=h.rank>1?h.shape[1]:1;if(te.length!==tu)throw Error("outputShape has incorrect number of elements:, "+te.length+", should be: "+tu+".");var tc=g.size;if(0!==g.rank&&(1!==g.rank||tc!==to))throw Error("sparseValues has incorrect shape "+g.shape+", should be [] or ["+to+"]");if(g.dtype!==tr.dtype)throw Error("sparseValues.dtype must match defaultValues.dtype")}(to,tu,te,tc),tM.runKernelFunc(function(h){return h.sparseToDense(to,tu,te,tc)},{$sparseIndices:to,$sparseValues:tu,$defaultValue:tc})}}),o6=An({gatherND_:function(h,g){var te=mn(g,"indices","gatherND","int32"),tr=mn(h,"x","gatherND");return tM.runKernelFunc(function(h){return h.gatherND(tr,te)},{x:tr,indices:te},null,"GatherNd")}}),o8=An({diag_:function(h){var g=mn(h,"x","diag").flatten(),te=h.shape.concat(h.shape);return tM.runKernelFunc(function(h){return h.diag(g)},{$x:g}).reshape(te)}}),o7=An({dropout_:function(h,g,te,tr){var to=mn(h,"x","dropout");if(C("float32"===to.dtype,function(){return"x has to be a floating point tensor since it's going to be scaled, but got a "+to.dtype+" tensor instead."}),C(g>=0&&g<1,function(){return"rate must be a float in the range [0, 1), but got "+g+"."}),0===g)return h instanceof tx?to.clone():to;var tu=function(h,g){if(null==g)return h.shape.slice();if(S(h.shape,g))return g;if(h.shape.length===g.length){for(var te=[],tr=0;tr<h.shape.length;tr++)null==g[tr]&&null!=h.shape[tr]?te.push(h.shape[tr]):te.push(g[tr]);return te}return g}(to,te),tc=1-g,tl=nO(tu,0,1,"float32",tr).add(tc).floor().div(tc);return to.mul(tl)}});function rh(h,g,te){for(var tr=1-h%2,to=new Float32Array(h),tu=0;tu<h;++tu){var tc=2*Math.PI*tu/(h+tr-1);to[tu]=g-te*Math.cos(tc)}return Mn(to,"float32")}var o9=An({hannWindow_:function(h){return rh(h,.5,.5)}}),an=An({hammingWindow_:function(h){return rh(h,.54,.46)}}),ar=An({frame_:function(h,g,te,tr,to){void 0===tr&&(tr=!1),void 0===to&&(to=0);for(var tu=0,tc=[];tu+g<=h.size;)tc.push(oE(h,tu,g)),tu+=te;if(tr)for(;tu<h.size;){var tl=tu+g-h.size,th=t1([oE(h,tu,g-tl),Hn([tl],to)]);tc.push(th),tu+=te}return 0===tc.length?Bn([],[0,g]):t1(tc).as2D(tc.length,g)}}),au=An({stft_:function(h,g,te,tr,to){void 0===to&&(to=o9),null==tr&&(tr=Math.floor(Math.pow(2,Math.ceil(Math.log(g)/Math.log(2)))));for(var tu=ar(h,g,te),tc=rB(tu,to(g)),tl=[],th=0;th<tu.shape[0];th++)tl.push(o2(tc.slice([th,0],[1,g]),tr));return t1(tl)}}),ac=Object.freeze({hannWindow:o9,hammingWindow:an,frame:ar,stft:au});(aA=ak||(ak={}))[aA.NONE=0]="NONE",aA[aA.MEAN=1]="MEAN",aA[aA.SUM=2]="SUM",aA[aA.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS";var al=An({absoluteDifference_:function(h,g,te,tr){void 0===tr&&(tr=ak.SUM_BY_NONZERO_WEIGHTS);var to=mn(h,"labels","absoluteDifference"),tu=mn(g,"predictions","absoluteDifference"),tc=null;return null!=te&&(tc=mn(te,"weights","absoluteDifference")),E(to.shape,tu.shape,"Error in absoluteDifference: "),ah(to.sub(tu).abs(),tc,tr)}}),ah=An({computeWeightedLoss_:function(h,g,te){void 0===te&&(te=ak.SUM_BY_NONZERO_WEIGHTS);var tr=mn(h,"losses","computeWeightedLoss"),to=null;null!=g&&(to=mn(g,"weights","computeWeightedLoss"));var tu=null==to?tr:tr.mul(to);if(te===ak.NONE)return tu;if(te===ak.SUM)return tu.sum();if(te===ak.MEAN){if(null==to)return tu.mean();var tc=tr.size/to.size,tl=tu.sum().div(to.sum());return tc>1?tl.div(On(tc)):tl}if(te===ak.SUM_BY_NONZERO_WEIGHTS){if(null==to)return tu.sum().div(On(tr.size));var th=to.mul(zn(tr.shape)).notEqual(On(0)).sum().toFloat();return tu.sum().div(th)}throw Error("Unknown reduction: "+te)}}),ad=An({cosineDistance_:function(h,g,te,tr,to){void 0===to&&(to=ak.SUM_BY_NONZERO_WEIGHTS);var tu=mn(h,"labels","cosineDistance"),tc=mn(g,"predictions","cosineDistance"),tl=null;return null!=tr&&(tl=mn(tr,"weights","cosineDistance")),E(tu.shape,tc.shape,"Error in cosineDistance: "),ah(On(1).sub(tu.mul(tc).sum(te,!0)),tl,to)}}),af=An({hingeLoss_:function(h,g,te,tr){void 0===tr&&(tr=ak.SUM_BY_NONZERO_WEIGHTS);var to=mn(h,"labels","hingeLoss"),tu=mn(g,"predictions","hingeLoss"),tc=null;null!=te&&(tc=mn(te,"weights","hingeLoss")),E(to.shape,tu.shape,"Error in hingeLoss: ");var tl=On(1);return to=On(2).mul(to).sub(tl),ah(tl.sub(to.mul(tu)).relu(),tc,tr)}}),ap=An({huberLoss_:function(h,g,te,tr,to){void 0===tr&&(tr=1),void 0===to&&(to=ak.SUM_BY_NONZERO_WEIGHTS);var tu=mn(h,"labels","huberLoss"),tc=mn(g,"predictions","huberLoss"),tl=null;null!=te&&(tl=mn(te,"weights","huberLoss")),E(tu.shape,tc.shape,"Error in huberLoss: ");var th=On(tr),td=tc.sub(tu).abs(),tf=rF(td,th),tp=td.sub(tf);return ah(On(.5).mul(tf.square()).add(th.mul(tp)),tl,to)}}),av=An({logLoss_:function(h,g,te,tr,to){void 0===tr&&(tr=1e-7),void 0===to&&(to=ak.SUM_BY_NONZERO_WEIGHTS);var tu=mn(h,"labels","logLoss"),tc=mn(g,"predictions","logLoss"),tl=null;null!=te&&(tl=mn(te,"weights","logLoss")),E(tu.shape,tc.shape,"Error in logLoss: ");var th=On(1),td=On(tr);return ah(tu.mul(tc.add(td).log()).neg().sub(th.sub(tu).mul(th.sub(tc).add(td).log())),tl,to)}}),am=An({meanSquaredError_:function(h,g,te,tr){void 0===tr&&(tr=ak.SUM_BY_NONZERO_WEIGHTS);var to=mn(h,"labels","meanSquaredError"),tu=mn(g,"predictions","meanSquaredError"),tc=null;return null!=te&&(tc=mn(te,"weights","meanSquaredError")),E(to.shape,tu.shape,"Error in meanSquaredError: "),ah(to.squaredDifference(tu),tc,tr)}}),ag=An({sigmoidCrossEntropy_:function(h,g,te,tr,to){void 0===tr&&(tr=0),void 0===to&&(to=ak.SUM_BY_NONZERO_WEIGHTS);var tu,tc,tl,th,td,tf=mn(h,"multiClassLabels","sigmoidCrossEntropy"),tp=mn(g,"logits","sigmoidCrossEntropy"),tv=null;if(null!=te&&(tv=mn(te,"weights","sigmoidCrossEntropy")),E(tf.shape,tp.shape,"Error in sigmoidCrossEntropy: "),tr>0){var tm=On(tr),tg=On(1),ty=On(.5);tf=tf.mul(tg.sub(tm)).add(ty.mul(tm))}return ah((tu=mn(tf,"labels","sigmoidCrossEntropyWithLogits"),tc=mn(tp,"logits","sigmoidCrossEntropyWithLogits"),E(tu.shape,tc.shape,"Error in sigmoidCrossEntropyWithLogits: "),tl=tc.relu(),th=tc.mul(tu),td=tc.abs().neg().exp().log1p(),tl.sub(th).add(td)),tv,to)}}),ay=An({softmaxCrossEntropy_:function(h,g,te,tr,to){void 0===tr&&(tr=0),void 0===to&&(to=ak.SUM_BY_NONZERO_WEIGHTS);var tu=mn(h,"onehotLabels","softmaxCrossEntropy"),tc=mn(g,"logits","softmaxCrossEntropy"),tl=null;if(null!=te&&(tl=mn(te,"weights","softmaxCrossEntropy")),E(tu.shape,tc.shape,"Error in softmaxCrossEntropy: "),tr>0){var th=On(tr),td=On(1),tf=On(tu.shape[1]);tu=tu.mul(td.sub(th)).add(th.div(tf))}return ah(function(h,g,te){if(void 0===te&&(te=-1),-1===te&&(te=g.rank-1),te!==g.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank "+g.rank+" and dim was "+te);return vo(function(h,g,tr){var to=g.logSumExp([te],!0),tu=g.toFloat().sub(to);return tr([h,tu]),{value:tu.mul(h).neg().sum([te]),gradFunc:function(h,g){var tr=g[0],to=g[1],tu=wn(h.shape,[te]);return[h.reshape(tu).mul(tr.toFloat().sub(to.exp())),h.reshape(tu).mul(to.exp().sub(tr.toFloat()))]}}})(h,g)}(tu,tc),tl,to)}}),ax=Object.freeze({get Reduction(){return ak},absoluteDifference:al,computeWeightedLoss:ah,cosineDistance:ad,hingeLoss:af,huberLoss:ap,logLoss:av,meanSquaredError:am,sigmoidCrossEntropy:ag,softmaxCrossEntropy:ay});function wh(h,g){return void 0===g&&(g=!1),tM.tidy(function(){if(2!==h.shape.length)throw Error("qr2d() requires a 2D Tensor, but got a "+h.shape.length+"D Tensor.");for(var te=h.shape[0],tr=h.shape[1],to=nw(te),tu=h.clone(),tc=Bn([[1]],[1,1]),tl=tc.clone(),th=te>=tr?tr:te,c=function(h){var g,th=tu,td=tl,tf=to;tl=(g=tM.tidy(function(){var g=tu.slice([h,h],[te-h,1]),th=g.norm(),td=tu.slice([h,h],[1,1]),tf=Bn([[-1]]).where(td.greater(0),Bn([[1]])),tp=td.sub(tf.mul(th)),tv=g.div(tp);tl=1===tv.shape[0]?tc.clone():tc.concat(tv.slice([1,0],[tv.shape[0]-1,tv.shape[1]]),0);var tm=tf.matMul(tp).div(th).neg(),tg=tu.slice([h,0],[te-h,tr]),ty=tm.mul(tl);if(0===h)tu=tg.sub(ty.matMul(tl.transpose().matMul(tg)));else{var tx=tg.sub(ty.matMul(tl.transpose().matMul(tg)));tu=tu.slice([0,0],[h,tr]).concat(tx,0)}var tb=to.slice([0,h],[te,to.shape[1]-h]);if(0===h)to=tb.sub(tb.matMul(tl).matMul(ty.transpose()));else{var tC=tb.sub(tb.matMul(tl).matMul(ty.transpose()));to=to.slice([0,0],[te,h]).concat(tC,1)}return[tl,tu,to]}))[0],tu=g[1],to=g[2],tn([th,td,tf])},td=0;td<th;++td)c(td);return!g&&te>tr&&(to=to.slice([0,0],[te,tr]),tu=tu.slice([0,0],[tr,tr])),[to,tu]})}var ab=Object.freeze({bandPart:An({bandPart_:function(h,g,te){if(g%1!=0)throw Error("bandPart(): numLower must be an integer, got "+g+".");if(te%1!=0)throw Error("bandPart(): numUpper must be an integer, got "+te+".");var tr=mn(h,"a","bandPart");if(tr.rank<2)throw Error("bandPart(): Rank must be at least 2, got "+tr.rank+".");var to=tr.shape,tu=tr.shape.slice(-2),tc=tu[0],tl=tu[1];if(!(g<=tc))throw Error("bandPart(): numLower ("+g+") must not be greater than the number of rows ("+tc+").");if(!(te<=tl))throw Error("bandPart(): numUpper ("+te+") must not be greater than the number of columns ("+tl+").");g<0&&(g=tc),te<0&&(te=tl);var th=rU(Kn(0,tc,1,"int32").reshape([-1,1]),Kn(0,tl,1,"int32")),td=rg(th.lessEqual(On(+g,"int32")),th.greaterEqual(On(-te,"int32"))),tf=Gn([tc,tl],tr.dtype);return nP(nV(tr.reshape([-1,tc,tl])).map(function(h){return rC(td,h,tf)})).reshape(to)}}),gramSchmidt:An({gramSchmidt_:function(h){if(Array.isArray(h)){g=!1,C(null!=h&&h.length>0,function(){return"Gram-Schmidt process: input must not be null, undefined, or empty"});for(var g,te=h[0].shape[0],r=function(g){C(h[g].shape[0]===te,function(){return"Gram-Schmidt: Non-unique lengths found in the input vectors: ("+h[g].shape[0]+" vs. "+te+")"})},tr=1;tr<h.length;++tr)r(tr)}else g=!0,h=t6(h,h.shape[0],0).map(function(h){return nB(h,[0])});C(h.length<=h[0].shape[0],function(){return"Gram-Schmidt: Number of vectors ("+h.length+") exceeds number of dimensions ("+h[0].shape[0]+")."});var to=[],tu=h,s=function(h){to.push(tM.tidy(function(){var g=tu[h];if(h>0)for(var te=0;te<h;++te){var tr=oP(to[te].mulStrict(g)).mul(to[te]);g=g.sub(tr)}return g.div(oj(g,"euclidean"))}))};for(tr=0;tr<h.length;++tr)s(tr);return g?nP(to,0):to}}),qr:An({qr_:function(h,g){if(void 0===g&&(g=!1),h.rank<2)throw Error("qr() requires input tensor to have a rank >= 2, but got rank "+h.rank);if(2===h.rank)return wh(h,g);var te=h.shape.slice(0,h.shape.length-2).reduce(function(h,g){return h*g}),tr=nV(h.reshape([te,h.shape[h.shape.length-2],h.shape[h.shape.length-1]]),0),to=[],tu=[];return tr.forEach(function(h){var te=wh(h,g),tr=te[0],tc=te[1];to.push(tr),tu.push(tc)}),[nP(to,0).reshape(h.shape),nP(tu,0).reshape(h.shape)]}})});function kh(h,g,te,tr,to,tu){null==tr&&(tr=.5),null==to&&(to=Number.NEGATIVE_INFINITY),null==tu&&(tu=0);var tc=h.shape[0];return te=Math.min(te,tc),C(0<=tr&&tr<=1,function(){return"iouThreshold must be in [0, 1], but was '"+tr+"'"}),C(2===h.rank,function(){return"boxes must be a 2D tensor, but was of rank '"+h.rank+"'"}),C(4===h.shape[1],function(){return"boxes must have 4 columns, but 2nd dimension was "+h.shape[1]}),C(1===g.rank,function(){return"scores must be a 1D tensor"}),C(g.shape[0]===tc,function(){return"scores has incompatible shape with boxes. Expected "+tc+", but was "+g.shape[0]}),C(0<=tu&&tu<=1,function(){return"softNmsSigma must be in [0, 1], but was '"+tu+"'"}),{maxOutputSize:te,iouThreshold:tr,scoreThreshold:to,softNmsSigma:tu}}var aC=Object.freeze({resizeBilinear:An({resizeBilinear_:function(h,g,te){void 0===te&&(te=!1);var tr=mn(h,"images","resizeBilinear");C(3===tr.rank||4===tr.rank,function(){return"Error in resizeBilinear: x must be rank 3 or 4, but got rank "+tr.rank+"."}),C(2===g.length,function(){return"Error in resizeBilinear: new shape must 2D, but got shape "+g+"."});var to=tr,tu=!1;3===tr.rank&&(tu=!0,to=tr.as4D(1,tr.shape[0],tr.shape[1],tr.shape[2]));var tc=g[0],tl=g[1],th=tM.runKernelFunc(function(h,g){return g([to]),h.resizeBilinear(to,tc,tl,te)},{x:to},function(h,g){return{x:function(){return tM.runKernelFunc(function(tr){return tr.resizeBilinearBackprop(h,g[0],te)},{})}}},"ResizeBilinear",{alignCorners:te,newHeight:tc,newWidth:tl});return tu?th.as3D(th.shape[1],th.shape[2],th.shape[3]):th}}),resizeNearestNeighbor:An({resizeNearestNeighbor_:function(h,g,te){void 0===te&&(te=!1);var tr=mn(h,"images","resizeNearestNeighbor");C(3===tr.rank||4===tr.rank,function(){return"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank "+tr.rank+"."}),C(2===g.length,function(){return"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+g+"."}),C("float32"===tr.dtype||"int32"===tr.dtype,function(){return"`images` must have `int32` or `float32` as dtype"});var to=tr,tu=!1;3===tr.rank&&(tu=!0,to=tr.as4D(1,tr.shape[0],tr.shape[1],tr.shape[2]));var tc=g[0],tl=g[1],th=tM.runKernelFunc(function(h,g){return g([to]),h.resizeNearestNeighbor(to,tc,tl,te)},{batchImages:to},function(h,g){return{batchImages:function(){return tM.runKernelFunc(function(tr){return tr.resizeNearestNeighborBackprop(h,g[0],te)},{})}}});return tu?th.as3D(th.shape[1],th.shape[2],th.shape[3]):th}}),nonMaxSuppression:An({nonMaxSuppression_:function(h,g,te,tr,to){void 0===tr&&(tr=.5),void 0===to&&(to=Number.NEGATIVE_INFINITY);var tu=mn(h,"boxes","nonMaxSuppression"),tc=mn(g,"scores","nonMaxSuppression"),tl=kh(tu,tc,te,tr,to);te=tl.maxOutputSize,tr=tl.iouThreshold,to=tl.scoreThreshold;var th={maxOutputSize:te,iouThreshold:tr,scoreThreshold:to};return tM.runKernelFunc(function(h){return h.nonMaxSuppression(tu,tc,te,tr,to)},{boxes:tu,scores:tc},null,"NonMaxSuppressionV3",th)}}),nonMaxSuppressionAsync:function(h,g,te,tr,to){return void 0===tr&&(tr=.5),void 0===to&&(to=Number.NEGATIVE_INFINITY),n(this,void 0,void 0,function(){var tu,tc,tl,th,td;return r(this,function(tf){switch(tf.label){case 0:return tu=mn(h,"boxes","nonMaxSuppressionAsync"),tc=mn(g,"scores","nonMaxSuppressionAsync"),te=(tl=kh(tu,tc,te,tr,to)).maxOutputSize,tr=tl.iouThreshold,to=tl.scoreThreshold,[4,Promise.all([tu.data(),tc.data()])];case 1:return td=jo((th=tf.sent())[0],th[1],te,tr,to),tu!==h&&tu.dispose(),tc!==g&&tc.dispose(),[2,td]}})})},nonMaxSuppressionWithScore:An({nonMaxSuppressionWithScore_:function(h,g,te,tr,to,tu){void 0===tr&&(tr=.5),void 0===to&&(to=Number.NEGATIVE_INFINITY),void 0===tu&&(tu=0);var tc=mn(h,"boxes","nonMaxSuppression"),tl=mn(g,"scores","nonMaxSuppression"),th=kh(tc,tl,te,tr,to,tu),td={maxOutputSize:te=th.maxOutputSize,iouThreshold:tr=th.iouThreshold,scoreThreshold:to=th.scoreThreshold,softNmsSigma:tu=th.softNmsSigma},tf=tM.runKernel("NonMaxSuppressionV5",{boxes:tc,scores:tl},td);return{selectedIndices:tf[0],selectedScores:tf[1]}}}),nonMaxSuppressionWithScoreAsync:function(h,g,te,tr,to,tu){return void 0===tr&&(tr=.5),void 0===to&&(to=Number.NEGATIVE_INFINITY),void 0===tu&&(tu=0),n(this,void 0,void 0,function(){var tc,tl,th,td,tf;return r(this,function(tp){switch(tp.label){case 0:return tc=mn(h,"boxes","nonMaxSuppressionAsync"),tl=mn(g,"scores","nonMaxSuppressionAsync"),te=(th=kh(tc,tl,te,tr,to,tu)).maxOutputSize,tr=th.iouThreshold,to=th.scoreThreshold,tu=th.softNmsSigma,[4,Promise.all([tc.data(),tl.data()])];case 1:return tf=Xo((td=tp.sent())[0],td[1],te,tr,to,tu),tc!==h&&tc.dispose(),tl!==g&&tl.dispose(),[2,tf]}})})},cropAndResize:An({cropAndResize_:function(h,g,te,tr,to,tu){var tc=mn(h,"image","cropAndResize"),tl=mn(g,"boxes","cropAndResize","float32"),th=mn(te,"boxInd","cropAndResize","int32");to=to||"bilinear",tu=tu||0;var td=tl.shape[0];return C(4===tc.rank,function(){return"Error in cropAndResize: image must be rank 4,but got rank "+tc.rank+"."}),C(2===tl.rank&&4===tl.shape[1],function(){return"Error in cropAndResize: boxes must be have size ["+td+",4] but had shape "+tl.shape+"."}),C(1===th.rank&&th.shape[0]===td,function(){return"Error in cropAndResize: boxInd must be have size ["+td+"] but had shape "+tl.shape+"."}),C(2===tr.length,function(){return"Error in cropAndResize: cropSize must be of length 2, but got length "+tr.length+"."}),C(tr[0]>=1&&tr[1]>=1,function(){return"cropSize must be atleast [1,1], but was "+tr}),C("bilinear"===to||"nearest"===to,function(){return"method must be bilinear or nearest, but was "+to}),tM.runKernelFunc(function(h,g){return h.cropAndResize(tc,tl,th,tr,to,tu)},{images:tc,boxes:tl,boxInd:th},null,"CropAndResize",{method:to,extrapolationValue:tu,cropSize:tr})}})}),Mh=function(h,g){return!(h>0)||"linear"===g},Bh=function(h,g,te){if(null==te||"linear"===te)return h;if("relu"===te)return h.mul(g.step());throw Error("Gradient for activation "+te+" has not been implemented yet.")},Ph=function(h,g){var te=g,tr=Eo(h.shape,g.shape);return tr.length>0&&(te=te.sum(tr)),te.reshape(h.shape)},Lh=function(h,g,te){if("linear"===g)return h;if("relu"===g)return oz(h);if("elu"===g)return oW(h);if("relu6"===g)return oH(h);if("prelu"===g)return oU(h,te);throw Error("Unknown fused activation "+g+".")},aw=Object.freeze({image:aC,linalg:ab,losses:ax,spectral:o4,fused:Object.freeze({matMul:An({fusedMatMul_:function(h){var g,te=h.a,tr=h.b,to=h.transposeA,tu=void 0!==to&&to,tc=h.transposeB,tl=void 0!==tc&&tc,th=h.bias,td=h.activation,tf=void 0===td?"linear":td,tp=h.preluActivationWeights;if(!1===Mh(tM.state.gradientDepth,tf)){var tv=ol(te,tr,tu,tl);return null!=th&&(tv=rw(tv,th)),Lh(tv,tf,tp)}var tm=mn(te,"a","fused matMul"),tg=mn(tr,"b","fused matMul");tm=(g=Nt(tm,tg))[0],tg=g[1];var ty=tu?tm.shape[tm.rank-2]:tm.shape[tm.rank-1],tx=tl?tg.shape[tg.rank-1]:tg.shape[tg.rank-2],tb=tu?tm.shape[tm.rank-1]:tm.shape[tm.rank-2],tC=tl?tg.shape[tg.rank-2]:tg.shape[tg.rank-1],tw=tm.shape.slice(0,-2),tE=tg.shape.slice(0,-2),tR=k(tw),tI=k(tE);C(tm.rank>=2&&tg.rank>=2&&tm.rank===tg.rank,function(){return"Error in fused matMul: inputs must have the same rank of at least 2, got ranks "+tm.rank+" and "+tg.rank+"."}),C(S(tw,tE),function(){return"Error in fused matMul: outer dimensions ("+tw+") and ("+tE+") of Tensors with shapes "+tm.shape+" and "+tg.shape+" must match."}),C(ty===tx,function(){return"Error in fused matMul: inner shapes ("+ty+") and ("+tx+") of Tensors with shapes "+tm.shape+" and "+tg.shape+" and transposeA="+tu+" and transposeB="+tl+" must match."});var tk,tA,tS=tm.shape.slice(0,-2).concat([tb,tC]),tD=tu?tm.as3D(tR,ty,tb):tm.as3D(tR,tb,ty),tN=tl?tg.as3D(tI,tC,tx):tg.as3D(tI,tx,tC);null!=th&&Ro(tS,(tk=Nt(tk=mn(th,"bias","fused matMul"),tm)[0]).shape),null!=tp&&(tA=mn(tp,"prelu weights","fused matMul"));var tT={a:tD,b:tN};null!=th&&(tT.bias=tk),null!=tp&&(tT.preluActivationWeights=tA);var tF=[tD,tN];return tM.runKernelFunc(function(h,g){var te=h.fusedBatchMatMul({a:tD,b:tN,transposeA:tu,transposeB:tl,bias:tk,activation:tf,preluActivationWeights:tA});return g([tD,tN,te]),te},tT,function(h,g){var te=g[0],tr=g[1],to=Bh(h,g[2],tf),tc={};return null!=th&&(tc={bias:function(){return Ph(tk,to)}}),tu||tl?!tu&&tl?Object.assign({a:function(){return to.matMul(tr,!1,!1)},b:function(){return to.matMul(te,!0,!1)}},tc):tu&&!tl?Object.assign({a:function(){return tr.matMul(to,!1,!0)},b:function(){return te.matMul(to,!1,!1)}},tc):Object.assign({a:function(){return tr.matMul(to,!0,!0)},b:function(){return to.matMul(te,!0,!0)}},tc):Object.assign({a:function(){return to.matMul(tr,!1,!0)},b:function(){return te.matMul(to,!0,!1)}},tc)},"_FusedMatMul",{transposeA:tu,transposeB:tl,activation:tf},tF,[!0]).reshape(tS)}}),conv2d:An({fusedConv2d_:function(h){var g=h.x,te=h.filter,tr=h.strides,to=h.pad,tu=h.dataFormat,tc=void 0===tu?"NHWC":tu,tl=h.dilations,th=void 0===tl?[1,1]:tl,td=h.dimRoundingMode,tf=h.bias,tp=h.activation,tv=void 0===tp?"linear":tp,tm=h.preluActivationWeights;if(tv=tv||"linear",!1===Mh(tM.state.gradientDepth,tv)){var tg=r4(g,te,tr,to,tc,th,td);return null!=tf&&(tg=rw(tg,tf)),Lh(tg,tv,tm)}var ty=mn(g,"x","conv2d"),tx=mn(te,"filter","conv2d"),tb=ty,tC=!1;3===ty.rank&&(tC=!0,tb=ty.as4D(1,ty.shape[0],ty.shape[1],ty.shape[2])),C(4===tb.rank,function(){return"Error in fused conv2d: input must be rank 4, but got rank "+tb.rank+"."}),C(4===tx.rank,function(){return"Error in fused conv2d: filter must be rank 4, but got rank "+tx.rank+"."}),null!=td&&C(A(to),function(){return"Error in fused conv2d: pad must be an integer when using, dimRoundingMode "+td+" but got pad "+to+"."}),C(tb.shape[3]===tx.shape[2],function(){return"Error in conv2d: depth of input ("+tb.shape[3]+") must match input depth for filter "+tx.shape[2]+"."}),C(Mo(tr,th),function(){return"Error in conv2D: Either strides or dilations must be 1. Got strides "+tr+" and dilations '"+th+"'"}),C("NHWC"===tc,function(){return"Error in conv2d: got dataFormat of "+tc+" but only NHWC is currently supported."});var tw,tE,tR=So(tb.shape,tx.shape,tr,th,to,td);null!=tf&&(tw=Nt(tw=mn(tf,"bias","fused conv2d"),ty)[0],Ro(tR.outShape,tw.shape)),null!=tm&&(tE=mn(tm,"prelu weights","fused conv2d"));var tI={x:tb,filter:tx};null!=tf&&(tI.bias=tw),null!=tm&&(tI.preluActivationWeights=tE);var tk=[tx,tb],tA=tM.runKernelFunc(function(h,g){var te=h.fusedConv2d({input:tb,filter:tx,convInfo:tR,bias:tw,activation:tv,preluActivationWeights:tE});return g([tx,tb,te]),te},tI,function(h,g){var te=g[0],tu=g[1],tc=Bh(h,g[2],tv);C(Oo(th),function(){return"Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+th+"'"});var tl={};return null!=tf&&(tl={bias:function(){return Ph(tw,tc)}}),Object.assign({x:function(){return r8(tu.shape,tc,te,tr,to)},filter:function(){return r6(tu,tc,te.shape,tr,to)}},tl)},"FusedConv2D",{convInfo:tR,activation:tv},tk,[!0]);return tC?tA.as3D(tA.shape[1],tA.shape[2],tA.shape[3]):tA}}),depthwiseConv2d:An({fusedDepthwiseConv2d_:function(h){var g=h.x,te=h.filter,tr=h.strides,to=h.pad,tu=h.dataFormat,tc=h.dilations,tl=void 0===tc?[1,1]:tc,th=h.dimRoundingMode,td=h.bias,tf=h.activation,tp=void 0===tf?"linear":tf,tv=h.preluActivationWeights;if(!1===Mh(tM.state.gradientDepth,tp)){var tm=r7(g,te,tr,to,void 0===tu?"NHWC":tu,tl,th);return null!=td&&(tm=rw(tm,td)),Lh(tm,tp,tv)}var tg=mn(g,"x","depthwiseConv2d"),ty=mn(te,"filter","depthwiseConv2d"),tx=tg,tb=!1;3===tg.rank&&(tb=!0,tx=tg.as4D(1,tg.shape[0],tg.shape[1],tg.shape[2])),C(4===tx.rank,function(){return"Error in fused depthwiseConv2d: input must be rank 4, but got rank "+tx.rank+"."}),C(4===ty.rank,function(){return"Error in fused depthwiseConv2d: filter must be rank 4, but got rank "+ty.rank+"."}),C(tx.shape[3]===ty.shape[2],function(){return"Error in fused depthwiseConv2d: number of input channels ("+tx.shape[3]+") must match the inChannels dimension in filter "+ty.shape[2]+"."}),null==tl&&(tl=[1,1]),C(Mo(tr,tl),function(){return"Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides "+tr+" and dilations '"+tl+"'"}),null!=th&&C(A(to),function(){return"Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode "+th+" but got pad "+to+"."});var tC,tw,tE=So(tx.shape,ty.shape,tr,tl,to,th,!0);null!=td&&(tC=Nt(tC=mn(td,"bias","fused conv2d"),tg)[0],Ro(tE.outShape,tC.shape)),null!=tv&&(tw=mn(tv,"prelu weights","fused depthwiseConv2d"));var tR={x:tx,filter:ty};null!=td&&(tR.bias=tC),null!=tv&&(tR.preluActivationWeights=tw);var tI=[ty,tx],tk=tM.runKernelFunc(function(h,g){var te=h.fusedDepthwiseConv2D({input:tx,filter:ty,convInfo:tE,bias:tC,activation:tp,preluActivationWeights:tw});return g([ty,tx,te]),te},tR,function(h,g){C(Oo(tl),function(){return"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+tl+"'"});var te=g[0],tr=g[1],to=Bh(h,g[2],tp),tu={};return null!=td&&(tu={bias:function(){return Ph(tC,to)}}),Object.assign({x:function(){return r9(tr.shape,to,te,tE)},filter:function(){return on(tr,to,te.shape,tE)}},tu)},"FusedDepthwiseConv2D",{convInfo:tE,activation:tp},tI,[!0]);return tb?tk.as3D(tk.shape[1],tk.shape[2],tk.shape[3]):tk}})}),signal:ac,square:eD,squaredDifference:eT,conv1d:r3,conv2d:r4,conv3d:r5,depthwiseConv2d:r7,separableConv2d:or,conv2dTranspose:ou,conv3dTranspose:oc,op:An,batchNormalization2d:ru,batchNormalization3d:rc,batchNormalization4d:rl,batchNormalization:rd,batchNorm:rf,batchNorm2d:rp,batchNorm3d:rv,batchNorm4d:rm,booleanMaskAsync:function(h,g,te){return n(this,void 0,void 0,function(){var tr,to,tu,tc,tl,th,td,tf,tp,tv,tm,tg,ty;return r(this,function(tx){switch(tx.label){case 0:for(tr=mn(h,"tensor","boolMask"),to=mn(g,"mask","boolMask","bool"),tu=null==te?0:te,tc=to.rank,tl=tr.shape,C(tc>0,function(){return"mask cannot be scalar"}),E(tl.slice(tu,tu+tc),to.shape,"mask's shape must match the first K dimensions of tensor's shape,"),th=1,td=tu;td<tu+tc;td++)th*=tl[td];return tf=tl.slice(0,tu).concat([th],tl.slice(tu+tc)),tp=tr.reshape(tf),[4,nc(tv=to.reshape([-1]))];case 1:return tg=(tm=tx.sent()).squeeze([1]),ty=r1(tp,tg,tu),h!==tr&&tr.dispose(),g!==to&&to.dispose(),tg.dispose(),tp.dispose(),tv.dispose(),tm.dispose(),[2,ty]}})})},complex:tY,real:tJ,imag:tQ,concat:t1,concat1d:t2,concat2d:t3,concat3d:t4,concat4d:t5,split:t6,matMul:ol,dot:oh,outerProduct:od,reverse:of,reverse1d:op,reverse2d:ov,reverse3d:om,reverse4d:og,maxPool:oy,avgPool:ox,pool:ob,maxPool3d:oC,avgPool3d:ow,slice:oE,slice1d:oR,slice2d:oI,slice3d:ok,slice4d:oA,abs:eF,acos:eO,acosh:e_,asin:eM,asinh:eB,atan:eP,atanh:eL,ceil:eW,clipByValue:eV,cos:eU,cosh:ez,erf:eH,exp:eG,expm1:eq,floor:eK,log:ej,log1p:eX,logSigmoid:e$,neg:eY,reciprocal:eJ,round:eQ,rsqrt:eZ,sigmoid:e0,sign:e1,isNaN:e2,isInf:e3,isFinite:e4,sin:e5,sinh:e6,softplus:e8,sqrt:e7,step:e9,tan:rn,tanh:rr,all:oS,any:oD,argMax:oN,argMin:oT,logSumExp:oF,max:oO,mean:o_,min:oM,moments:oB,sum:oP,prod:oL,equal:rH,equalStrict:rG,greater:rq,greaterEqual:rK,greaterEqualStrict:rj,greaterStrict:rX,less:r$,lessEqual:rY,lessEqualStrict:rJ,lessStrict:rQ,notEqual:rZ,notEqualStrict:r0,add:rw,addN:rE,addStrict:rR,atan2:rI,div:rk,divNoNan:rA,divStrict:rS,floorDiv:rD,maximum:rN,maximumStrict:rT,minimum:rF,minimumStrict:rO,mod:r_,modStrict:rM,mul:rB,mulStrict:rP,pow:rL,powStrict:rW,squaredDifferenceStrict:rV,sub:rU,subStrict:rz,elu:oW,leakyRelu:oV,prelu:oU,relu:oz,relu6:oH,selu:oG,logicalAnd:rg,logicalNot:ry,logicalOr:rx,logicalXor:rb,where:rC,whereAsync:nc,buffer:dr,print:function(h,g){void 0===g&&(g=!1),console.log(h.toString(g))},batchToSpaceND:nv,broadcastTo:nm,cast:ng,clone:ny,cumsum:nx,depthToSpace:nb,expandDims:nC,eye:nw,multinomial:nE,oneHot:nR,pad:nI,pad1d:nk,pad2d:nA,pad3d:nS,pad4d:nD,rand:nN,randomNormal:nT,randomGamma:nF,randomUniform:nO,reshape:n_,spaceToBatchND:nM,squeeze:nB,stack:nP,tile:nL,truncatedNormal:nW,unstack:nV,setdiff1dAsync:function(h,g){return n(this,void 0,void 0,function(){var te,tr,to,tu,tc,tl,th,td,tf,tp;return r(this,function(tm){switch(tm.label){case 0:return te=mn(h,"x","setdiff1d"),tr=mn(g,"y","setdiff1d"),C(te.dtype===tr.dtype,function(){return"x and y should have the same dtype, but got x ("+te.dtype+") and y ("+tr.dtype+")."}),C(1===te.rank,function(){return"x should be 1D tensor, but got x ("+te.shape+")."}),C(1===tr.rank,function(){return"y should be 1D tensor, but got y ("+tr.shape+")."}),[4,te.data()];case 1:return to=tm.sent(),[4,tr.data()];case 2:for(tu=tm.sent(),tc=new Set(tu),tl=0,tf=0;tf<to.length;tf++)tc.has(to[tf])||tl++;for(th=new tv([tl],te.dtype),td=new tv([tl],"int32"),tf=0,tp=0;tf<to.length;tf++)tc.has(to[tf])||(th.values[tp]=to[tf],td.values[tp]=tf,tp++);return[2,[th.toTensor(),td.toTensor()]]}})})},fill:Hn,linspace:function(h,g,te){if(te<=0)throw Error("The number of values should be positive.");return tM.runKernelFunc(function(tr){return tr.linspace(h,g,te)},{})},ones:zn,range:Kn,scalar:On,tensor:Fn,tensor1d:Mn,tensor2d:Bn,tensor3d:Pn,tensor4d:Ln,tensor5d:function(h,g,te){if(R(h),null!=g&&5!==g.length)throw Error("tensor5d() requires shape to have five numbers");var tr=pn(h,te);if(5!==tr.length&&1!==tr.length)throw Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===tr.length&&null==g)throw Error("tensor5d() requires shape to be provided when `values` are a flat array");return _n(h,g,tr,te)},tensor6d:function(h,g,te){if(R(h),null!=g&&6!==g.length)throw Error("tensor6d() requires shape to have six numbers");var tr=pn(h,te);if(6!==tr.length&&1!==tr.length)throw Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===tr.length&&null==g)throw Error("tensor6d() requires shape to be provided when `values` are a flat array");return _n(h,g=g||tr,tr,te)},variable:function(h,g,te,tr){return void 0===g&&(g=!0),tM.makeVariable(h,g,te,tr)},zeros:Gn,onesLike:tZ,zerosLike:t0,transpose:oq,softmax:nU,logSoftmax:nz,localResponseNormalization:oK,norm:oj,gather:r1,unsortedSegmentSum:r2,basicLSTMCell:oX,multiRNNCell:o$,movingAverage:oY,stridedSlice:oJ,topk:oQ,scatterND:oZ,fft:o0,ifft:o1,rfft:o2,irfft:o3,sparseToDense:o5,gatherND:o6,diag:o8,dropout:o7,hannWindow:o9,hammingWindow:an,frame:ar,stft:au,inTopKAsync:function(h,g,te){return void 0===te&&(te=1),n(this,void 0,void 0,function(){var tr,to,tu,tc,tl,th,td,tf,tp,tv,tm,tg,ty,tx;return r(this,function(tb){switch(tb.label){case 0:return tr=mn(h,"predictions","inTopK"),to=mn(g,"targets","inTopK"),C(tr.rank>1,function(){return"inTopK() expects the predictions to be of rank 2 or higher, but got "+tr.rank}),C(tr.rank-1===to.rank,function(){return"predictions rank should be 1 larger than targets rank, but got predictions rank "+tr.rank+" and targets rank "+to.rank}),E(tr.shape.slice(0,tr.shape.length-1),to.shape,"predictions's shape should be align with the targets' shape, except the last dimension."),tu=tr.shape[tr.shape.length-1],C(te>0&&te<=tu,function(){return"'k' passed to inTopK() must be > 0 && <= the predictions last dimension ("+tu+"), but got "+te}),[4,tr.data()];case 1:return tc=tb.sent(),[4,to.data()];case 2:for(tl=tb.sent(),tf=(th=[tc.length/tu,tu])[1],tp=B("bool",td=th[0]),tv=0;tv<td;tv++){for(tm=tv*tf,tg=tc.subarray(tm,tm+tf),ty=[],tx=0;tx<tg.length;tx++)ty.push({value:tg[tx],index:tx});for(ty.sort(function(h,g){return g.value-h.value}),tp[tv]=0,tx=0;tx<te;tx++)if(ty[tx].index===tl[tv]){tp[tv]=1;break}}return h!==tr&&tr.dispose(),g!==to&&to.dispose(),[2,Fn(tp,to.shape,"bool")]}})})}});function Hh(h,g){Array.isArray(h)||(h=[h]),h.forEach(function(h){null!=h&&C("complex64"!==h.dtype,function(){return g+" does not support complex64 tensors."})})}function qh(h,g,te,tr){if("linear"===te)return h.linear(g);if("relu"===te)return h.relu(g);if("elu"===te)return h.elu(g);if("relu6"===te)return h.relu6(g);if("prelu"===te)return h.prelu(g,tr);throw Error("Activation "+te+" has not been implemented for the CPU backend.")}var aE=function(h){function o(){var g=h.call(this)||this;return g.blockSize=48,g.firstUse=!0,g.data=new nH(g,tM),g}return e(o,h),o.prototype.write=function(h,g,te){this.firstUse&&(this.firstUse=!1,tl.get("IS_NODE")&&dn("\n============================\nHi there \uD83D\uDC4B. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));var tr={};return this.data.set(tr,{values:h,dtype:te}),tr},o.prototype.move=function(h,g,te,tr){this.data.set(h,{values:g,dtype:tr})},o.prototype.numDataIds=function(){return this.data.numDataIds()},o.prototype.read=function(h){return n(this,void 0,void 0,function(){return r(this,function(g){return[2,this.readSync(h)]})})},o.prototype.readSync=function(h){var g=this.data.get(h),te=g.dtype,tr=g.complexTensors;return"complex64"===te?Vo(this.readSync(tr.real.dataId),this.readSync(tr.imag.dataId)):this.data.get(h).values},o.prototype.bufferSync=function(h){var g=this.readSync(h.dataId),te=g;if("string"===h.dtype)try{te=g.map(function(h){return ot(h)})}catch(h){throw Error("Failed to decode encoded string bytes into utf-8")}return dr(h.shape,h.dtype,te)},o.prototype.makeOutput=function(h,g,te){var tr=this.write(h,g,te);return tM.makeTensorFromDataId(tr,g,te,this)},o.prototype.disposeData=function(h){if(this.data.has(h)){var g=this.data.get(h).complexTensors;null!=g&&(g.real.dispose(),g.imag.dispose()),this.data.delete(h)}},o.prototype.time=function(h){return n(this,void 0,void 0,function(){var g;return r(this,function(te){return g=et(),h(),[2,{kernelMs:et()-g}]})})},o.prototype.memory=function(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}},o.prototype.complex=function(h,g){var te=this.makeOutput(null,h.shape,"complex64");return this.data.get(te.dataId).complexTensors={real:tM.keep(h.clone()),imag:tM.keep(g.clone())},te},o.prototype.real=function(h){return this.data.get(h.dataId).complexTensors.real.clone()},o.prototype.imag=function(h){return this.data.get(h.dataId).complexTensors.imag.clone()},o.prototype.slice=function(h,g,te){if(Hh(h,"slice"),io(h.shape,g,te)){var tr=so(g,h.strides),to=k(te);return Fn(this.readSync(h.dataId).subarray(tr,tr+to),te,h.dtype)}for(var tu=dr(te,h.dtype),tc=this.bufferSync(h),tl=0;tl<tu.size;++tl){var th=tu.indexToLoc(tl).map(function(h,te){return h+g[te]});tu.values[tl]=tc.get.apply(tc,th)}return tu.toTensor()},o.prototype.stridedSlice=function(h,g,te,tr){Hh(h,"stridedSlice");var to=ro(g,te,tr);if(to.some(function(h){return 0===h}))return Fn([],to);for(var tu=dr(to,h.dtype),tc=this.bufferSync(h),tl=0;tl<tu.size;tl++){for(var th=tu.indexToLoc(tl),td=Array(th.length),tf=0;tf<td.length;tf++)td[tf]=th[tf]*tr[tf]+g[tf];tu.set.apply(tu,[tc.get.apply(tc,td)].concat(th))}return tu.toTensor()},o.prototype.diag=function(h){for(var g=this.readSync(h.dataId),te=dr([h.size,h.size],h.dtype),tr=te.values,to=0;to<g.length;to++)tr[to*h.size+to]=g[to];return te.toTensor()},o.prototype.unstack=function(h,g){for(var te=h.shape[g],tr=Array(h.rank-1),to=0,tu=0;tu<h.rank;tu++)tu!==g&&(tr[to++]=h.shape[tu]);var tc=Array(h.rank).fill(0),tl=h.shape.slice();tl[g]=1;var th=Array(te);for(tu=0;tu<th.length;tu++)tc[g]=tu,th[tu]=this.slice(h,tc,tl).reshape(tr);return th},o.prototype.reverse=function(h,g){Hh(h,"reverse");for(var te=dr(h.shape,h.dtype),tr=this.bufferSync(h),to=0;to<te.size;to++)(function(to){var tu=te.indexToLoc(to),tc=tu.slice();g.forEach(function(g){return tc[g]=h.shape[g]-1-tc[g]}),te.set.apply(te,[tr.get.apply(tr,tc)].concat(tu))})(to);return te.toTensor()},o.prototype.concat=function(h,g){var te=this;if("complex64"===h[0].dtype){var tr=h.map(function(h){return tJ(h)}),to=h.map(function(h){return tQ(h)});return tY(this.concat(tr,g),this.concat(to,g))}var tu=h.map(function(h){var te=k(h.shape.slice(g));return h.as2D(-1,te)}),tc=Sn(tu.map(function(h){return h.shape}),1),tl=dr(tc,h[0].dtype).values;if(1===tu[0].shape[0]){var th=0;tu.forEach(function(h){tl.set(te.readSync(h.dataId),th),th+=h.size})}else{var td=0;tu.forEach(function(h){for(var g=te.readSync(h.dataId),tr=0,to=0;to<h.shape[0];++to)for(var tu=to*tc[1]+td,th=0;th<h.shape[1];++th)tl[tu+th]=g[tr++];td+=h.shape[1]})}return Fn(tl,Sn(h.map(function(h){return h.shape}),g),h[0].dtype)},o.prototype.neg=function(h){return Hh(h,"neg"),this.multiply(On(-1),h)},o.prototype.add=function(h,g){return"complex64"===h.dtype||"complex64"===g.dtype?this.broadcastedBinaryComplexOp(h.cast("complex64"),g.cast("complex64"),function(h,g,te,tr){return{real:h+te,imag:g+tr}}):this.broadcastedBinaryOp(h,g,Dt(h.dtype,g.dtype),function(h,g){return h+g})},o.prototype.addN=function(h){var g=this;Hh(h,"addN");for(var te=h.map(function(h){return g.readSync(h.dataId)}),tr=dr(h[0].shape,h[0].dtype),to=tr.values,tu=0;tu<h.length;tu++)for(var tc=te[tu],tl=0;tl<to.length;tl++)to[tl]+=tc[tl];return tr.toTensor()},o.prototype.softmax=function(h,g){var te=O([g],h.shape),tr=this.max(h,te),to=wn(tr.shape,te),tu=this.subtract(h,tr.reshape(to)),tc=this.exp(tu),tl=this.sum(tc,te).reshape(to);return this.realDivide(tc,tl)},o.prototype.subtract=function(h,g){return"complex64"===h.dtype||"complex64"===g.dtype?this.broadcastedBinaryComplexOp(h.cast("complex64"),g.cast("complex64"),function(h,g,te,tr){return{real:h-te,imag:g-tr}}):this.broadcastedBinaryOp(h,g,Dt(h.dtype,g.dtype),function(h,g){return h-g})},o.prototype.pow=function(h,g){return Hh([h,g],"pow"),this.broadcastedBinaryOp(h,g,h.dtype,function(h,g){return Math.pow(h,g)})},o.prototype.batchMatMul=function(h,g,te,tr){Hh([h,g],"matMul");for(var to=te?h.shape[1]:h.shape[2],tu=te?h.shape[2]:h.shape[1],tc=tr?g.shape[1]:g.shape[2],tl=h.shape[0],th=this.readSync(h.dataId),td=this.readSync(g.dataId),tf=te?[h.strides[0],1,h.strides[1]]:[h.strides[0],h.strides[1],1],tp=tf[0],tv=tf[1],tm=tf[2],tg=tr?[1,g.strides[1],g.strides[0]]:[g.strides[1],1,g.strides[0]],ty=tg[0],tx=tg[1],tb=tg[2],tC=tu*tc,tw=dr([tl,tu,tc],h.dtype),tE=tw.values,tR=this.blockSize,tI=0;tI<tl;tI++)for(var tk=0;tk<tu;tk+=tR)for(var tA=0;tA<tc;tA+=tR)for(var tS=0;tS<to;tS+=tR)for(var tD=Math.min(tk+tR,tu),tN=Math.min(tA+tR,tc),tT=Math.min(tS+tR,to),tF=tk;tF<tD;tF++)for(var tO=tA;tO<tN;tO++){for(var t_=0,tM=tS;tM<tT;tM++)t_+=th[tI*tp+tF*tv+tM*tm]*td[tM*ty+tO*tx+tI*tb];tE[tI*tC+(tF*tc+tO)]+=t_}return tw.toTensor()},o.prototype.fusedBatchMatMul=function(h){var g=h.a,te=h.b,tr=h.transposeA,to=h.transposeB,tu=h.bias,tc=h.activation,tl=h.preluActivationWeights,th=this.batchMatMul(g,te,tr,to);return tu&&(th=this.add(th,tu)),tc&&(th=qh(this,th,tc,tl)),th},o.prototype.multiply=function(h,g){return"complex64"===h.dtype||"complex64"===g.dtype?this.broadcastedBinaryComplexOp(h.cast("complex64"),g.cast("complex64"),function(h,g,te,tr){return{real:h*te-g*tr,imag:h*tr+g*te}}):this.broadcastedBinaryOp(h,g,Dt(h.dtype,g.dtype),function(h,g){return h*g})},o.prototype.realDivide=function(h,g){return Hh([h,g],"realDivide"),this.broadcastedBinaryOp(h,g,"float32",function(h,g){return h/g})},o.prototype.floorDiv=function(h,g){return Hh([h,g],"floorDiv"),this.broadcastedBinaryOp(h,g,"int32",function(h,g){return Math.floor(h/g)})},o.prototype.sum=function(h,g){Hh(h,"sum"),Cn("sum",g,h.rank);for(var te=bn(h.shape,g),tr=te[0],to=te[1],tu=Gn(tr,Dt(h.dtype,"int32")),tc=k(to),tl=this.readSync(tu.dataId),th=this.readSync(h.dataId),td=0;td<tl.length;++td){for(var tf=td*tc,tp=0,tv=0;tv<tc;++tv)tp+=th[tf+tv];tl[td]=tp}return tu},o.prototype.prod=function(h,g){Hh(h,"sum");for(var te=bn(h.shape,g),tr=te[0],to=te[1],tu=Gn(tr,Dt(h.dtype,"int32")),tc=k(to),tl=this.readSync(tu.dataId),th=this.readSync(h.dataId),td=0;td<tl.length;++td){for(var tf=td*tc,tp=1,tv=0;tv<tc;++tv)tp*=th[tf+tv];tl[td]=tp}return tu},o.prototype.unsortedSegmentSum=function(h,g,te){Hh(h,"unsortedSegmentSum");for(var tr=[],to=h.rank-g.rank,tu=0;tu<to;++tu)g=g.expandDims(tu+1);for(tu=0;tu<te;++tu){var tc=rH(On(tu,"int32"),g).asType("float32").mul(h).sum(0);tr.push(tc)}return nP(tr)},o.prototype.argMin=function(h,g){Hh(h,"argMin");var te=[g];Cn("argMin",te,h.rank);for(var tr=bn(h.shape,te),to=tr[0],tu=tr[1],tc=Gn(to,"int32"),tl=k(tu),th=this.readSync(tc.dataId),td=this.readSync(h.dataId),tf=0;tf<th.length;++tf){for(var tp=tf*tl,tv=td[tp],tm=0,tg=0;tg<tl;++tg){var ty=td[tp+tg];ty<tv&&(tv=ty,tm=tg)}th[tf]=tm}return tc},o.prototype.argMax=function(h,g){Hh(h,"argMax");var te=[g];Cn("argMax",te,h.rank);for(var tr=bn(h.shape,te),to=tr[0],tu=tr[1],tc=Gn(to,"int32"),tl=k(tu),th=this.readSync(tc.dataId),td=this.readSync(h.dataId),tf=0;tf<th.length;++tf){for(var tp=tf*tl,tv=td[tp],tm=0,tg=0;tg<tl;++tg){var ty=td[tp+tg];ty>tv&&(tv=ty,tm=tg)}th[tf]=tm}return tc},o.prototype.cumsum=function(h,g,te,tr){if(Hh(h,"cumsum"),g!==h.rank-1)throw Error("backend.cumsum in CPU expects an inner-most axis="+(h.rank-1)+" but got axis="+g);for(var to=Dt(h.dtype,"int32"),tu=Gn(h.shape,to),tc=this.readSync(tu.dataId),tl=this.readSync(h.dataId),th=h.shape[h.rank-1],td=tr?function(h,g){return h+th-g-1}:function(h,g){return h+g},tf=0;tf<tl.length;tf+=th)for(var tp=0;tp<th;tp++){var tv=td(tf,tp);if(0===tp)tc[tv]=te?0:tl[tv];else{var tm=td(tf,tp-1);tc[tv]=te?tl[tm]+tc[tm]:tl[tv]+tc[tm]}}return tu},o.prototype.equal=function(h,g){return Hh([h,g],"equal"),this.broadcastedBinaryOp(h,g,"bool",function(h,g){return h===g?1:0})},o.prototype.notEqual=function(h,g){return Hh([h,g],"notEqual"),this.broadcastedBinaryOp(h,g,"bool",function(h,g){return h!==g?1:0})},o.prototype.less=function(h,g){return Hh([h,g],"less"),this.broadcastedBinaryOp(h,g,"bool",function(h,g){return h<g?1:0})},o.prototype.lessEqual=function(h,g){return Hh([h,g],"lessEqual"),this.broadcastedBinaryOp(h,g,"bool",function(h,g){return h<=g?1:0})},o.prototype.greater=function(h,g){return Hh([h,g],"greater"),this.broadcastedBinaryOp(h,g,"bool",function(h,g){return h>g?1:0})},o.prototype.greaterEqual=function(h,g){return Hh([h,g],"greaterEqual"),this.broadcastedBinaryOp(h,g,"bool",function(h,g){return h>=g?1:0})},o.prototype.logicalNot=function(h){Hh(h,"logicalNot");for(var g=this.readSync(h.dataId),te=new Uint8Array(g.length),tr=0;tr<g.length;++tr)te[tr]=g[tr]?0:1;return this.makeOutput(te,h.shape,"bool")},o.prototype.logicalAnd=function(h,g){return Hh([h,g],"logicalAnd"),this.broadcastedBinaryOp(h,g,"bool",function(h,g){return h&&g})},o.prototype.logicalOr=function(h,g){return Hh([h,g],"logicalOr"),this.broadcastedBinaryOp(h,g,"bool",function(h,g){return h||g})},o.prototype.select=function(h,g,te){Hh([h,g,te],"select");for(var tr=this.readSync(h.dataId),to=this.readSync(g.dataId),tu=this.readSync(te.dataId),tc=Gn(g.shape,Dt(g.dtype,te.dtype)),tl=this.readSync(tc.dataId),th=0,td=0===h.rank||h.rank>1||1===g.rank?1:k(g.shape.slice(1)),tf=0;tf<tr.length;tf++)for(var tp=0;tp<td;tp++)1===tr[tf]?tl[th++]=to[tf]:tl[th++]=tu[tf];return tc},o.prototype.where=function(h){Hh([h],"where");var g=this.readSync(h.dataId);return na(h.shape,g)},o.prototype.topk=function(h,g,te){return Hh(h,"topk"),ea(this.readSync(h.dataId),h.shape,h.dtype,g)},o.prototype.min=function(h,g){Hh(h,"min"),Cn("min",g,h.rank);for(var te=bn(h.shape,g),tr=te[0],to=te[1],tu=Gn(tr,h.dtype),tc=k(to),tl=this.readSync(tu.dataId),th=this.readSync(h.dataId),td=0;td<tl.length;++td){for(var tf=td*tc,tp=th[tf],tv=0;tv<tc;++tv){var tm=th[tf+tv];tm<tp&&(tp=tm)}tl[td]=tp}return tu},o.prototype.minimum=function(h,g){return Hh([h,g],"minimum"),this.broadcastedBinaryOp(h,g,h.dtype,function(h,g){return Math.min(h,g)})},o.prototype.mod=function(h,g){return Hh([h,g],"mod"),this.broadcastedBinaryOp(h,g,h.dtype,function(h,g){var te=h%g;return h<0&&g<0||h>=0&&g>=0?te:(te+g)%g})},o.prototype.max=function(h,g){Hh(h,"max"),Cn("max",g,h.rank);for(var te=bn(h.shape,g),tr=te[0],to=te[1],tu=Gn(tr,h.dtype),tc=k(to),tl=this.readSync(tu.dataId),th=this.readSync(h.dataId),td=0;td<tl.length;++td){for(var tf=td*tc,tp=th[tf],tv=0;tv<tc;++tv){var tm=th[tf+tv];tm>tp&&(tp=tm)}tl[td]=tp}return tu},o.prototype.maximum=function(h,g){return Hh([h,g],"maximum"),this.broadcastedBinaryOp(h,g,h.dtype,function(h,g){return Math.max(h,g)})},o.prototype.all=function(h,g){Hh(h,"all"),Cn("all",g,h.rank);for(var te=bn(h.shape,g),tr=te[0],to=te[1],tu=Gn(tr,h.dtype),tc=k(to),tl=this.readSync(tu.dataId),th=this.readSync(h.dataId),td=0;td<tl.length;++td){for(var tf=td*tc,tp=th[tf],tv=0;tv<tc;++tv){var tm=th[tf+tv];tp=tp&&tm}tl[td]=tp}return tu},o.prototype.any=function(h,g){Hh(h,"any"),Cn("any",g,h.rank);for(var te=bn(h.shape,g),tr=te[0],to=te[1],tu=Gn(tr,h.dtype),tc=k(to),tl=this.readSync(tu.dataId),th=this.readSync(h.dataId),td=0;td<tl.length;++td){for(var tf=td*tc,tp=th[tf],tv=0;tv<tc;++tv){var tm=th[tf+tv];tp=tp||tm}tl[td]=tp}return tu},o.prototype.squaredDifference=function(h,g){return Hh([h,g],"squaredDifference"),this.broadcastedBinaryOp(h,g,h.dtype,function(h,g){var te=h-g;return te*te})},o.prototype.ceil=function(h){Hh(h,"ceil");for(var g=this.readSync(h.dataId),te=new Float32Array(g.length),tr=0;tr<g.length;++tr)te[tr]=Math.ceil(g[tr]);return this.makeOutput(te,h.shape,"float32")},o.prototype.floor=function(h){Hh(h,"floor");for(var g=this.readSync(h.dataId),te=new Float32Array(g.length),tr=0;tr<g.length;++tr)te[tr]=Math.floor(g[tr]);return this.makeOutput(te,h.shape,"float32")},o.prototype.sign=function(h){Hh(h,"x");for(var g=this.readSync(h.dataId),te=new Float32Array(g.length),tr=0;tr<g.length;++tr)g[tr]<0?te[tr]=-1:g[tr]>0?te[tr]=1:te[tr]=0;return this.makeOutput(te,h.shape,"float32")},o.prototype.isNaN=function(h){Hh(h,"x");for(var g=this.readSync(h.dataId),te=new Uint8Array(g.length),tr=0;tr<g.length;++tr)Number.isNaN(g[tr])&&(te[tr]=1);return this.makeOutput(te,h.shape,"bool")},o.prototype.isInf=function(h){Hh(h,"x");for(var g=this.readSync(h.dataId),te=new Uint8Array(g.length),tr=0;tr<g.length;++tr)Math.abs(g[tr])===1/0&&(te[tr]=1);return this.makeOutput(te,h.shape,"bool")},o.prototype.isFinite=function(h){Hh(h,"x");for(var g=this.readSync(h.dataId),te=new Uint8Array(g.length),tr=0;tr<g.length;++tr)Number.isFinite(g[tr])&&(te[tr]=1);return this.makeOutput(te,h.shape,"bool")},o.prototype.round=function(h){Hh(h,"round");for(var g=this.readSync(h.dataId),te=new Float32Array(g.length),tr=0;tr<g.length;++tr){var to=Math.floor(g[tr]);g[tr]-to<.5?te[tr]=Math.floor(g[tr]):g[tr]-to>.5?te[tr]=Math.ceil(g[tr]):te[tr]=to%2==0?to:to+1}return this.makeOutput(te,h.shape,"float32")},o.prototype.exp=function(h){Hh(h,"exp");for(var g=this.readSync(h.dataId),te=new Float32Array(g.length),tr=0;tr<g.length;++tr)te[tr]=Math.exp(g[tr]);return this.makeOutput(te,h.shape,"float32")},o.prototype.expm1=function(h){Hh(h,"expm1");for(var g=this.readSync(h.dataId),te=new Float32Array(g.length),tr=0;tr<g.length;++tr)te[tr]=Math.expm1(g[tr]);return this.makeOutput(te,h.shape,"float32")},o.prototype.log=function(h){Hh(h,"log");for(var g=this.readSync(h.dataId),te=new Float32Array(g.length),tr=0;tr<g.length;++tr){var to=g[tr];te[tr]=Math.log(to)}return this.makeOutput(te,h.shape,"float32")},o.prototype.log1p=function(h){Hh(h,"log1p");for(var g=this.readSync(h.dataId),te=new Float32Array(g.length),tr=0;tr<g.length;++tr){var to=g[tr];te[tr]=Math.log1p(to)}return this.makeOutput(te,h.shape,"float32")},o.prototype.sqrt=function(h){Hh(h,"sqrt");for(var g=this.readSync(h.dataId),te=new Float32Array(g.length),tr=0;tr<g.length;++tr){var to=g[tr];te[tr]=Math.sqrt(to)}return this.makeOutput(te,h.shape,"float32")},o.prototype.rsqrt=function(h){Hh(h,"rsqrt");for(var g=this.readSync(h.dataId),te=new Float32Array(g.length),tr=0;tr<g.length;++tr){var to=g[tr];te[tr]=1/Math.sqrt(to)}return this.makeOutput(te,h.shape,"float32")},o.prototype.reciprocal=function(h){Hh(h,"reciprocal");for(var g=this.readSync(h.dataId),te=new Float32Array(g.length),tr=0;tr<g.length;++tr)te[tr]=1/g[tr];return this.makeOutput(te,h.shape,"float32")},o.prototype.linear=function(h){return h},o.prototype.relu=function(h){Hh(h,"relu");for(var g=Gn(h.shape,h.dtype),te=this.readSync(g.dataId),tr=this.readSync(h.dataId),to=0;to<tr.length;++to)te[to]=Math.max(0,tr[to]);return g},o.prototype.relu6=function(h){Hh(h,"relu");for(var g=Gn(h.shape,h.dtype),te=this.readSync(g.dataId),tr=this.readSync(h.dataId),to=0;to<tr.length;++to)te[to]=Math.min(Math.max(0,tr[to]),6);return g},o.prototype.prelu=function(h,g){return Hh([h,g],"prelu"),this.broadcastedBinaryOp(h,g,h.dtype,function(h,g){return h<0?g*h:h})},o.prototype.elu=function(h){Hh(h,"elu");for(var g=new Float32Array(h.size),te=this.readSync(h.dataId),tr=0;tr<te.length;++tr){var to=te[tr];g[tr]=to>=0?to:Math.exp(to)-1}return this.makeOutput(g,h.shape,"float32")},o.prototype.eluDer=function(h,g){Hh([h,g],"eluDer");for(var te=new Float32Array(g.size),tr=this.readSync(g.dataId),to=this.readSync(h.dataId),tu=0;tu<tr.length;++tu){var tc=tr[tu];te[tu]=tc>=1?to[tu]:to[tu]*(tc+1)}return this.makeOutput(te,g.shape,"float32")},o.prototype.selu=function(h){Hh(h,"selu");for(var g=new Float32Array(h.size),te=this.readSync(h.dataId),tr=0;tr<te.length;++tr){var to=te[tr];g[tr]=to>=0?1.0507009873554805*to:1.7580993408473768*(Math.exp(to)-1)}return this.makeOutput(g,h.shape,"float32")},o.prototype.clip=function(h,g,te){Hh(h,"clip");for(var tr=new Float32Array(h.size),to=this.readSync(h.dataId),tu=0;tu<to.length;++tu){var tc=to[tu];tr[tu]=tc>te?te:tc<g?g:tc}return this.makeOutput(tr,h.shape,"float32")},o.prototype.abs=function(h){for(var g=new Float32Array(h.size),te=this.readSync(h.dataId),tr=0;tr<te.length;++tr)g[tr]=Math.abs(te[tr]);return this.makeOutput(g,h.shape,"float32")},o.prototype.complexAbs=function(h){for(var g=new Float32Array(h.size),te=this.readSync(h.dataId),tr=0;tr<h.size;++tr){var to=te[2*tr],tu=te[2*tr+1];g[tr]=Math.hypot(to,tu)}return this.makeOutput(g,h.shape,"float32")},o.prototype.int=function(h){Hh(h,"int");for(var g=new Int32Array(h.size),te=this.readSync(h.dataId),tr=0;tr<te.length;++tr)g[tr]=te[tr];return this.makeOutput(g,h.shape,"int32")},o.prototype.sigmoid=function(h){Hh(h,"sigmoid");for(var g=new Float32Array(h.size),te=this.readSync(h.dataId),tr=0;tr<te.length;++tr)g[tr]=1/(1+Math.exp(-te[tr]));return this.makeOutput(g,h.shape,"float32")},o.prototype.softplus=function(h){Hh(h,"softplus");for(var g=Math.log(11920928955078125e-23)+2,te=new Float32Array(h.size),tr=this.readSync(h.dataId),to=0;to<tr.length;++to){var tu=tr[to]>-g,tc=tr[to]<g,tl=Math.exp(tr[to]),th=void 0;th=tc?tl:tu?tr[to]:Math.log(1+tl),te[to]=th}return this.makeOutput(te,h.shape,"float32")},o.prototype.sin=function(h){Hh(h,"sin");for(var g=new Float32Array(h.size),te=this.readSync(h.dataId),tr=0;tr<te.length;++tr)g[tr]=Math.sin(te[tr]);return this.makeOutput(g,h.shape,"float32")},o.prototype.cos=function(h){Hh(h,"cos");for(var g=new Float32Array(h.size),te=this.readSync(h.dataId),tr=0;tr<te.length;++tr)g[tr]=Math.cos(te[tr]);return this.makeOutput(g,h.shape,"float32")},o.prototype.tan=function(h){Hh(h,"tan");for(var g=new Float32Array(h.size),te=this.readSync(h.dataId),tr=0;tr<te.length;++tr)g[tr]=Math.tan(te[tr]);return this.makeOutput(g,h.shape,"float32")},o.prototype.asin=function(h){Hh(h,"asin");for(var g=new Float32Array(h.size),te=this.readSync(h.dataId),tr=0;tr<te.length;++tr)g[tr]=Math.asin(te[tr]);return this.makeOutput(g,h.shape,"float32")},o.prototype.acos=function(h){Hh(h,"acos");for(var g=new Float32Array(h.size),te=this.readSync(h.dataId),tr=0;tr<te.length;++tr)g[tr]=Math.acos(te[tr]);return this.makeOutput(g,h.shape,"float32")},o.prototype.atan=function(h){Hh(h,"atan");for(var g=new Float32Array(h.size),te=this.readSync(h.dataId),tr=0;tr<te.length;++tr)g[tr]=Math.atan(te[tr]);return this.makeOutput(g,h.shape,"float32")},o.prototype.atan2=function(h,g){return Hh([h,g],"atan2"),this.broadcastedBinaryOp(h,g,h.dtype,function(h,g){return Math.atan2(h,g)})},o.prototype.sinh=function(h){Hh(h,"sinh");for(var g=new Float32Array(h.size),te=this.readSync(h.dataId),tr=0;tr<te.length;++tr)g[tr]=Math.sinh(te[tr]);return this.makeOutput(g,h.shape,"float32")},o.prototype.cosh=function(h){Hh(h,"cosh");for(var g=new Float32Array(h.size),te=this.readSync(h.dataId),tr=0;tr<te.length;++tr)g[tr]=Math.cosh(te[tr]);return this.makeOutput(g,h.shape,"float32")},o.prototype.tanh=function(h){Hh(h,"tanh");for(var g=new Float32Array(h.size),te=this.readSync(h.dataId),tr=0;tr<te.length;++tr)g[tr]=D(te[tr]);return this.makeOutput(g,h.shape,"float32")},o.prototype.asinh=function(h){Hh(h,"asinh");for(var g=new Float32Array(h.size),te=this.readSync(h.dataId),tr=0;tr<te.length;++tr)g[tr]=Math.asinh(te[tr]);return this.makeOutput(g,h.shape,"float32")},o.prototype.acosh=function(h){Hh(h,"acosh");for(var g=new Float32Array(h.size),te=this.readSync(h.dataId),tr=0;tr<te.length;++tr)g[tr]=Math.acosh(te[tr]);return this.makeOutput(g,h.shape,"float32")},o.prototype.atanh=function(h){Hh(h,"atanh");for(var g=new Float32Array(h.size),te=this.readSync(h.dataId),tr=0;tr<te.length;++tr)g[tr]=Math.atanh(te[tr]);return this.makeOutput(g,h.shape,"float32")},o.prototype.erf=function(h){Hh(h,"erf");for(var g=new Float32Array(h.size),te=this.readSync(h.dataId),tr=0;tr<te.length;++tr){var to=Math.sign(te[tr]),tu=Math.abs(te[tr]),tc=1/(1+.3275911*tu);g[tr]=to*(1-((((1.061405429*tc-1.453152027)*tc+1.421413741)*tc-.284496736)*tc+.254829592)*tc*Math.exp(-tu*tu))}return this.makeOutput(g,h.shape,"float32")},o.prototype.step=function(h,g){void 0===g&&(g=0),Hh(h,"step");for(var te=new Float32Array(h.size),tr=this.readSync(h.dataId),to=0;to<tr.length;++to){var tu=tr[to];isNaN(tu)?te[to]=NaN:te[to]=tu>0?1:g}return this.makeOutput(te,h.shape,"float32")},o.prototype.fusedConv2d=function(h){var g=h.input,te=h.filter,tr=h.convInfo,to=h.bias,tu=h.activation,tc=h.preluActivationWeights,tl=this.conv2d(g,te,tr);return to&&(tl=this.add(tl,to)),tu&&(tl=qh(this,tl,tu,tc)),tl},o.prototype.conv2d=function(h,g,te){Hh([h,g],"conv2d");for(var tr=te.filterHeight,to=te.filterWidth,tu=te.dilationHeight,tc=te.dilationWidth,tl=te.padInfo.left,th=te.padInfo.top,td="channelsLast"===te.dataFormat,tf=dr(te.outShape,h.dtype),tp=h.strides[0],tv=td?h.strides[1]:h.strides[2],tm=td?h.strides[2]:1,tg=td?1:h.strides[1],ty=tf.strides[0],tx=td?tf.strides[1]:tf.strides[2],tb=td?tf.strides[2]:1,tC=td?1:tf.strides[1],tw=this.readSync(h.dataId),tE=this.readSync(g.dataId),tR=tf.values,tI=0;tI<te.batchSize;++tI)for(var tk=tI*tp,tA=tI*ty,tS=0;tS<te.outHeight;++tS)for(var tD=tA+tS*tx,tN=tS*te.strideHeight-th,tT=0;tT<tr;tT++){var tF=tN+tT*tu;if(!(tF<0||tF>=te.inHeight))for(var tO=tT*g.strides[0],t_=tk+tF*tv,tM=0;tM<te.outWidth;++tM)for(var tB=tD+tM*tb,tP=tM*te.strideWidth-tl,tL=0;tL<to;tL++){var tW=tP+tL*tc;if(!(tW<0||tW>=te.inWidth))for(var tV=t_+tW*tm,tU=tO+tL*g.strides[1],tz=0;tz<te.inChannels;++tz){for(var tH=tw[tV+tz*tg],tG=0;tG<te.outChannels;++tG)tR[tB+tG*tC]+=tH*tE[tU+tG];tU+=te.outChannels}}}return tf.toTensor()},o.prototype.conv3d=function(h,g,te){for(var tr=te.filterDepth,to=te.filterHeight,tu=te.filterWidth,tc=te.dilationDepth,tl=te.dilationHeight,th=te.dilationWidth,td=te.padInfo.front,tf=te.padInfo.left,tp=te.padInfo.top,tv=dr(te.outShape,h.dtype),tm=this.readSync(h.dataId),tg=this.readSync(g.dataId),ty=tv.values,tx=0;tx<te.batchSize;++tx)for(var tb=tx*h.strides[0],tC=tx*tv.strides[0],tw=0;tw<te.outDepth;++tw)for(var tE=tC+tw*tv.strides[1],tR=tw*te.strideDepth-td,tI=0;tI<tr;tI++){var tk=tR+tI*tc;if(!(tk<0||tk>=te.inDepth))for(var tA=tI*g.strides[0],tS=tb+tk*h.strides[1],tD=0;tD<te.outHeight;++tD)for(var tN=tE+tD*tv.strides[2],tT=tD*te.strideHeight-tp,tF=0;tF<to;tF++){var tO=tT+tF*tl;if(!(tO<0||tO>=te.inHeight))for(var t_=tA+tF*g.strides[1],tM=tS+tO*h.strides[2],tB=0;tB<te.outWidth;++tB)for(var tP=tN+tB*te.outChannels,tL=tB*te.strideWidth-tf,tW=0;tW<tu;tW++){var tV=tL+tW*th;if(!(tV<0||tV>=te.inWidth))for(var tU=t_+tW*g.strides[2],tz=tM+tV*te.inChannels,tH=tU,tG=0;tG<te.inChannels;++tG){for(var tq=tm[tz+tG],tK=0;tK<te.outChannels;++tK)ty[tP+tK]+=tq*tg[tH+tK];tH+=te.outChannels}}}}return tv.toTensor()},o.prototype.conv2dDerInput=function(h,g,te){Hh([h,g],"conv2dDerInput");for(var tr=dr(te.inShape,"float32"),to=tr.values,tu=this.readSync(h.dataId),tc=this.readSync(g.dataId),tl=g.strides,th=tl[0],td=tl[1],tf=tl[2],tp=te.batchSize,tv=te.filterHeight,tm=te.filterWidth,tg=te.inChannels,ty=te.inHeight,tx=te.inWidth,tb=te.outChannels,tC=te.outHeight,tw=te.outWidth,tE=te.strideHeight,tR=te.strideWidth,tI=te.dataFormat,tk=tv-1-te.padInfo.top,tA=tm-1-te.padInfo.left,tS="channelsLast"===tI,tD=tr.strides[0],tN=tS?tr.strides[1]:tr.strides[2],tT=tS?tr.strides[2]:1,tF=tS?1:tr.strides[1],tO=h.strides[0],t_=tS?h.strides[1]:h.strides[2],tM=tS?h.strides[2]:1,tB=tS?1:h.strides[1],tP=0;tP<tp;++tP)for(var tL=0;tL<tg;++tL)for(var tW=0;tW<ty;++tW)for(var tV=tW-tk,tU=Math.max(0,Math.ceil(tV/tE)),tz=Math.min(tC,(tv+tV)/tE),tH=0;tH<tx;++tH){for(var tG=tH-tA,tq=Math.max(0,Math.ceil(tG/tR)),tK=Math.min(tw,(tm+tG)/tR),tj=0,tX=tU;tX<tz;++tX)for(var t$=tX*tE-tV,tY=tq;tY<tK;++tY)for(var tJ=tO*tP+t_*tX+tM*tY,tQ=th*(tv-1-t$)+td*(tm-1-(tY*tR-tG))+tf*tL,tZ=0;tZ<tb;++tZ)tj+=tu[tJ+tB*tZ]*tc[tQ+tZ];to[tD*tP+tN*tW+tT*tH+tF*tL]=tj}return tr.toTensor()},o.prototype.conv3dDerInput=function(h,g,te){for(var tr=dr(te.inShape,"float32"),to=tr.values,tu=tr.strides,tc=tu[0],tl=tu[1],th=tu[2],td=tu[3],tf=this.readSync(h.dataId),tp=h.strides,tv=tp[0],tm=tp[1],tg=tp[2],ty=tp[3],tx=this.readSync(g.dataId),tb=g.strides,tC=tb[0],tw=tb[1],tE=tb[2],tR=tb[3],tI=te.batchSize,tk=te.filterDepth,tA=te.filterHeight,tS=te.filterWidth,tD=te.inChannels,tN=te.inDepth,tT=te.inHeight,tF=te.inWidth,tO=te.outChannels,t_=te.outDepth,tM=te.outHeight,tB=te.outWidth,tP=te.strideDepth,tL=te.strideHeight,tW=te.strideWidth,tV=tk-1-te.padInfo.front,tU=tA-1-te.padInfo.top,tz=tS-1-te.padInfo.left,tH=0;tH<tI;++tH)for(var tG=0;tG<tD;++tG)for(var tq=0;tq<tN;++tq)for(var tK=tq-tV,tj=Math.max(0,Math.ceil(tK/tP)),tX=Math.min(t_,(tk+tK)/tP),t$=0;t$<tT;++t$)for(var tY=t$-tU,tJ=Math.max(0,Math.ceil(tY/tL)),tQ=Math.min(tM,(tA+tY)/tL),tZ=0;tZ<tF;++tZ){for(var t0=tZ-tz,t1=Math.max(0,Math.ceil(t0/tW)),t2=Math.min(tB,(tS+t0)/tW),t3=0,t4=tj;t4<tX;++t4)for(var t5=t4*tP-tK,t6=tJ;t6<tQ;++t6)for(var t8=t6*tL-tY,t7=t1;t7<t2;++t7)for(var t9=tv*tH+tm*t4+tg*t6+ty*t7,nn=tC*(tk-1-t5)+tw*(tA-1-t8)+tE*(tS-1-(t7*tW-t0))+tR*tG,nr=0;nr<tO;++nr)t3+=tf[t9+nr]*tx[nn+nr];to[tc*tH+tl*tq+th*t$+td*tZ+tG]=t3}return tr.toTensor()},o.prototype.conv2dDerFilter=function(h,g,te){Hh([h,g],"conv2dDerFilter");for(var tr=te.strideHeight,to=te.strideWidth,tu=te.filterHeight,tc=te.filterWidth,tl="channelsLast"===te.dataFormat,th=dr(te.filterShape,"float32"),td=te.padInfo.left,tf=te.padInfo.top,tp=this.bufferSync(h),tv=this.bufferSync(g),tm=0;tm<tu;++tm)for(var tg=Math.max(0,Math.ceil((tf-tm)/tr)),ty=Math.min(te.outHeight,(te.inHeight+tf-tm)/tr),tx=0;tx<tc;++tx)for(var tb=Math.max(0,Math.ceil((td-tx)/to)),tC=Math.min(te.outWidth,(te.inWidth+td-tx)/to),tw=0;tw<te.inChannels;++tw)for(var tE=0;tE<te.outChannels;++tE){for(var tR=0,tI=0;tI<te.batchSize;++tI)for(var tk=tg;tk<ty;++tk)for(var tA=tm+tk*tr-tf,tS=tb;tS<tC;++tS){var tD=tx+tS*to-td;tR+=tl?tp.get(tI,tA,tD,tw)*tv.get(tI,tk,tS,tE):tp.get(tI,tw,tA,tD)*tv.get(tI,tE,tk,tS)}th.set(tR,tm,tx,tw,tE)}return th.toTensor()},o.prototype.conv3dDerFilter=function(h,g,te){for(var tr=te.strideDepth,to=te.strideHeight,tu=te.strideWidth,tc=te.filterDepth,tl=te.filterHeight,th=te.filterWidth,td=dr(te.filterShape,"float32"),tf=td.values,tp=td.strides,tv=tp[0],tm=tp[1],tg=tp[2],ty=tp[3],tx=this.readSync(g.dataId),tb=g.strides,tC=tb[0],tw=tb[1],tE=tb[2],tR=tb[3],tI=this.readSync(h.dataId),tk=h.strides,tA=tk[0],tS=tk[1],tD=tk[2],tN=tk[3],tT=te.padInfo.front,tF=te.padInfo.left,tO=te.padInfo.top,t_=0;t_<tc;++t_)for(var tM=Math.max(0,Math.ceil((tT-t_)/tr)),tB=Math.min(te.outDepth,(te.inDepth+tT-t_)/tr),tP=t_*tv,tL=0;tL<tl;++tL)for(var tW=Math.max(0,Math.ceil((tO-tL)/to)),tV=Math.min(te.outHeight,(te.inHeight+tO-tL)/to),tU=tL*tm+tP,tz=0;tz<th;++tz)for(var tH=Math.max(0,Math.ceil((tF-tz)/tu)),tG=Math.min(te.outWidth,(te.inWidth+tF-tz)/tu),tq=tz*tg+tU,tK=0;tK<te.inChannels;++tK)for(var tj=tK*ty+tq,tX=0;tX<te.outChannels;++tX){for(var t$=0,tY=0;tY<te.batchSize;++tY)for(var tJ=tY*tA,tQ=tY*tC,tZ=tM;tZ<tB;++tZ)for(var t0=(t_+tZ*tr-tT)*tS+tJ,t1=tZ*tw+tQ,t2=tW;t2<tV;++t2)for(var t3=(tL+t2*to-tO)*tD+t0,t4=t2*tE+t1,t5=tH;t5<tG;++t5){var t6=t5*tR+t4;t$+=tI[(tz+t5*tu-tF)*tN+t3+tK]*tx[t6+tX]}tf[tj+tX]=t$}return td.toTensor()},o.prototype.fusedDepthwiseConv2D=function(h){var g=h.input,te=h.filter,tr=h.convInfo,to=h.bias,tu=h.activation,tc=h.preluActivationWeights,tl=this.depthwiseConv2D(g,te,tr);return to&&(tl=this.add(tl,to)),tu&&(tl=qh(this,tl,tu,tc)),tl},o.prototype.depthwiseConv2D=function(h,g,te){Hh([h,g],"depthwiseConv2D");for(var tr=te.filterHeight,to=te.filterWidth,tu=te.dilationHeight,tc=te.dilationWidth,tl=te.padInfo.left,th=te.padInfo.top,td=te.outChannels/te.inChannels,tf=dr(te.outShape,h.dtype),tp=this.readSync(h.dataId),tv=this.readSync(g.dataId),tm=tf.values,tg=0;tg<te.batchSize;++tg)for(var ty=tg*h.strides[0],tx=tg*tf.strides[0],tb=0;tb<te.outHeight;++tb)for(var tC=tx+tb*tf.strides[1],tw=tb*te.strideHeight-tl,tE=0;tE<tr;++tE){var tR=tw+tE*tu;if(!(tR<0||tR>=te.inHeight))for(var tI=tE*g.strides[0],tk=ty+tR*h.strides[1],tA=0;tA<te.outWidth;++tA)for(var tS=tC+tA*tf.strides[2],tD=tA*te.strideWidth-th,tN=0;tN<to;++tN){var tT=tD+tN*tc;if(!(tT<0||tT>=te.inWidth))for(var tF=tI+tN*g.strides[1],tO=tk+tT*te.inChannels,t_=tS,tM=tF,tB=0;tB<te.inChannels;++tB){for(var tP=tp[tO+tB],tL=0;tL<td;++tL)tm[t_+tL]+=tP*tv[tM+tL];t_+=td,tM+=td}}}return tf.toTensor()},o.prototype.depthwiseConv2DDerInput=function(h,g,te){Hh([h,g],"depthwiseConv2DDerInput");for(var tr=dr(te.inShape,"float32"),to=tr.values,tu=tr.strides,tc=tu[0],tl=tu[1],th=tu[2],td=this.readSync(h.dataId),tf=h.strides,tp=tf[0],tv=tf[1],tm=tf[2],tg=this.readSync(g.dataId),ty=g.strides,tx=ty[0],tb=ty[1],tC=ty[2],tw=te.batchSize,tE=te.filterHeight,tR=te.filterWidth,tI=te.inChannels,tk=te.inHeight,tA=te.inWidth,tS=te.outChannels,tD=te.outHeight,tN=te.outWidth,tT=te.strideHeight,tF=te.strideWidth,tO=tE-1-te.padInfo.top,t_=tR-1-te.padInfo.left,tM=tS/tI,tB=0;tB<tw;++tB)for(var tP=0;tP<tI;++tP)for(var tL=0;tL<tk;++tL)for(var tW=tL-tO,tV=Math.max(0,Math.ceil(tW/tT)),tU=Math.min(tD,(tE+tW)/tT),tz=0;tz<tA;++tz){for(var tH=tz-t_,tG=Math.max(0,Math.ceil(tH/tF)),tq=Math.min(tN,(tR+tH)/tF),tK=0,tj=tV;tj<tU;++tj)for(var tX=tj*tT-tW,t$=tG;t$<tq;++t$)for(var tY=tp*tB+tv*tj+tm*t$,tJ=tx*(tE-1-tX)+tb*(tR-1-(t$*tF-tH))+tC*tP,tQ=0;tQ<tM;++tQ)tK+=td[tY+(tP*tM+tQ)]*tg[tJ+tQ];to[tc*tB+tl*tL+th*tz+tP]=tK}return tr.toTensor()},o.prototype.depthwiseConv2DDerFilter=function(h,g,te){Hh([h,g],"depthwiseConv2DDerFilter");for(var tr=te.strideHeight,to=te.strideWidth,tu=te.filterHeight,tc=te.filterWidth,tl=dr(te.filterShape,"float32"),th=te.padInfo.left,td=te.padInfo.top,tf=te.outChannels/te.inChannels,tp=this.bufferSync(h),tv=this.bufferSync(g),tm=0;tm<tu;++tm)for(var tg=Math.max(0,Math.ceil((td-tm)/tr)),ty=Math.min(te.outHeight,(te.inHeight+td-tm)/tr),tx=0;tx<tc;++tx)for(var tb=Math.max(0,Math.ceil((th-tx)/to)),tC=Math.min(te.outWidth,(te.inWidth+th-tx)/to),tw=0;tw<te.outChannels;++tw){for(var tE=Math.trunc(tw/tf),tR=tw%tf,tI=0,tk=0;tk<te.batchSize;++tk)for(var tA=tg;tA<ty;++tA)for(var tS=tm+tA*tr-td,tD=tb;tD<tC;++tD){var tN=tx+tD*to-th;tI+=tp.get(tk,tS,tN,tE)*tv.get(tk,tA,tD,tw)}tl.set(tI,tm,tx,tE,tR)}return tl.toTensor()},o.prototype.tile=function(h,g){return Hh(h,"tile"),ta(this.bufferSync(h),g)},o.prototype.pad=function(h,g,te){Hh(h,"pad");var tr=g.map(function(g,te){return g[0]+h.shape[te]+g[1]}),to=g.map(function(h){return h[0]}),tu=this.bufferSync(h),tc=dr(tr,h.dtype);0!==te&&tc.values.fill(te);for(var tl=0;tl<h.size;tl++){var th=tu.indexToLoc(tl),td=th.map(function(h,g){return h+to[g]});tc.set.apply(tc,[tu.get.apply(tu,th)].concat(td))}return tc.toTensor()},o.prototype.transpose=function(h,g){Hh(h,"transpose");for(var te=Array(h.rank),tr=0;tr<te.length;tr++)te[tr]=h.shape[g[tr]];var to=this.readSync(h.dataId),tu=dr(te,h.dtype),tc=this.bufferSync(h);for(tr=0;tr<h.size;++tr){for(var tl=tc.indexToLoc(tr),th=Array(tl.length),td=0;td<th.length;td++)th[td]=tl[g[td]];var tf=tu.locToIndex(th);tu.values[tf]=to[tr]}return tu.toTensor()},o.prototype.gather=function(h,g,te){Hh([h,g],"gather");var tr=h.shape.slice(),to=this.readSync(g.dataId);tr[te]=to.length;for(var tu=dr(tr,h.dtype),tc=this.bufferSync(h),tl=0;tl<tu.size;++tl){var th=tu.indexToLoc(tl),td=th.slice();td[te]=to[th[te]];var tf=tc.locToIndex(td);tu.values[tl]=tc.values[tf]}return tu.toTensor()},o.prototype.batchToSpaceND=function(h,g,te){Hh([h],"batchToSpaceND");var tr=g.reduce(function(h,g){return h*g}),to=zr(h.shape,g,tr),tu=Gr(to.length,g.length),tc=Hr(h.shape,g,tr),tl=qr(te,g.length),th=Kr(tc,te,g.length);return h.reshape(to).transpose(tu).reshape(tc).slice(tl,th)},o.prototype.spaceToBatchND=function(h,g,te){Hh([h],"spaceToBatchND");var tr=g.reduce(function(h,g){return h*g}),to=[[0,0]];to.push.apply(to,te);for(var tu=1+g.length;tu<h.shape.length;++tu)to.push([0,0]);var tc=h.pad(to),tl=zr(tc.shape,g,tr,!1),th=Gr(tl.length,g.length,!1),td=Hr(tc.shape,g,tr,!1);return tc.reshape(tl).transpose(th).reshape(td)},o.prototype.pool=function(h,g,te){Hh(h,"pool");for(var tr=g.strideHeight,to=g.strideWidth,tu=g.dilationHeight,tc=g.dilationWidth,tl=g.effectiveFilterHeight,th=g.effectiveFilterWidth,td=g.padInfo.top,tf=g.padInfo.left,tp="max"===te?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,tv=this.readSync(h.dataId),tm=dr(g.outShape,h.dtype),tg=tm.values,ty=g.outShape[1]*g.outShape[2]*g.outShape[3],tx=g.outShape[2]*g.outShape[3],tb=g.outShape[3],tC=0;tC<g.batchSize;++tC)for(var tw=tC*ty,tE=tC*h.strides[0],tR=0;tR<g.inChannels;++tR)for(var tI=0;tI<g.outHeight;++tI)for(var tk=tI*tr-td,tA=Math.max(0,tk),tS=Math.min(g.inHeight,tl+tk),tD=tw+tI*tx,tN=0;tN<g.outWidth;++tN){for(var tT=tN*to-tf,tF=Math.max(0,tT),tO=Math.min(g.inWidth,th+tT),t_=tp,tM=0,tB=0,tP=tA;tP<tS;tP+=tu){for(var tL=tE+tP*h.strides[1],tW=tF;tW<tO;tW+=tc){var tV=tv[tL+tW*h.strides[2]+tR];"max"===te&&tV>t_?t_=tV:"avg"===te&&(tM+=tV,tB++)}if(isNaN(t_))break}tg[tD+tN*tb+tR]="avg"===te?tM/tB:t_}return tm.toTensor()},o.prototype.maxPool=function(h,g){return this.pool(h,g,"max")},o.prototype.maxPoolPositions=function(h,g){for(var te=dr(g.outShape,"int32"),tr=g.strideHeight,to=g.strideWidth,tu=g.dilationHeight,tc=g.dilationWidth,tl=g.effectiveFilterHeight,th=g.effectiveFilterWidth,td=g.padInfo.top,tf=g.padInfo.left,tp=this.bufferSync(h),tv=0;tv<g.batchSize;++tv)for(var tm=0;tm<g.inChannels;++tm)for(var tg=0;tg<g.outHeight;++tg){for(var ty=tg*tr-td,tx=ty;tx<0;)tx+=tu;for(var tb=Math.min(g.inHeight,tl+ty),tC=0;tC<g.outWidth;++tC){for(var tw=tC*to-tf,tE=tw;tE<0;)tE+=tc;for(var tR=Math.min(g.inWidth,th+tw),tI=Number.NEGATIVE_INFINITY,tk=-1,tA=tx;tA<tb;tA+=tu)for(var tS=tA-ty,tD=tE;tD<tR;tD+=tc){var tN=tD-tw,tT=tp.get(tv,tA,tD,tm);tT>tI&&(tI=tT,tk=tS*th+tN)}te.set(tk,tv,tg,tC,tm)}}return te.toTensor()},o.prototype.maxPoolBackprop=function(h,g,te,tr){Hh([g,te],"maxPoolBackprop");for(var to=this.maxPoolPositions(g,tr),tu=tr.strideHeight,tc=tr.strideWidth,tl=tr.dilationHeight,th=tr.dilationWidth,td=tr.effectiveFilterHeight,tf=tr.effectiveFilterWidth,tp=tf-1-tr.padInfo.left,tv=td-1-tr.padInfo.top,tm=dr(g.shape,"float32"),tg=this.bufferSync(to),ty=this.bufferSync(h),tx=0;tx<tr.batchSize;++tx)for(var tb=0;tb<tr.inChannels;++tb)for(var tC=0;tC<tr.inHeight;++tC)for(var tw=0;tw<tr.inWidth;++tw){for(var tE=tC-tv,tR=tw-tp,tI=0,tk=0;tk<td;tk+=tl){var tA=(tE+tk)/tu;if(!(tA<0||tA>=tr.outHeight||Math.floor(tA)!==tA))for(var tS=0;tS<tf;tS+=th){var tD=(tR+tS)/tc;if(!(tD<0||tD>=tr.outWidth||Math.floor(tD)!==tD)){var tN=td*tf-1-tg.get(tx,tA,tD,tb)===tk*tf+tS?1:0;0!==tN&&(tI+=ty.get(tx,tA,tD,tb)*tN)}}}tm.set(tI,tx,tC,tw,tb)}return tm.toTensor()},o.prototype.avgPoolBackprop=function(h,g,te){Hh([h,g],"avgPoolBackprop");for(var tr=te.strideHeight,to=te.strideWidth,tu=te.filterHeight,tc=te.filterWidth,tl=te.dilationHeight,th=te.dilationWidth,td=te.effectiveFilterHeight,tf=te.effectiveFilterWidth,tp=tf-1-te.padInfo.left,tv=td-1-te.padInfo.top,tm=dr(g.shape,"float32"),tg=1/(tu*tc),ty=this.bufferSync(h),tx=0;tx<te.batchSize;++tx)for(var tb=0;tb<te.inChannels;++tb)for(var tC=0;tC<te.inHeight;++tC)for(var tw=0;tw<te.inWidth;++tw){for(var tE=tC-tv,tR=tw-tp,tI=0,tk=0;tk<td;tk+=tl){var tA=(tE+tk)/tr;if(!(tA<0||tA>=te.outHeight||Math.floor(tA)!==tA))for(var tS=0;tS<tf;tS+=th){var tD=(tR+tS)/to;tD<0||tD>=te.outWidth||Math.floor(tD)!==tD||(tI+=ty.get(tx,tA,tD,tb))}}tm.set(tI*tg,tx,tC,tw,tb)}return tm.toTensor()},o.prototype.pool3d=function(h,g,te){Hh(h,"pool3d");for(var tr=g.strideDepth,to=g.strideHeight,tu=g.strideWidth,tc=g.dilationDepth,tl=g.dilationHeight,th=g.dilationWidth,td=g.effectiveFilterDepth,tf=g.effectiveFilterHeight,tp=g.effectiveFilterWidth,tv=g.padInfo.front,tm=g.padInfo.top,tg=g.padInfo.left,ty="max"===te?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,tx=this.readSync(h.dataId),tb=dr(g.outShape,h.dtype),tC=tb.values,tw=g.outShape[1]*g.outShape[2]*g.outShape[3]*g.outShape[4],tE=g.outShape[2]*g.outShape[3]*g.outShape[4],tR=g.outShape[3]*g.outShape[4],tI=g.outShape[4],tk=0;tk<g.batchSize;++tk)for(var tA=tk*tw,tS=tk*h.strides[0],tD=0;tD<g.inChannels;++tD)for(var tN=0;tN<g.outDepth;++tN){for(var tT=tN*tr-tv,tF=tT;tF<0;)tF+=tc;for(var tO=Math.min(g.inDepth,td+tT),t_=tA+tN*tE,tM=0;tM<g.outHeight;++tM){for(var tB=tM*to-tm,tP=tB;tP<0;)tP+=tl;for(var tL=Math.min(g.inHeight,tf+tB),tW=t_+tM*tR,tV=0;tV<g.outWidth;++tV){for(var tU=tV*tu-tg,tz=tU;tz<0;)tz+=th;for(var tH=Math.min(g.inWidth,tp+tU),tG=tW+tV*tI,tq=ty,tK=0,tj=0,tX=tF;tX<tO;tX+=tc){for(var t$=tS+tX*h.strides[1],tY=tP;tY<tL;tY+=tl){for(var tJ=t$+tY*h.strides[2],tQ=tz;tQ<tH;tQ+=th){var tZ=tx[tJ+tQ*h.strides[3]+tD];if("max"===te&&tZ>tq?tq=tZ:"avg"===te&&(tK+=tZ,tj++),isNaN(tq))break}if(isNaN(tq))break}if(isNaN(tq))break}tC[tG+tD]="avg"===te?tK/tj:tq}}}return tb.toTensor()},o.prototype.avgPool3d=function(h,g){return Hh(h,"avgPool3d"),this.pool3d(h,g,"avg").toFloat()},o.prototype.avgPool3dBackprop=function(h,g,te){Hh([h,g],"avgPool3dBackprop");for(var tr=te.strideDepth,to=te.strideHeight,tu=te.strideWidth,tc=te.filterDepth,tl=te.filterHeight,th=te.filterWidth,td=te.dilationDepth,tf=te.dilationHeight,tp=te.dilationWidth,tv=te.effectiveFilterDepth,tm=te.effectiveFilterHeight,tg=te.effectiveFilterWidth,ty=tv-1-te.padInfo.front,tx=tg-1-te.padInfo.left,tb=tm-1-te.padInfo.top,tC=dr(g.shape,"float32"),tw=1/(tc*tl*th),tE=this.bufferSync(h),tR=0;tR<te.batchSize;++tR)for(var tI=0;tI<te.inChannels;++tI)for(var tk=0;tk<te.inDepth;++tk)for(var tA=0;tA<te.inHeight;++tA)for(var tS=0;tS<te.inWidth;++tS){for(var tD=tk-ty,tN=tA-tb,tT=tS-tx,tF=0,tO=0;tO<tv;tO+=td){var t_=(tD+tO)/tr;if(!(t_<0||t_>=te.outDepth||Math.floor(t_)!==t_))for(var tM=0;tM<tm;tM+=tf){var tB=(tN+tM)/to;if(!(tB<0||tB>=te.outHeight||Math.floor(tB)!==tB))for(var tP=0;tP<tg;tP+=tp){var tL=(tT+tP)/tu;tL<0||tL>=te.outWidth||Math.floor(tL)!==tL||(tF+=tE.get(tR,t_,tB,tL,tI))}}}tC.set(tF*tw,tR,tk,tA,tS,tI)}return tC.toTensor()},o.prototype.maxPool3d=function(h,g){return Hh(h,"maxPool3d"),this.pool3d(h,g,"max").toFloat()},o.prototype.maxPool3dPositions=function(h,g){for(var te=dr(g.outShape,"int32"),tr=g.strideDepth,to=g.strideHeight,tu=g.strideWidth,tc=g.dilationDepth,tl=g.dilationHeight,th=g.dilationWidth,td=g.effectiveFilterDepth,tf=g.effectiveFilterHeight,tp=g.effectiveFilterWidth,tv=g.padInfo.front,tm=g.padInfo.top,tg=g.padInfo.left,ty=this.bufferSync(h),tx=0;tx<g.batchSize;++tx)for(var tb=0;tb<g.inChannels;++tb)for(var tC=0;tC<g.outDepth;++tC){for(var tw=tC*tr-tv,tE=tw;tE<0;)tE+=tc;for(var tR=Math.min(g.inDepth,td+tw),tI=0;tI<g.outHeight;++tI){for(var tk=tI*to-tm,tA=tk;tA<0;)tA+=tl;for(var tS=Math.min(g.inHeight,tf+tk),tD=0;tD<g.outWidth;++tD){for(var tN=tD*tu-tg,tT=tN;tT<0;)tT+=th;for(var tF=Math.min(g.inWidth,tp+tN),tO=Number.NEGATIVE_INFINITY,t_=-1,tM=tE;tM<tR;tM+=tc)for(var tB=tM-tw,tP=tA;tP<tS;tP+=tl)for(var tL=tP-tk,tW=tT;tW<tF;tW+=th){var tV=tW-tN,tU=ty.get(tx,tM,tP,tW,tb);tU>=tO&&(tO=tU,t_=tB*tf*tp+tL*tf+tV)}te.set(t_,tx,tC,tI,tD,tb)}}}return te.toTensor()},o.prototype.maxPool3dBackprop=function(h,g,te,tr){Hh([g,te],"maxPool3dBackprop");for(var to=this.maxPool3dPositions(g,tr),tu=tr.strideDepth,tc=tr.strideHeight,tl=tr.strideWidth,th=tr.dilationDepth,td=tr.dilationHeight,tf=tr.dilationWidth,tp=tr.effectiveFilterDepth,tv=tr.effectiveFilterHeight,tm=tr.effectiveFilterWidth,tg=tp-1-tr.padInfo.front,ty=tm-1-tr.padInfo.left,tx=tv-1-tr.padInfo.top,tb=dr(g.shape,"float32"),tC=this.bufferSync(to),tw=this.bufferSync(h),tE=0;tE<tr.batchSize;++tE)for(var tR=0;tR<tr.inChannels;++tR)for(var tI=0;tI<tr.inDepth;++tI)for(var tk=0;tk<tr.inHeight;++tk)for(var tA=0;tA<tr.inWidth;++tA){for(var tS=tI-tg,tD=tk-tx,tN=tA-ty,tT=0,tF=0;tF<tp;tF+=th){var tO=(tS+tF)/tu;if(!(tO<0||tO>=tr.outDepth||Math.floor(tO)!==tO))for(var t_=0;t_<tv;t_+=td){var tM=(tD+t_)/tc;if(!(tM<0||tM>=tr.outHeight||Math.floor(tM)!==tM))for(var tB=0;tB<tm;tB+=tf){var tP=(tN+tB)/tl;if(!(tP<0||tP>=tr.outWidth||Math.floor(tP)!==tP)){var tL=tp*tv*tm-1-tC.get(tE,tO,tM,tP,tR)===tF*tv*tm+t_*tm+tB?1:0;0!==tL&&(tT+=tw.get(tE,tO,tM,tP,tR)*tL)}}}}tb.set(tT,tE,tI,tk,tA,tR)}return tb.toTensor()},o.prototype.cast=function(h,g){return Po(h,g,this)},o.prototype.reshape=function(h,g){return Lo(h,g)},o.prototype.avgPool=function(h,g){return Hh(h,"avgPool"),this.pool(h,g,"avg").toFloat()},o.prototype.resizeBilinear=function(h,g,te,tr){Hh(h,"resizeBilinear");for(var to=h.shape,tu=to[0],tc=to[1],tl=to[2],th=to[3],td=this.readSync(h.dataId),tf=new Float32Array(k([tu,g,te,th])),tp=[tr&&g>1?tc-1:tc,tr&&te>1?tl-1:tl],tv=[tr&&g>1?g-1:g,tr&&te>1?te-1:te],tm=0,tg=tp[0]/tv[0],ty=tp[1]/tv[1],tx=0;tx<tu;tx++)for(var tb=0;tb<g;tb++)for(var tC=tg*tb,tw=Math.floor(tC),tE=tC-tw,tR=Math.min(tc-1,Math.ceil(tC)),tI=tx*h.strides[0]+tw*h.strides[1],tk=tx*h.strides[0]+tR*h.strides[1],tA=0;tA<te;tA++)for(var tS=ty*tA,tD=Math.floor(tS),tN=tS-tD,tT=Math.min(tl-1,Math.ceil(tS)),tF=tI+tD*h.strides[2],tO=tk+tD*h.strides[2],t_=tI+tT*h.strides[2],tM=tk+tT*h.strides[2],tB=0;tB<th;tB++){var tP=td[tF+tB],tL=td[tO+tB],tW=tP+(td[t_+tB]-tP)*tN,tV=tW+(tL+(td[tM+tB]-tL)*tN-tW)*tE;tf[tm++]=tV}return Fn(tf,[tu,g,te,th])},o.prototype.resizeBilinearBackprop=function(h,g,te){Hh([h,g],"resizeBilinearBackprop");for(var tr=g.shape,to=tr[0],tu=tr[1],tc=tr[2],tl=tr[3],th=h.shape,td=th[1],tf=th[2],tp=new Float32Array(to*tu*tc*tl),tv=[te&&td>1?tu-1:tu,te&&tf>1?tc-1:tc],tm=[te&&td>1?td-1:td,te&&tf>1?tf-1:tf],tg=tv[0]/tm[0],ty=tv[1]/tm[1],tx=this.readSync(h.dataId),tb=0,tC=0;tC<to;tC++)for(var tw=tC*g.strides[0],tE=0;tE<td;tE++)for(var tR=tE*tg,tI=Math.floor(tR),tk=Math.min(Math.ceil(tR),tu-1),tA=tw+tI*g.strides[1],tS=tw+tk*g.strides[1],tD=tR-tI,tN=1-tD,tT=0;tT<tf;tT++)for(var tF=tT*ty,tO=Math.floor(tF),t_=Math.min(Math.ceil(tF),tc-1),tM=tF-tO,tB=1-tM,tP=tA+tO*g.strides[2],tL=tA+t_*g.strides[2],tW=tS+tO*g.strides[2],tV=tS+t_*g.strides[2],tU=tN*tB,tz=tN*tM,tH=tD*tB,tG=tD*tM,tq=0;tq<tl;tq++){var tK=tx[tb++];tp[tP+tq]+=tK*tU,tp[tL+tq]+=tK*tz,tp[tW+tq]+=tK*tH,tp[tV+tq]+=tK*tG}return Ln(tp,[to,tc,tu,tl],g.dtype)},o.prototype.resizeNearestNeighbor=function(h,g,te,tr){Hh(h,"resizeNearestNeighbor");for(var to=h.shape,tu=to[0],tc=to[1],tl=to[2],th=to[3],td=this.readSync(h.dataId),tf=new Float32Array(tu*g*te*th),tp=[tr&&g>1?tc-1:tc,tr&&te>1?tl-1:tl],tv=[tr&&g>1?g-1:g,tr&&te>1?te-1:te],tm=tp[0]/tv[0],tg=tp[1]/tv[1],ty=0,tx=0;tx<tu;tx++)for(var tb=tx*h.strides[0],tC=0;tC<g;tC++)for(var tw=tm*tC,tE=tb+Math.min(tc-1,tr?Math.round(tw):Math.floor(tw))*h.strides[1],tR=0;tR<te;tR++)for(var tI=tg*tR,tk=tE+Math.min(tl-1,tr?Math.round(tI):Math.floor(tI))*h.strides[2],tA=0;tA<th;tA++){var tS=td[tk+tA];tf[ty++]=tS}return Fn(tf,[tu,g,te,th],h.dtype)},o.prototype.resizeNearestNeighborBackprop=function(h,g,te){Hh([h,g],"resizeNearestNeighborBackprop");for(var tr=g.shape,to=tr[0],tu=tr[1],tc=tr[2],tl=tr[3],th=h.shape,td=th[1],tf=th[2],tp=new Float32Array(to*tu*tc*tl),tv=this.readSync(h.dataId),tm=[te&&td>1?tu-1:tu,te&&tf>1?tc-1:tc],tg=[te&&td>1?td-1:td,te&&tf>1?tf-1:tf],ty=tm[0]/tg[0],tx=tm[1]/tg[1],tb=1/ty,tC=1/tx,tw=2*Math.ceil(tb)+2,tE=2*Math.ceil(tC)+2,tR=0;tR<to;tR++)for(var tI=tR*g.strides[0],tk=0;tk<tu;tk++)for(var tA=tI+tk*g.strides[1],tS=Math.floor(tk*tb),tD=Math.floor(tS-tw/2),tN=0;tN<tc;tN++)for(var tT=tA+tN*g.strides[2],tF=Math.floor(tN*tC),tO=Math.floor(tF-tE/2),t_=0;t_<tl;t_++){for(var tM=0,tB=0;tB<tw;tB++){var tP=tB+tD;if(!(tP<0||tP>=td)){var tL=tI+tP*h.strides[1],tW=tP*ty;if(tk===Math.min(tu-1,te?Math.round(tW):Math.floor(tW)))for(var tV=0;tV<tE;tV++){var tU=tV+tO;if(!(tU<0||tU>=tf)){var tz=tL+tU*h.strides[2],tH=tU*tx;tN===Math.min(tc-1,te?Math.round(tH):Math.floor(tH))&&(tM+=tv[tz+t_])}}}}tp[tT+t_]=tM}return Ln(tp,g.shape,g.dtype)},o.prototype.batchNormalization=function(h,g,te,tr,to,tu){Hh([h,g,te,to,tu],"batchNorm");for(var tc=this.readSync(h.dataId),tl=this.readSync(g.dataId),th=this.readSync(te.dataId),td=to?this.readSync(to.dataId):new Float32Array([1]),tf=tu?this.readSync(tu.dataId):new Float32Array([0]),tp=new Float32Array(tc.length),tv=tf.length,tm=td.length,tg=th.length,ty=tl.length,tx=0,tb=0,tC=0,tw=0,tE=0;tE<tc.length;++tE)tp[tE]=tf[tx++]+(tc[tE]-tl[tb++])*td[tC++]/Math.sqrt(th[tw++]+tr),tx>=tv&&(tx=0),tb>=ty&&(tb=0),tC>=tm&&(tC=0),tw>=tg&&(tw=0);return Ln(tp,h.shape)},o.prototype.localResponseNormalization4D=function(h,g,te,tr,to){Hh(h,"localResponseNormalization4D");for(var tu=h.shape[3],tc=tu-1,tl=this.readSync(h.dataId),th=h.size,td=new Float32Array(th),tf=0;tf<th;tf++){var tp=function(h){for(var te=h%tu,tr=h-te+Math.max(0,te-g),to=h-te+Math.min(te+g,tc),th=0;tr<=to;tr++){var td=tl[tr];th+=td*td}return th}(tf),tv=tl[tf]*Math.pow(te+tr*tp,-to);td[tf]=tv}return Ln(td,h.shape)},o.prototype.LRNGrad=function(h,g,te,tr,to,tu,tc){Hh(h,"LRNGrad");for(var tl=h.shape[3],th=this.readSync(h.dataId),td=this.readSync(g.dataId),tf=this.readSync(te.dataId),tp=new Float32Array(h.size),tv=h.size,tm=0;tm<tv;tm++){for(var tg=tm%tl,ty=tm-tg+Math.max(0,tg-tr),tx=tm-tg+Math.min(tl,tg+tr+1),tb=0,tC=ty;tC<tx;tC++)tb+=Math.pow(td[tC],2);for(tb=tu*tb+to,tC=ty;tC<tx;tC++){var tw=-2*tu*tc*td[tC]*tf[tm]/tb;tm===tC&&(tw+=Math.pow(tb,-tc)),tw*=th[tm],tp[tC]+=tw}}return Ln(tp,h.shape)},o.prototype.multinomial=function(h,g,te,tr){Hh(h,"multinomial");for(var to=g?h:nU(h),tu=to.shape[0],tc=to.shape[1],tl=Gn([tu,te],"int32"),th=this.readSync(tl.dataId),td=this.readSync(to.dataId),tf=0;tf<tu;++tf){var tp=tf*tc,tv=new Float32Array(tc-1);tv[0]=td[tp];for(var tm=1;tm<tv.length;++tm)tv[tm]=tv[tm-1]+td[tp+tm];for(var tg=nh(tr.toString()),ty=tf*te,tx=0;tx<te;++tx){var tb=tg();th[ty+tx]=tv.length;for(var tC=0;tC<tv.length;tC++)if(tb<tv[tC]){th[ty+tx]=tC;break}}}return tl},o.prototype.oneHot=function(h,g,te,tr){Hh(h,"oneHot");var to=new Float32Array(h.size*g);to.fill(tr);for(var tu=this.readSync(h.dataId),tc=0;tc<h.size;++tc)tu[tc]>=0&&tu[tc]<g&&(to[tc*g+tu[tc]]=te);return Bn(to,[h.size,g],"int32")},o.prototype.nonMaxSuppression=function(h,g,te,tr,to){return Hh(h,"nonMaxSuppression"),jo(this.readSync(h.dataId),this.readSync(g.dataId),te,tr,to)},o.prototype.fft=function(h){return this.fftBatch(h,!1)},o.prototype.ifft=function(h){return this.fftBatch(h,!0)},o.prototype.fftBatch=function(h,g){for(var te=h.shape[0],tr=h.shape[1],to=dr(h.shape,"float32"),tu=dr(h.shape,"float32"),tc=tJ(h).as2D(te,tr),tl=tQ(h).as2D(te,tr),th=0;th<te;th++)for(var td=tc.slice([th,0],[1,tr]),tf=tl.slice([th,0],[1,tr]),tp=tY(td,tf),tv=this.readSync(this.fftImpl(tp,g).dataId),tm=0;tm<tr;tm++){var tg=zo(tv,tm);to.values[th*tr+tm]=tg.real,tu.values[th*tr+tm]=tg.imag}return tY(to.toTensor(),tu.toTensor()).as2D(te,tr)},o.prototype.fftImpl=function(h,g){var te=h.as1D(),tr=te.size;if(this.isExponentOf2(tr)){var to=this.fftRadix2(te,tr,g).as2D(h.shape[0],h.shape[1]);return g&&(to=tY(tJ(to).div(On(tr)),tQ(to).div(On(tr)))),to}var tu=this.readSync(h.dataId),tc=function(h){for(var g=new Float32Array(h.length/2),te=new Float32Array(h.length/2),tr=0;tr<h.length;tr+=2)g[tr/2]=h[tr],te[tr/2]=h[tr+1];return{real:g,imag:te}}(this.fourierTransformByMatmul(tu,tr,g));return tY(tc.real,tc.imag).as2D(h.shape[0],h.shape[1])},o.prototype.isExponentOf2=function(h){return 0==(h&h-1)},o.prototype.fftRadix2=function(h,g,te){if(1===g)return h;var tr=this.readSync(h.dataId),to=g/2,tu=function(h){for(var g=Math.ceil(h.length/4),te=new Float32Array(g),tr=new Float32Array(g),to=0;to<h.length;to+=4)te[Math.floor(to/4)]=h[to],tr[Math.floor(to/4)]=h[to+1];return{real:te,imag:tr}}(tr),tc=tY(tu.real,tu.imag).as1D(),tl=function(h){for(var g=Math.floor(h.length/4),te=new Float32Array(g),tr=new Float32Array(g),to=2;to<h.length;to+=4)te[Math.floor(to/4)]=h[to],tr[Math.floor(to/4)]=h[to+1];return{real:te,imag:tr}}(tr),th=tY(tl.real,tl.imag).as1D();tc=this.fftRadix2(tc,to,te),th=this.fftRadix2(th,to,te);var td=function(h,g){for(var te=new Float32Array(h/2),tr=new Float32Array(h/2),to=0;to<Math.ceil(h/2);to++){var tu=(g?2:-2)*Math.PI*(to/h);te[to]=Math.cos(tu),tr[to]=Math.sin(tu)}return{real:te,imag:tr}}(g,te),tf=tY(td.real,td.imag).mul(th),tp=tc.add(tf),tv=tc.sub(tf);return tY(tJ(tp).concat(tJ(tv)),tQ(tp).concat(tQ(tv))).as1D()},o.prototype.fourierTransformByMatmul=function(h,g,te){for(var tr=new Float32Array(2*g),to=0;to<g;to++){for(var tu,tc,tl,th=0,td=0,tf=0;tf<g;tf++){var tp=function(h,g,te){var tr=(te?2:-2)*Math.PI*(h/g);return{real:Math.cos(tr),imag:Math.sin(tr)}}(to*tf,g,te),tv=zo(h,tf);th+=tv.real*tp.real-tv.imag*tp.imag,td+=tv.real*tp.imag+tv.imag*tp.real}te&&(th/=g,td/=g),tu=th,tc=td,tr[2*(tl=to)]=tu,tr[2*tl+1]=tc}return tr},o.prototype.depthToSpace=function(h,g,te){C("NHWC"===te,function(){return"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+te}),C(g>1,function(){return"blockSize should be > 1 for depthToSpace, but was: "+g});for(var tr=h.shape[0],to=h.shape[1],tu=h.shape[2],tc=h.shape[3],tl=to*g,th=tu*g,td=tc/(g*g),tf=this.readSync(h.dataId),tp=new Float32Array(tr*tl*th*td),tv=0,tm=0;tm<tr;++tm)for(var tg=0;tg<tl;++tg)for(var ty=Math.floor(tg/g),tx=tg%g,tb=0;tb<th;++tb)for(var tC=Math.floor(tb/g),tw=(tx*g+tb%g)*td,tE=0;tE<td;++tE){var tR=tE+tw+tc*(tC+tu*(ty+to*tm));tp[tv++]=tf[tR]}return Ln(tp,[tr,tl,th,td])},o.prototype.broadcastedBinaryOp=function(h,g,te,tr){var to=Ro(h.shape,g.shape),tu=dr(to,te),tc=this.readSync(h.dataId),tl=this.readSync(g.dataId),th=Co(h.shape,to),td=Co(g.shape,to),tf=tu.values;if(th.length+td.length===0)for(var tp=0;tp<tf.length;++tp)tf[tp]=tr(tc[tp%tc.length],tl[tp%tl.length]);else{var tv=this.bufferSync(h),tm=this.bufferSync(g);for(tp=0;tp<tf.length;++tp)(function(te){var to=tu.indexToLoc(te),tp=to.slice(-h.rank);th.forEach(function(h){return tp[h]=0});var tg=tv.locToIndex(tp),ty=to.slice(-g.rank);td.forEach(function(h){return ty[h]=0});var tx=tm.locToIndex(ty);tf[te]=tr(tc[tg],tl[tx])})(tp)}return tu.toTensor()},o.prototype.broadcastedBinaryComplexOp=function(h,g,te){var tr=Ro(h.shape,g.shape),to=dr(tr,"float32"),tu=dr(tr,"float32"),tc=this.readSync(h.dataId),tl=this.readSync(g.dataId),th=Co(h.shape,tr),td=Co(g.shape,tr),tf=to.values,tp=tu.values;if(th.length+td.length===0)for(var tv=0;tv<tf.length;tv++){var tm=tv%tc.length,tg=tv%tl.length,ty=te(tc[2*tm],tc[2*tm+1],tl[2*tg],tl[2*tg+1]);tf[tv]=ty.real,tp[tv]=ty.imag}else{var tx=this.bufferSync(this.data.get(h.dataId).complexTensors.real),tb=this.bufferSync(this.data.get(g.dataId).complexTensors.real);for(tv=0;tv<tf.length;tv++)(function(tr){var tu=to.indexToLoc(tr),tv=tu.slice(-h.rank);th.forEach(function(h){return tv[h]=0});var tm=tx.locToIndex(tv),tg=tu.slice(-g.rank);td.forEach(function(h){return tg[h]=0});var ty=tb.locToIndex(tg),tC=te(tc[2*tm],tc[2*tm+1],tl[2*ty],tl[2*ty+1]);tf[tr]=tC.real,tp[tr]=tC.imag})(tv)}return this.complex(to.toTensor(),tu.toTensor())},o.prototype.split=function(h,g,te){return Zo(h,g,te)},o.prototype.dispose=function(){},o.prototype.floatPrecision=function(){return 32},o.prototype.epsilon=function(){return 1e-7},o.prototype.cropAndResize=function(h,g,te,tr,to,tu){for(var tc=h.shape,tl=tc[0],th=tc[1],td=tc[2],tf=tc[3],tp=g.shape[0],tv=tr[0],tm=tr[1],tg=dr([tp,tv,tm,tf],"float32"),ty=this.readSync(g.dataId),tx=this.readSync(te.dataId),tb=this.readSync(h.dataId),tC=h.strides,tw=tg.strides,tE=0;tE<tp;tE++){var tR=4*tE,tI=ty[tR],tk=ty[tR+1],tA=ty[tR+2],tS=ty[tR+3],tD=tx[tE];if(!(tD>=tl))for(var tN=tv>1?(tA-tI)*(th-1)/(tv-1):0,tT=tm>1?(tS-tk)*(td-1)/(tm-1):0,tF=0;tF<tv;tF++){var tO,t_=tv>1?tI*(th-1)+tF*tN:.5*(tI+tA)*(th-1);if(t_<0||t_>th-1)for(var tM=0;tM<tm;tM++)for(var tB=0;tB<tf;tB++){var tP=tB+tM*tw[2]+tF*tw[1]+tE*tw[0];tg.values[tP]=tu}else if("bilinear"===to){var tL=Math.floor(t_),tW=Math.ceil(t_),tV=t_-tL;for(tM=0;tM<tm;tM++)if((tO=tm>1?tk*(td-1)+tM*tT:.5*(tk+tS)*(td-1))<0||tO>td-1)for(tB=0;tB<tf;tB++)tP=tB+tM*tw[2]+tF*tw[1]+tE*tw[0],tg.values[tP]=tu;else{var tU=Math.floor(tO),tz=Math.ceil(tO),tH=tO-tU;for(tB=0;tB<tf;tB++){var tG=tb[tP=tB+tU*tC[2]+tL*tC[1]+tD*tC[0]],tq=tb[tP=tB+tz*tC[2]+tL*tC[1]+tD*tC[0]],tK=tb[tP=tB+tU*tC[2]+tW*tC[1]+tD*tC[0]],tj=tG+(tq-tG)*tH,tX=tK+(tb[tP=tB+tz*tC[2]+tW*tC[1]+tD*tC[0]]-tK)*tH;tP=tB+tM*tw[2]+tF*tw[1]+tE*tw[0],tg.values[tP]=tj+(tX-tj)*tV}}}else for(tM=0;tM<tm;++tM)if((tO=tm>1?tk*(td-1)+tM*tT:.5*(tk+tS)*(td-1))<0||tO>td-1)for(tB=0;tB<tf;tB++)tP=tB+tM*tw[2]+tF*tw[1]+tE*tw[0],tg.values[tP]=tu;else{var t$=Math.round(tO),tY=Math.round(t_);for(tB=0;tB<tf;tB++){var tJ=tB+t$*tC[2]+tY*tC[1]+tD*tC[0],tQ=tB+tM*tw[2]+tF*tw[1]+tE*tw[0];tg.values[tQ]=tb[tJ]}}}}return tg.toTensor()},o.prototype.sparseToDense=function(h,g,te,tr){var to=Zr(0,h,te),tu=to.sliceRank,tc=to.numUpdates,tl=to.sliceSize,th=to.strides,td=to.outputSize;return this.scatter(h,g,te,td,tl,tc,tu,th,tr,!1)},o.prototype.gatherND=function(h,g){var te=g.shape,tr=te[te.length-1],to=jr(h,g),tu=to[0],tc=to[1],tl=to[2],th=to[3];if(0===tc)return Fn([],tu,h.dtype);for(var td=new tv([tc,tl],h.dtype),tf=this.readSync(g.dataId),tp=this.readSync(h.dataId),tm=0;tm<tc;tm++){for(var tg=[],ty=0,tx=0;tx<tr;tx++){var tb=tf[tm*tr+tx];ty+=tb*th[tx],tg.push(tb)}if(ty<0||ty>=h.size/tl)throw Error("Invalid indices: "+tg+" does not index into "+h.shape);for(var tC=0;tC<tl;tC++)td.values[tm*tl+tC]=tp[ty*tl+tC]}return td.toTensor().reshape(tu)},o.prototype.scatterND=function(h,g,te){var tr=Zr(0,h,te),to=tr.sliceRank,tu=tr.numUpdates,tc=tr.sliceSize,tl=tr.strides,th=tr.outputSize,td=On(0);return this.scatter(h,g,te,th,tc,tu,to,tl,td,!0)},o.prototype.fill=function(h,g,te){var tr=P(te=te||j(g),k(h));return tr.fill(g),tM.makeTensor(tr,h,te,this)},o.prototype.onesLike=function(h){if("string"===h.dtype)throw Error("onesLike is not supported for string tensors");return this.fill(h.shape,1,h.dtype)},o.prototype.zerosLike=function(h){var g=P(h.dtype,k(h.shape));return this.makeOutput(g,h.shape,h.dtype)},o.prototype.linspace=function(h,g,te){return Wo(h,g,te)},o.prototype.scatter=function(h,g,te,tr,to,tu,tc,tl,th,td){var tf=[tr/to,to],tp=this.readSync(h.dataId),tm=this.readSync(g.dataId);if(0===tr)return Fn([],te,g.dtype);var tg=new tv(tf,g.dtype);tg.values.fill(this.readSync(th.dataId)[0]);for(var ty=0;ty<tu;ty++){for(var tx=[],tb=0,tC=0;tC<tc;tC++){var tw=tp[ty*tc+tC];tx.push(tw),tb+=tw*tl[tC]}if(tb<0||tb>=tr/to)throw Error("Invalid indices: "+tx+" does not index into "+te);for(var tE=0;tE<to;tE++)td?tg.values[tb*to+tE]+=tm[ty*to+tE]:tg.values[tb*to+tE]=0===g.rank?tm[0]:tm[ty*to+tE]}return tg.toTensor().reshape(te)},o}(nG);tM.registerBackend("cpu",function(){return new aE},1);for(var aR=0,aI=[{kernelName:"NonMaxSuppressionV5",backendName:"cpu",kernelFunc:function(h){var g=h.inputs,te=h.backend,tr=h.attrs,to=g.boxes,tu=g.scores,tc=tr.maxOutputSize,tl=tr.iouThreshold,th=tr.scoreThreshold,td=tr.softNmsSigma;Hh(to,"NonMaxSuppressionWithScore");var tf=Xo(te.data.get(to.dataId).values,te.data.get(tu.dataId).values,tc,tl,th,td);return[tf.selectedIndices,tf.selectedScores]}},{kernelName:"Square",backendName:"cpu",kernelFunc:function(h){var g=h.inputs,te=h.backend,tr=g.x;Hh(tr,"square");for(var to=te.data.get(tr.dataId).values,tu=new Float32Array(to.length),tc=0;tc<to.length;++tc){var tl=to[tc];tu[tc]=tl*tl}return{dataId:te.write(tu,tr.shape,tr.dtype),shape:tr.shape,dtype:tr.dtype}}},{kernelName:eN,backendName:"cpu",kernelFunc:function(h){var g=h.inputs,te=h.backend,tr=g.a,to=g.b;Hh([tr,to],eN);var tu=te.data.get(tr.dataId).values,tc=te.data.get(to.dataId).values,tl=function(h,g,te,tr,to,tu){var tc=Ro(h,g),tl=tc.length,th=$(tc),td=B(to,k(tc)),tf=h.length,tp=g.length,tv=$(h),tm=$(g),tg=Co(h,tc),ty=Co(g,tc);if(tg.length+ty.length===0)for(var tx=0;tx<td.length;++tx)td[tx]=tu(te[tx%te.length],tr[tx%tr.length]);else for(tx=0;tx<td.length;++tx)!function(h){var g=it(h,tl,th),to=g.slice(-tf);tg.forEach(function(h){return to[h]=0});var tc=at(to,tf,tv),tx=g.slice(-tp);ty.forEach(function(h){return tx[h]=0});var tb=at(tx,tp,tm);td[h]=tu(te[tc],tr[tb])}(tx);return[td,tc]}(tr.shape,to.shape,tu,tc,tr.dtype,function(h,g){var te=h-g;return te*te}),th=tl[0],td=tl[1];return{dataId:te.write(th,td,tr.dtype),shape:td,dtype:tr.dtype}}}];aR<aI.length;aR++)d(aI[aR]);for(var ak,aA,aS,$h=function(h){this.variableNames=["A"];var g=ua(),te=h[0],tr=h[1];this.outputShape=h,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+tr+".0, "+te+".0);\n\n        vec4 values = "+g.texture2D+"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    "},Qh=function(h){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;var g=ua(),te=h[0],tr=h[1];this.outputShape=h,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2("+tr+".0, "+te+".0);\n            vec4 values = "+g.texture2D+"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        "+g.output+" = result;\n      }\n    "},aD=0,aN=[{kernelName:"FromPixels",backendName:"webgl",kernelFunc:function(h){var g=h.inputs,te=h.backend,tr=h.attrs,to=g.pixels,tu=tr.numChannels,tc="undefined"!=typeof HTMLVideoElement&&to instanceof HTMLVideoElement,th="undefined"!=typeof HTMLImageElement&&to instanceof HTMLImageElement,td=tc?[to.videoWidth,to.videoHeight]:[to.width,to.height],tf=td[0],tp=td[1],tv=[tp,tf],tm=[tp,tf,tu];(th||tc)&&(null==aS&&(aS=document.createElement("canvas").getContext("2d")),aS.canvas.width=tf,aS.canvas.height=tp,aS.drawImage(to,0,0,tf,tp),to=aS.canvas);var tg=te.makeTensorInfo(tv,"int32");te.texData.get(tg.dataId).usage=tL.PIXELS,te.gpgpu.uploadPixelDataToTexture(te.getTexture(tg.dataId),to);var ty=tl.getBool("WEBGL_PACK")?new Qh(tm):new $h(tm),tx=te.runWebGLProgram(ty,[tg],"int32");return te.disposeData(tg.dataId),tx}},{kernelName:"NonMaxSuppressionV5",backendName:"webgl",kernelFunc:function(h){var g=h.inputs,te=h.backend,tr=h.attrs;dn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var to=g.boxes,tu=g.scores,tc=tr.maxOutputSize,tl=tr.iouThreshold,th=tr.scoreThreshold,td=tr.softNmsSigma,tf=Xo(te.readSync(to.dataId),te.readSync(tu.dataId),tc,tl,th,td);return[tf.selectedIndices,tf.selectedScores]}},{kernelName:"Square",backendName:"webgl",kernelFunc:function(h){var g=h.inputs,te=h.backend,tr=g.x,to=new Cs(tr.shape,"return x * x;");return te.runWebGLProgram(to,[tr],tr.dtype)}},{kernelName:eN,backendName:"webgl",kernelFunc:function(h){var g=h.inputs,te=h.backend,tr=g.a,to=g.b,tu=tl.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("return (a - b) * (a - b);",tr.shape,to.shape):new Ba("return (a - b) * (a - b);",tr.shape,to.shape);return te.compileAndRun(tu,[tr,to])}}];aD<aN.length;aD++)d(aN[aD]);for(var aT=0,aF=[{kernelName:"Square",gradFunc:function(h,g){var te=g[0];return{x:function(){return h.mul(te.toFloat().mul(2))}}}},{kernelName:eN,gradFunc:function(h,g){var te=g[0],tr=g[1],to=On(2);return{a:function(){return rB(h,rB(to,rU(te,tr)))},b:function(){return rB(h,rB(to,rU(tr,te)))}}}}];aT<aF.length;aT++)!function(h){var g=h.kernelName;td.has(g)&&console.warn("Overriding the gradient for '"+g+"'"),td.set(g,h)}(aF[aT]);var aO=function(){function t(){}return t.prototype.fetch=function(h,g){return fetch(h,g)},t.prototype.now=function(){return performance.now()},t.prototype.encode=function(h,g){if("utf-8"!==g&&"utf8"!==g)throw Error("Browser's encoder only supports utf-8, but got "+g);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(h)},t.prototype.decode=function(h,g){return new TextDecoder(g).decode(h)},t}();tl.get("IS_BROWSER")&&tl.setPlatform("browser",new aO);var a_,aM=function(){function t(){this.util=te(753),this.textEncoder=new this.util.TextEncoder}return t.prototype.fetch=function(h,g){return null!=tl.global.fetch?tl.global.fetch(h,g):(null==a_&&(a_=te(522)),a_(h,g))},t.prototype.now=function(){var h=to.hrtime();return 1e3*h[0]+h[1]/1e6},t.prototype.encode=function(h,g){if("utf-8"!==g&&"utf8"!==g)throw Error("Node built-in encoder only supports utf-8, but got "+g);return this.textEncoder.encode(h)},t.prototype.decode=function(h,g){return 0===h.length?"":new this.util.TextDecoder(g).decode(h)},t}();tl.get("IS_NODE")&&tl.setPlatform("node",new aM);var aB={float32:4,int32:4,uint16:2,uint8:1,bool:1};function cf(h,g){for(var te={},tr=0,to=0;to<g.length;to++)!function(g){var to=g.name,tu=g.dtype,tc=g.shape,tl=k(tc),th=void 0;if("quantization"in g){var td=g.quantization;if("uint8"!==td.dtype&&"uint16"!==td.dtype)throw Error("Weight "+g.name+" has unknown quantization dtype "+td.dtype+". Supported quantization dtypes are: 'uint8' and 'uint16'.");var tf=aB[td.dtype],tp=h.slice(tr,tr+tl*tf),tv="uint8"===td.dtype?new Uint8Array(tp):new Uint16Array(tp);if("float32"===tu)th=Float32Array.from(tv,function(h){return h*td.scale+td.min});else{if("int32"!==tu)throw Error("Unsupported dtype in weight '"+to+"': "+tu);th=Int32Array.from(tv,function(h){return Math.round(h*td.scale+td.min)})}tr+=tl*tf}else if("string"===tu){var tm=k(g.shape);th=[];for(var tg=0;tg<tm;tg++){var ty=new Uint32Array(h.slice(tr,tr+4))[0];tr+=4;var tx=new Uint8Array(h.slice(tr,tr+ty));th.push(tx),tr+=ty}}else{var tb=aB[tu];if(tp=h.slice(tr,tr+tl*tb),"float32"===tu)th=new Float32Array(tp);else if("int32"===tu)th=new Int32Array(tp);else{if("bool"!==tu)throw Error("Unsupported dtype in weight '"+to+"': "+tu);th=new Uint8Array(tp)}tr+=tl*tb}te[to]=Fn(th,tc,tu)}(g[to]);return te}var aP=void 0!==tu&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function ff(h){return aP?tu.byteLength(h):new Blob([h]).size}function df(h){var g=0;h.forEach(function(h){g+=h.byteLength});var te=new Uint8Array(g),tr=0;return h.forEach(function(h){te.set(new Uint8Array(h),tr),tr+=h.byteLength}),te.buffer}function pf(h){for(h=h.trim();h.endsWith("/");)h=h.slice(0,h.length-1);var g=h.split("/");return g[g.length-1]}function vf(h){if(h.modelTopology instanceof ArrayBuffer)throw Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==h.modelTopology?0:ff(JSON.stringify(h.modelTopology)),weightSpecsBytes:null==h.weightSpecs?0:ff(JSON.stringify(h.weightSpecs)),weightDataBytes:null==h.weightData?0:h.weightData.byteLength}}var aL=function(){function t(){this.saveRouters=[],this.loadRouters=[]}return t.getInstance=function(){return null==t.instance&&(t.instance=new t),t.instance},t.registerSaveRouter=function(h){t.getInstance().saveRouters.push(h)},t.registerLoadRouter=function(h){t.getInstance().loadRouters.push(h)},t.getSaveHandlers=function(h){return t.getHandlers(h,"save")},t.getLoadHandlers=function(h,g){return t.getHandlers(h,"load",g)},t.getHandlers=function(h,g,te){var tr=[];return("load"===g?t.getInstance().loadRouters:t.getInstance().saveRouters).forEach(function(g){var to=g(h,te);null!==to&&tr.push(to)}),tr},t}(),aW=function(){function t(){this.managers={}}return t.getInstance=function(){return null==t.instance&&(t.instance=new t),t.instance},t.registerManager=function(h,g){C(null!=h,function(){return"scheme must not be undefined or null."}),h.endsWith("://")&&(h=h.slice(0,h.indexOf("://"))),C(h.length>0,function(){return"scheme must not be an empty string."});var te=t.getInstance();C(null==te.managers[h],function(){return"A model store manager is already registered for scheme '"+h+"'."}),te.managers[h]=g},t.getManager=function(h){var g=this.getInstance().managers[h];if(null==g)throw Error("Cannot find model manager for scheme '"+h+"'");return g},t.getSchemes=function(){return Object.keys(this.getInstance().managers)},t}();function xf(h){if(-1===h.indexOf("://"))throw Error("The url string provided does not contain a scheme. Supported schemes are: "+aW.getSchemes().join(","));return{scheme:h.split("://")[0],path:h.split("://")[1]}}function bf(h,g,te){return void 0===te&&(te=!1),n(this,void 0,void 0,function(){var tr,to,tu,tc,tl,th,td,tf,tp;return r(this,function(tv){switch(tv.label){case 0:return C(h!==g,function(){return"Old path and new path are the same: '"+h+"'"}),C((tr=aL.getLoadHandlers(h)).length>0,function(){return"Copying failed because no load handler is found for source URL "+h+"."}),C(tr.length<2,function(){return"Copying failed because more than one ("+tr.length+") load handlers for source URL "+h+"."}),to=tr[0],C((tu=aL.getSaveHandlers(g)).length>0,function(){return"Copying failed because no save handler is found for destination URL "+g+"."}),C(tu.length<2,function(){return"Copying failed because more than one ("+tr.length+") save handlers for destination URL "+g+"."}),tc=tu[0],tl=xf(h).scheme,th=xf(h).path,td=tl===xf(h).scheme,[4,to.load()];case 1:return tf=tv.sent(),te&&td?[4,aW.getManager(tl).removeModel(th)]:[3,3];case 2:tv.sent(),tv.label=3;case 3:return[4,tc.save(tf)];case 4:return tp=tv.sent(),!te||td?[3,6]:[4,aW.getManager(tl).removeModel(th)];case 5:tv.sent(),tv.label=6;case 6:return[2,tp.modelArtifactsInfo]}})})}var aV="models_store",aU="model_info_store";function Ef(){if(!tl.getBool("IS_BROWSER"))throw Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");var h=window||self,g=h.indexedDB||h.mozIndexedDB||h.webkitIndexedDB||h.msIndexedDB||h.shimIndexedDB;if(null==g)throw Error("The current browser does not appear to support IndexedDB.");return g}function Rf(h){var g=h.result;g.createObjectStore(aV,{keyPath:"modelPath"}),g.createObjectStore(aU,{keyPath:"modelPath"})}var az=function(){function t(h){if(this.indexedDB=Ef(),null==h||!h)throw Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=h}return t.prototype.save=function(h){return n(this,void 0,void 0,function(){return r(this,function(g){if(h.modelTopology instanceof ArrayBuffer)throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return[2,this.databaseAction(this.modelPath,h)]})})},t.prototype.load=function(){return n(this,void 0,void 0,function(){return r(this,function(h){return[2,this.databaseAction(this.modelPath)]})})},t.prototype.databaseAction=function(h,g){var te=this;return new Promise(function(h,tr){var to=te.indexedDB.open("tensorflowjs",1);to.onupgradeneeded=function(){return Rf(to)},to.onsuccess=function(){var tu=to.result;if(null==g){var tc=tu.transaction(aV,"readonly"),tl=tc.objectStore(aV).get(te.modelPath);tl.onsuccess=function(){if(null==tl.result)return tu.close(),tr(Error("Cannot find model with path '"+te.modelPath+"' in IndexedDB."));h(tl.result.modelArtifacts)},tl.onerror=function(h){return tu.close(),tr(tl.error)},tc.oncomplete=function(){return tu.close()}}else{var th,td=vf(g),tf=tu.transaction(aU,"readwrite"),tp=tf.objectStore(aU),tv=tp.put({modelPath:te.modelPath,modelArtifactsInfo:td});tv.onsuccess=function(){var to=(th=tu.transaction(aV,"readwrite")).objectStore(aV).put({modelPath:te.modelPath,modelArtifacts:g,modelArtifactsInfo:td});to.onsuccess=function(){return h({modelArtifactsInfo:td})},to.onerror=function(h){var g=(tp=tf.objectStore(aU)).delete(te.modelPath);g.onsuccess=function(){return tu.close(),tr(to.error)},g.onerror=function(h){return tu.close(),tr(to.error)}}},tv.onerror=function(h){return tu.close(),tr(tv.error)},tf.oncomplete=function(){null==th?tu.close():th.oncomplete=function(){return tu.close()}}}},to.onerror=function(h){return tr(to.error)}})},t.URL_SCHEME="indexeddb://",t}(),kf=function(h){var g;return tl.getBool("IS_BROWSER")&&!Array.isArray(h)&&h.startsWith(az.URL_SCHEME)?(g=h.slice(az.URL_SCHEME.length),new az(g)):null};aL.registerSaveRouter(kf),aL.registerLoadRouter(kf);var aH=function(){function t(){this.indexedDB=Ef()}return t.prototype.listModels=function(){return n(this,void 0,void 0,function(){var h=this;return r(this,function(g){return[2,new Promise(function(g,te){var tr=h.indexedDB.open("tensorflowjs",1);tr.onupgradeneeded=function(){return Rf(tr)},tr.onsuccess=function(){var h=tr.result,to=h.transaction(aU,"readonly"),tu=to.objectStore(aU).getAll();tu.onsuccess=function(){for(var h={},te=0,tr=tu.result;te<tr.length;te++){var to=tr[te];h[to.modelPath]=to.modelArtifactsInfo}g(h)},tu.onerror=function(g){return h.close(),te(tu.error)},to.oncomplete=function(){return h.close()}},tr.onerror=function(h){return te(tr.error)}})]})})},t.prototype.removeModel=function(h){return n(this,void 0,void 0,function(){var g=this;return r(this,function(te){return h=h.startsWith(az.URL_SCHEME)?h.slice(az.URL_SCHEME.length):h,[2,new Promise(function(te,tr){var to=g.indexedDB.open("tensorflowjs",1);to.onupgradeneeded=function(){return Rf(to)},to.onsuccess=function(){var g,tu=to.result,tc=tu.transaction(aU,"readwrite"),tl=tc.objectStore(aU),th=tl.get(h);th.onsuccess=function(){if(null==th.result)return tu.close(),tr(Error("Cannot find model with path '"+h+"' in IndexedDB."));var to=tl.delete(h),i=function(){var to=(g=tu.transaction(aV,"readwrite")).objectStore(aV).delete(h);to.onsuccess=function(){return te(th.result.modelArtifactsInfo)},to.onerror=function(h){return tr(th.error)}};to.onsuccess=i,to.onerror=function(h){return i(),tu.close(),tr(th.error)}},th.onerror=function(h){return tu.close(),tr(th.error)},tc.oncomplete=function(){null==g?tu.close():g.oncomplete=function(){return tu.close()}}},to.onerror=function(h){return tr(to.error)}})]})})},t}();if(tl.getBool("IS_BROWSER"))try{aW.registerManager(az.URL_SCHEME,new aH)}catch(h){}var aG="tensorflowjs_models",aq="info";function Mf(h){return{info:[aG,h,aq].join("/"),topology:[aG,h,"model_topology"].join("/"),weightSpecs:[aG,h,"weight_specs"].join("/"),weightData:[aG,h,"weight_data"].join("/"),modelMetadata:[aG,h,"model_metadata"].join("/")}}var aK=function(){function t(h){if(!tl.getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==h||!h)throw Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=h,this.keys=Mf(this.modelPath)}return t.prototype.save=function(h){return n(this,void 0,void 0,function(){var g,te,tr;return r(this,function(to){if(h.modelTopology instanceof ArrayBuffer)throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");g=JSON.stringify(h.modelTopology),te=JSON.stringify(h.weightSpecs),tr=vf(h);try{return this.LS.setItem(this.keys.info,JSON.stringify(tr)),this.LS.setItem(this.keys.topology,g),this.LS.setItem(this.keys.weightSpecs,te),this.LS.setItem(this.keys.weightData,function(h){if(aP)return tu.from(h).toString("base64");for(var g=new Uint8Array(h),te="",tr=0,to=g.length;tr<to;tr++)te+=String.fromCharCode(g[tr]);return btoa(te)}(h.weightData)),this.LS.setItem(this.keys.modelMetadata,JSON.stringify({format:h.format,generatedBy:h.generatedBy,convertedBy:h.convertedBy,userDefinedMetadata:h.userDefinedMetadata})),[2,{modelArtifactsInfo:tr}]}catch(h){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),Error("Failed to save model '"+this.modelPath+"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes="+tr.modelTopologyBytes+", weightSpecsBytes="+tr.weightSpecsBytes+", weightDataBytes="+tr.weightDataBytes+".")}return[2]})})},t.prototype.load=function(){return n(this,void 0,void 0,function(){var h,g,te,tr,to,tc,tl;return r(this,function(th){if(null==(h=JSON.parse(this.LS.getItem(this.keys.info))))throw Error("In local storage, there is no model with name '"+this.modelPath+"'");if("JSON"!==h.modelTopologyType)throw Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");if(g={},null==(te=JSON.parse(this.LS.getItem(this.keys.topology))))throw Error("In local storage, the topology of model '"+this.modelPath+"' is missing.");if(g.modelTopology=te,null==(tr=JSON.parse(this.LS.getItem(this.keys.weightSpecs))))throw Error("In local storage, the weight specs of model '"+this.modelPath+"' are missing.");if(g.weightSpecs=tr,null!=(to=this.LS.getItem(this.keys.modelMetadata))&&(tc=JSON.parse(to),g.format=tc.format,g.generatedBy=tc.generatedBy,g.convertedBy=tc.convertedBy,g.userDefinedMetadata=tc.userDefinedMetadata),null==(tl=this.LS.getItem(this.keys.weightData)))throw Error("In local storage, the binary weight values of model '"+this.modelPath+"' are missing.");return g.weightData=function(h){if(aP){var g=tu.from(h,"base64");return g.buffer.slice(g.byteOffset,g.byteOffset+g.byteLength)}for(var te=atob(h),tr=new Uint8Array(te.length),to=0;to<te.length;++to)tr.set([te.charCodeAt(to)],to);return tr.buffer}(tl),[2,g]})})},t.URL_SCHEME="localstorage://",t}(),Lf=function(h){var g;return tl.getBool("IS_BROWSER")&&!Array.isArray(h)&&h.startsWith(aK.URL_SCHEME)?(g=h.slice(aK.URL_SCHEME.length),new aK(g)):null};aL.registerSaveRouter(Lf),aL.registerLoadRouter(Lf);var aj=function(){function t(){C(tl.getBool("IS_BROWSER"),function(){return"Current environment is not a web browser"}),C("undefined"==typeof window||void 0!==window.localStorage,function(){return"Current browser does not appear to support localStorage"}),this.LS=window.localStorage}return t.prototype.listModels=function(){return n(this,void 0,void 0,function(){var h,g,te,tr,to;return r(this,function(tu){for(h={},g=aG+"/",te="/"+aq,tr=0;tr<this.LS.length;++tr)(to=this.LS.key(tr)).startsWith(g)&&to.endsWith(te)&&(h[function(h){var g=h.split("/");if(g.length<3)throw Error("Invalid key format: "+h);return g.slice(1,g.length-1).join("/")}(to)]=JSON.parse(this.LS.getItem(to)));return[2,h]})})},t.prototype.removeModel=function(h){return n(this,void 0,void 0,function(){var g,te;return r(this,function(tr){if(g=Mf(h=h.startsWith(aK.URL_SCHEME)?h.slice(aK.URL_SCHEME.length):h),null==this.LS.getItem(g.info))throw Error("Cannot find model at path '"+h+"'");return te=JSON.parse(this.LS.getItem(g.info)),this.LS.removeItem(g.info),this.LS.removeItem(g.topology),this.LS.removeItem(g.weightSpecs),this.LS.removeItem(g.weightData),[2,te]})})},t}();if(tl.getBool("IS_BROWSER"))try{aW.registerManager(aK.URL_SCHEME,new aj)}catch(h){}function Gf(h){return new Promise(function(h){return setTimeout(h)}).then(h)}var aX=function(){function t(h){if(!tl.getBool("IS_BROWSER"))throw Error("browserDownloads() cannot proceed because the current environment is not a browser.");h.startsWith(t.URL_SCHEME)&&(h=h.slice(t.URL_SCHEME.length)),null!=h&&0!==h.length||(h="model"),this.modelTopologyFileName=h+".json",this.weightDataFileName=h+".weights.bin"}return t.prototype.save=function(h){return n(this,void 0,void 0,function(){var g,te,tr,to,tu,tc;return r(this,function(tl){switch(tl.label){case 0:if("undefined"==typeof document)throw Error("Browser downloads are not supported in this environment since `document` is not present");if(g=window.URL.createObjectURL(new Blob([h.weightData],{type:"application/octet-stream"})),!(h.modelTopology instanceof ArrayBuffer))return[3,1];throw Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");case 1:return te=[{paths:["./"+this.weightDataFileName],weights:h.weightSpecs}],tr={modelTopology:h.modelTopology,format:h.format,generatedBy:h.generatedBy,convertedBy:h.convertedBy,weightsManifest:te},to=window.URL.createObjectURL(new Blob([JSON.stringify(tr)],{type:"application/json"})),(tu=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor).download=this.modelTopologyFileName,tu.href=to,[4,Gf(function(){return tu.dispatchEvent(new MouseEvent("click"))})];case 2:return tl.sent(),null==h.weightData?[3,4]:((tc=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor).download=this.weightDataFileName,tc.href=g,[4,Gf(function(){return tc.dispatchEvent(new MouseEvent("click"))})]);case 3:tl.sent(),tl.label=4;case 4:return[2,{modelArtifactsInfo:vf(h)}]}})})},t.URL_SCHEME="downloads://",t}(),a$=function(){function t(h){if(null==h||h.length<1)throw Error("When calling browserFiles, at least 1 file is required, but received "+h);this.files=h}return t.prototype.load=function(){return n(this,void 0,void 0,function(){var h,g,te=this;return r(this,function(tr){return h=this.files[0],g=this.files.slice(1),[2,new Promise(function(tr,to){var tu=new FileReader;tu.onload=function(tu){var tc=JSON.parse(tu.target.result),tl=tc.modelTopology;if(null!=tl){0===g.length&&tr({modelTopology:tl});var th=tc.weightsManifest;if(null!=th){try{td=te.checkManifestAndWeightFiles(th,g)}catch(h){return void to(h)}var td,tf=[],tp=[],tv=[];th.forEach(function(h){h.paths.forEach(function(h){tp.push(h),tv.push(null)}),tf.push.apply(tf,h.weights)}),th.forEach(function(h){h.paths.forEach(function(h){var g=new FileReader;g.onload=function(g){var te=g.target.result;tv[tp.indexOf(h)]=te,-1===tv.indexOf(null)&&tr({modelTopology:tl,weightSpecs:tf,weightData:df(tv),format:tc.format,generatedBy:tc.generatedBy,convertedBy:tc.convertedBy,userDefinedMetadata:tc.userDefinedMetadata})},g.onerror=function(g){return to("Failed to weights data from file of path '"+h+"'.")},g.readAsArrayBuffer(td[h])})})}else to(Error("weightManifest field is missing from file "+h.name))}else to(Error("modelTopology field is missing from file "+h.name))},tu.onerror=function(g){return to("Failed to read model topology and weights manifest JSON from file '"+h.name+"'. BrowserFiles supports loading Keras-style tf.Model artifacts only.")},tu.readAsText(h)})]})})},t.prototype.checkManifestAndWeightFiles=function(h,g){for(var te=[],tr=g.map(function(h){return pf(h.name)}),to={},tu=0;tu<h.length;tu++)h[tu].paths.forEach(function(h){var tu=pf(h);if(-1!==te.indexOf(tu))throw Error("Duplicate file basename found in weights manifest: '"+tu+"'");if(te.push(tu),-1===tr.indexOf(tu))throw Error("Weight file with basename '"+tu+"' is not provided.");to[h]=g[tr.indexOf(tu)]});if(te.length!==g.length)throw Error("Mismatch in the number of files in weights manifest ("+te.length+") and the number of weight files provided ("+g.length+").");return to},t}();function Kf(h,g,te,tr){C(null!=h&&Array.isArray(h)&&h.length>0,function(){return"promises must be a none empty array"}),to=te=null==te?0:te,tu=tr=null==tr?1:tr,C(to>=0&&to<=1,function(){return"Progress fraction must be in range [0, 1], but got startFraction "+to}),C(tu>=0&&tu<=1,function(){return"Progress fraction must be in range [0, 1], but got endFraction "+tu}),C(tu>=to,function(){return"startFraction must be no more than endFraction, but got startFraction "+to+" and endFraction "+tu});var to,tu,tc=0;return Promise.all(h.map(function(to){return to.then(function(to){return g(te+ ++tc/h.length*(tr-te)),to}),to}))}function jf(h,g){return n(this,void 0,void 0,function(){var te,tr,to,tu,tc,th,td,tf,tp;return r(this,function(tv){switch(tv.label){case 0:return null==g&&(g={}),te=null==g.fetchFunc?tl.platform.fetch:g.fetchFunc,tr=h.map(function(h){return te(h,g.requestInit,{isBinary:!0})}),to=0,tu=.5,null!=g.onProgress?[3,2]:[4,Promise.all(tr)];case 1:return tc=tv.sent(),[3,4];case 2:return[4,Kf(tr,g.onProgress,to,tu)];case 3:tc=tv.sent(),tv.label=4;case 4:return th=tc.map(function(h){return h.arrayBuffer()}),td=.5,tf=1,null!=g.onProgress?[3,6]:[4,Promise.all(th)];case 5:return tp=tv.sent(),[3,8];case 6:return[4,Kf(th,g.onProgress,td,tf)];case 7:tp=tv.sent(),tv.label=8;case 8:return[2,tp]}})})}function Xf(h){var g=this;return function(te,tr,to){return void 0===tr&&(tr=""),n(g,void 0,void 0,function(){var g,tu,tc,tl,th,td,tf,tp,tv;return r(this,function(tm){switch(tm.label){case 0:if(g=te.map(function(){return!1}),tu={},tc=null!=to?to.map(function(){return!1}):[],tl=[],te.forEach(function(h,te){var tr=0;h.weights.forEach(function(h){var th=aB["quantization"in h?h.quantization.dtype:h.dtype]*k(h.shape),l=function(){g[te]=!0,null==tu[te]&&(tu[te]=[]),tu[te].push({manifestEntry:h,groupOffset:tr,sizeBytes:th})};null!=to?to.forEach(function(g,te){g===h.name&&(l(),tc[te]=!0)}):l(),tl.push(h.name),tr+=th})}),!tc.every(function(h){return h}))throw Error("Could not find weights in manifest with names: "+to.filter(function(h,g){return!tc[g]}).join(", ")+". \nManifest JSON has weights with names: "+tl.join(", ")+".");return th=g.reduce(function(h,g,te){return g&&h.push(te),h},[]),td=[],th.forEach(function(h){te[h].paths.forEach(function(h){var g=tr+(tr.endsWith("/")?"":"/")+h;td.push(g)})}),[4,h(td)];case 1:return tf=tm.sent(),tp={},tv=0,th.forEach(function(h){for(var g=te[h].paths.length,tr=0,to=0;to<g;to++)tr+=tf[tv+to].byteLength;for(var tc=new ArrayBuffer(tr),tl=new Uint8Array(tc),th=0,td=0;td<g;td++){var tm=new Uint8Array(tf[tv+td]);tl.set(tm,th),th+=tm.byteLength}tu[h].forEach(function(h){var g=cf(tc.slice(h.groupOffset,h.groupOffset+h.sizeBytes),[h.manifestEntry]);for(var te in g)tp[te]=g[te]}),tv+=g}),[2,tp]}})})}}aL.registerSaveRouter(function(h){var g;return tl.getBool("IS_BROWSER")&&!Array.isArray(h)&&h.startsWith(aX.URL_SCHEME)?(void 0===(g=h.slice(aX.URL_SCHEME.length))&&(g="model"),new aX(g)):null});var aY=function(){function t(h,g){if(this.DEFAULT_METHOD="POST",null==g&&(g={}),this.weightPathPrefix=g.weightPathPrefix,this.onProgress=g.onProgress,null!=g.fetchFunc?(C("function"==typeof g.fetchFunc,function(){return"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"}),this.fetch=g.fetchFunc):this.fetch=tl.platform.fetch,C(null!=h&&h.length>0,function(){return"URL path for http must not be null, undefined or empty."}),Array.isArray(h)&&C(2===h.length,function(){return"URL paths for http must have a length of 2, (actual length is "+h.length+")."}),this.path=h,null!=g.requestInit&&null!=g.requestInit.body)throw Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=g.requestInit||{}}return t.prototype.save=function(h){return n(this,void 0,void 0,function(){var g,te,tr,to;return r(this,function(tu){switch(tu.label){case 0:if(h.modelTopology instanceof ArrayBuffer)throw Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");return(g=Object.assign({method:this.DEFAULT_METHOD},this.requestInit)).body=new FormData,te=[{paths:["./model.weights.bin"],weights:h.weightSpecs}],tr={modelTopology:h.modelTopology,format:h.format,generatedBy:h.generatedBy,convertedBy:h.convertedBy,userDefinedMetadata:h.userDefinedMetadata,weightsManifest:te},g.body.append("model.json",new Blob([JSON.stringify(tr)],{type:"application/json"}),"model.json"),null!=h.weightData&&g.body.append("model.weights.bin",new Blob([h.weightData],{type:"application/octet-stream"}),"model.weights.bin"),[4,this.fetch(this.path,g)];case 1:if((to=tu.sent()).ok)return[2,{modelArtifactsInfo:vf(h),responses:[to]}];throw Error("BrowserHTTPRequest.save() failed due to HTTP response status "+to.status+".")}})})},t.prototype.load=function(){return n(this,void 0,void 0,function(){var h,g,te,tr,to,tu,tc,tl,th,td,tf,tp;return r(this,function(tv){switch(tv.label){case 0:return[4,this.fetch(this.path,this.requestInit)];case 1:if(!(h=tv.sent()).ok)throw Error("Request to "+this.path+" failed with status code "+h.status+". Please verify this URL points to the model JSON of the model to load.");tv.label=2;case 2:return tv.trys.push([2,4,,5]),[4,h.json()];case 3:return g=tv.sent(),[3,5];case 4:throw tv.sent(),te="Failed to parse model JSON of response from "+this.path+".",this.path.endsWith(".pb")?te+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":te+=" Please make sure the server is serving valid JSON for this request.",Error(te);case 5:if(tr=g.modelTopology,to=g.weightsManifest,tu=g.generatedBy,tc=g.convertedBy,tl=g.format,th=g.userDefinedMetadata,null==tr&&null==to)throw Error("The JSON from HTTP path "+this.path+" contains neither model topology or manifest for weights.");return null==to?[3,7]:[4,this.loadWeights(to)];case 6:td=(tp=tv.sent())[0],tf=tp[1],tv.label=7;case 7:return[2,{modelTopology:tr,weightSpecs:td,weightData:tf,userDefinedMetadata:th,generatedBy:tu,convertedBy:tc,format:tl}]}})})},t.prototype.loadWeights=function(h){return n(this,void 0,void 0,function(){var g,te,tr,to,tu,tc,tl,th,td,tf;return r(this,function(tp){switch(tp.label){case 0:var tv,tm,tg;for(tm=(tv=Array.isArray(this.path)?this.path[1]:this.path).lastIndexOf("/"),tg=tv.lastIndexOf("?"),te=(g=[tv.substring(0,tm)+"/",tg>tm?tv.substring(tg):""])[0],tr=g[1],to=this.weightPathPrefix||te,tu=[],tc=0,tl=h;tc<tl.length;tc++)th=tl[tc],tu.push.apply(tu,th.weights);return td=[],h.forEach(function(h){h.paths.forEach(function(h){td.push(to+h+tr)})}),[4,jf(td,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress})];case 1:return tf=tp.sent(),[2,[tu,df(tf)]]}})})},t.URL_SCHEME_REGEX=/^https?:\/\//,t}();function $f(h){return null!=h.match(aY.URL_SCHEME_REGEX)}var Qf=function(h,g){return"undefined"==typeof fetch?null:(Array.isArray(h)?h.every(function(h){return $f(h)}):$f(h))?Jf(h,{onProgress:g}):null};function Jf(h,g){return new aY(h,g)}aL.registerSaveRouter(Qf),aL.registerLoadRouter(Qf);var aJ=function(){function t(h){this.modelArtifacts=h}return t.prototype.load=function(){return n(this,void 0,void 0,function(){return r(this,function(h){return[2,this.modelArtifacts]})})},t}(),aQ=function(){function t(h){this.saveHandler=h}return t.prototype.save=function(h){return n(this,void 0,void 0,function(){return r(this,function(g){return[2,this.saveHandler(h)]})})},t}(),aZ=Object.freeze({browserFiles:function(h){return new a$(h)},browserHTTPRequest:function(h,g){return Jf(h,g)},concatenateArrayBuffers:df,decodeWeights:cf,encodeWeights:function(h,g){return n(this,void 0,void 0,function(){var te,tr,to,tu,tc,tl=this;return r(this,function(th){switch(th.label){case 0:for(te=[],tr=[],to=Array.isArray(h)?h.map(function(h){return h.name}):Object.keys(h),tu=function(tu){var tc=to[tu],th=Array.isArray(h)?h[tu].tensor:h[tc];if("float32"!==th.dtype&&"int32"!==th.dtype&&"bool"!==th.dtype&&"string"!==th.dtype)throw Error("Unsupported dtype in weight '"+tc+"': "+th.dtype);var td={name:tc,shape:th.shape,dtype:th.dtype};if("string"===th.dtype){var tf=new Promise(function(h){return n(tl,void 0,void 0,function(){var g,te,tr,to,tu,tc,tl;return r(this,function(td){switch(td.label){case 0:return[4,th.bytes()];case 1:for(te=(g=td.sent()).reduce(function(h,g){return h+g.length},0)+4*g.length,tr=new Uint8Array(te),to=0,tu=0;tu<g.length;tu++)tc=g[tu],tl=new Uint8Array(new Uint32Array([tc.length]).buffer),tr.set(tl,to),to+=4,tr.set(tc,to),to+=tc.length;return h(tr),[2]}})})});tr.push(tf)}else tr.push(th.data());null!=g&&(td.group=g),te.push(td)},tc=0;tc<to.length;++tc)tu(tc);return[4,Promise.all(tr)];case 1:return[2,{data:function(h){if(null===h)throw Error("Invalid input value: "+JSON.stringify(h));var g=0,te=[];h.forEach(function(h){if(g+=h.byteLength,te.push(h.byteLength===h.buffer.byteLength?h:new h.constructor(h)),!(h instanceof Float32Array||h instanceof Int32Array||h instanceof Uint8Array))throw Error("Unsupported TypedArray subtype: "+h.constructor.name)});var tr=new Uint8Array(g),to=0;return te.forEach(function(h){tr.set(new Uint8Array(h.buffer),to),to+=h.byteLength}),tr.buffer}(th.sent()),specs:te}]}})})},fromMemory:function(h,g,te,tr){return 1==arguments.length?null!=h.modelTopology||null!=h.weightSpecs?new aJ(h):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new aJ({modelTopology:h})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new aJ({modelTopology:h,weightSpecs:g,weightData:te,trainingConfig:tr}))},getLoadHandlers:function(h,g){return aL.getLoadHandlers(h,g)},getModelArtifactsInfoForJSON:vf,getSaveHandlers:function(h){return aL.getSaveHandlers(h)},http:Jf,isHTTPScheme:$f,loadWeights:function(h,g,te,tr){return void 0===g&&(g=""),n(this,void 0,void 0,function(){return r(this,function(to){return[2,Xf(function(h){return jf(h,{requestInit:tr})})(h,g,te)]})})},registerLoadRouter:function(h){return aL.registerLoadRouter(h)},registerSaveRouter:function(h){return aL.registerSaveRouter(h)},weightsLoaderFactory:Xf,withSaveHandler:function(h){return new aQ(h)},copyModel:function(h,g){return n(this,void 0,void 0,function(){return r(this,function(te){return[2,bf(h,g,!1)]})})},listModels:function(){return n(this,void 0,void 0,function(){var h,g,te,tr,to,tu,tc;return r(this,function(tl){switch(tl.label){case 0:h=aW.getSchemes(),g={},te=0,tr=h,tl.label=1;case 1:return te<tr.length?(to=tr[te],[4,aW.getManager(to).listModels()]):[3,4];case 2:for(tc in tu=tl.sent())g[to+"://"+tc]=tu[tc];tl.label=3;case 3:return te++,[3,1];case 4:return[2,g]}})})},moveModel:function(h,g){return n(this,void 0,void 0,function(){return r(this,function(te){return[2,bf(h,g,!0)]})})},removeModel:function(h){return n(this,void 0,void 0,function(){var g;return r(this,function(te){return g=xf(h),[2,aW.getManager(g.scheme).removeModel(g.path)]})})}});Object.freeze({confusionMatrix:An({confusionMatrix_:function(h,g,te){var tr=mn(h,"labels","confusionMatrix"),to=mn(g,"predictions","confusionMatrix");C(null==te||te>0&&Number.isInteger(te),function(){return"If provided, numClasses must be a positive integer, but got "+te}),C(1===tr.rank,function(){return"Expected the rank of labels to be 1, but got "+tr.rank}),C(1===to.rank,function(){return"Expected the rank of predictions to be 1, but got "+to.rank}),C(tr.shape[0]===to.shape[0],function(){return"Mismatch in the number of examples: "+tr.shape[0]+" vs. "+to.shape[0]+". Labels and predictions should have the same number of elements."}),C(te>0&&Number.isInteger(te),function(){return"numClasses is required to be a positive integer, but got "+te});var tu=nR(tr.asType("int32"),te),tc=nR(to.asType("int32"),te);return tu.transpose().matMul(tc).asType("int32")}})});var a0=Object.freeze({toPixels:function(h,g){return n(this,void 0,void 0,function(){var te,tr,to,tu,tc,tl,th,td,tf,tp,tv,tm,tg,ty,tb,tC,tw,tE,tR,tI,tk,tA,tS;return r(this,function(tD){switch(tD.label){case 0:if(te=mn(h,"img","toPixels"),h instanceof tx||(te=te.toInt()),2!==te.rank&&3!==te.rank)throw Error("toPixels only supports rank 2 or 3 tensors, got rank "+te.rank+".");if(to=(tr=te.shape.slice(0,2))[0],tu=tr[1],(tc=2===te.rank?1:te.shape[2])>4||2===tc)throw Error("toPixels only supports depth of size 1, 3 or 4 but got "+tc);return[4,te.data()];case 1:return tl=tD.sent(),th=te.min(),td=te.max(),[4,Promise.all([th.data(),td.data()])];case 2:if(tp=(tf=tD.sent())[0],tv=tf[1],tm=tp[0],tg=tv[0],th.dispose(),td.dispose(),"float32"===te.dtype){if(tm<0||tg>1)throw Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range ["+tm+" - "+tg+"].")}else{if("int32"!==te.dtype)throw Error("Unsupported type for toPixels: "+te.dtype+". Please use float32 or int32 tensors.");if(tm<0||tg>255)throw Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range ["+tm+" - "+tg+"].")}for(ty="float32"===te.dtype?255:1,tb=new Uint8ClampedArray(tu*to*4),tC=0;tC<to*tu;++tC)tw=void 0,tE=void 0,tR=void 0,tI=void 0,1===tc?(tw=tl[tC]*ty,tE=tl[tC]*ty,tR=tl[tC]*ty,tI=255):3===tc?(tw=tl[3*tC]*ty,tE=tl[3*tC+1]*ty,tR=tl[3*tC+2]*ty,tI=255):4===tc&&(tw=tl[4*tC]*ty,tE=tl[4*tC+1]*ty,tR=tl[4*tC+2]*ty,tI=tl[4*tC+3]*ty),tb[(tk=4*tC)+0]=Math.round(tw),tb[tk+1]=Math.round(tE),tb[tk+2]=Math.round(tR),tb[tk+3]=Math.round(tI);return null!=g&&(g.width=tu,g.height=to,tA=g.getContext("2d"),tS=new ImageData(tb,tu,to),tA.putImageData(tS,0,0)),te!==h&&te.dispose(),[2,tb]}})})},fromPixels:An({fromPixels_:function(h,g){if(void 0===g&&(g=3),g>4)throw Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==h)throw Error("pixels passed to tf.browser.fromPixels() can not be null");var te=!1,to=!1,tu=!1,tc=!1,tl=!1;if(h.data instanceof Uint8Array)te=!0;else if("undefined"!=typeof ImageData&&h instanceof ImageData)to=!0;else if("undefined"!=typeof HTMLVideoElement&&h instanceof HTMLVideoElement)tu=!0;else if("undefined"!=typeof HTMLImageElement&&h instanceof HTMLImageElement)tc=!0;else{if(null==h.getContext)throw Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was "+h.constructor.name);tl=!0}if(tu&&tu&&h.readyState<2)throw Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(null!=l("FromPixels",tM.backendName))return tM.runKernel("FromPixels",{pixels:h},{numChannels:g});var th,td,tf=tu?[h.videoWidth,h.videoHeight]:[h.width,h.height],tp=tf[0],tv=tf[1];if(tl?th=h.getContext("2d").getImageData(0,0,tp,tv).data:to||te?th=h.data:(tc||tu)&&(null==tr&&(tr=document.createElement("canvas").getContext("2d")),tr.canvas.width=tp,tr.canvas.height=tv,tr.drawImage(h,0,0,tp,tv),th=tr.getImageData(0,0,tp,tv).data),4===g)td=new Int32Array(th);else{var tm=tp*tv;td=new Int32Array(tm*g);for(var tg=0;tg<tm;tg++)for(var ty=0;ty<g;++ty)td[tg*g+ty]=th[4*tg+ty]}return Pn(td,[tv,tp,g],"int32")}})}),a1=function(){function t(){}return t.prototype.getClassName=function(){return this.constructor.className},t.fromConfig=function(h,g){return new h(g)},t}(),a2=function(){function t(){this.classNameMap={}}return t.getMap=function(){return null==t.instance&&(t.instance=new t),t.instance},t.register=function(h){t.getMap().classNameMap[h.className]=[h,h.fromConfig]},t}();function cd(h){C(null!=h.className,function(){return"Class being registered does not have the static className property defined."}),C("string"==typeof h.className,function(){return"className is required to be a string, but got type "+typeof h.className}),C(h.className.length>0,function(){return"Class being registered has an empty-string as its className, which is disallowed."}),a2.register(h)}function dd(){return 32===tM.backend.floatPrecision()?.001:.1}function pd(h,g,te){var tr=!0;if((V(h)||V(g))&&(tr=!1),V(h)&&V(g)&&(tr=!0),tr){var to=h.constructor.name,tu=g.constructor.name;if(to!==tu)throw Error("Arrays are of different type. Actual: "+to+". Expected: "+tu)}if(Array.isArray(h)&&Array.isArray(g)){var tc=pn(h),tl=pn(g);if(!S(tc,tl))throw Error("Arrays have different shapes. Actual: ["+tc+"]. Expected: ["+tl+"]")}var th=V(h)?h:I(h),td=V(g)?g:I(g);if(th.length!==td.length)throw Error("Arrays have different lengths actual: "+th.length+" vs expected: "+td.length+".\nActual:   "+th+".\nExpected: "+td+".");for(var tf=0;tf<td.length;++tf){var tp=th[tf],tv=td[tf];if(!te(tp,tv))throw Error("Arrays differ: actual["+tf+"] = "+tp+", expected["+tf+"] = "+tv+".\nActual:   "+th+".\nExpected: "+td+".")}}function vd(h,g,te){return!isFinite(h)&&!isFinite(g)||!(isNaN(h)||isNaN(g)||Math.abs(h-g)>te)}Object.freeze({Serializable:a1,SerializationMap:a2,registerClass:cd}),Object.freeze({TEST_EPSILON_FLOAT16:.1,expectArraysClose:function(h,g,te){return null==te&&(te=dd()),pd(h,g,function(h,g){return vd(h,g,te)})},testEpsilon:dd,expectPromiseToFail:function(h,g){h().then(function(){return g.fail()},function(){return g()})},expectArraysEqual:function(h,g){var te="string"==typeof g||"number"==typeof g||"boolean"==typeof g?[g]:g;return H(h)||H(h[0])||H(g)||H(g[0])?pd(h,te,function(h,g){return h==g}):pd(h,g,function(h,g){return vd(h,g,0)})},expectNumbersClose:function(h,g,te){if(null==te&&(te=dd()),!vd(h,g,te))throw Error("Numbers differ: actual === "+h+", expected === "+g)},expectValuesInRange:function(h,g,te){for(var tr=0;tr<h.length;tr++)if(h[tr]<g||h[tr]>te)throw Error("Value out of range:"+h[tr]+" low: "+g+", high: "+te)},expectArrayBuffersEqual:function(h,g){expect(new Float32Array(h)).toEqual(new Float32Array(g))}}),Object.freeze({gpgpu_util:n1,webgl_util:tX,forceHalfFloat:function(){tl.set("WEBGL_FORCE_F16_TEXTURES",!0)},MathBackendWebGL:eS,setWebGLContext:Kt,GPGPUContext:n2});var a3=function(h){function o(){return null!==h&&h.apply(this,arguments)||this}return e(o,h),o.prototype.minimize=function(h,g,te){void 0===g&&(g=!1);var tr=this.computeGradients(h,te),to=tr.value,tu=tr.grads;if(null!=te){var tc=te.map(function(h){return{name:h.name,tensor:tu[h.name]}});this.applyGradients(tc)}else this.applyGradients(tu);return tn(tu),g?to:(to.dispose(),null)},Object.defineProperty(o.prototype,"iterations",{get:function(){return null==this.iterations_&&(this.iterations_=0),this.iterations_},enumerable:!0,configurable:!0}),o.prototype.incrementIterations=function(){this.iterations_=this.iterations+1},o.prototype.computeGradients=function(h,g){return function(h,g){C(X(h),function(){return"The f passed in variableGrads(f) must be a function"}),C(null==g||Array.isArray(g)&&g.every(function(h){return h instanceof tI}),function(){return"The varList passed in variableGrads(f, varList) must be an array of variables"});var te=null!=g;if(!te)for(var tr in g=[],tM.registeredVariables)g.push(tM.registeredVariables[tr]);var to=te?g.filter(function(h){return!h.trainable}):null,tu=g.length;C((g=g.filter(function(h){return h.trainable})).length>0,function(){return"variableGrads() expects at least one of the input variables to be trainable, but none of the "+tu+" variables is trainable."});var tc=tM.gradients(h,g,null,!0),tl=tc.value,th=tc.grads;C(th.some(function(h){return null!=h}),function(){return"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."}),C(0===tl.rank,function(){return"The f passed in variableGrads(f) must return a scalar, but it returned a rank-"+tl.rank+" tensor"});var td={};return g.forEach(function(h,g){null!=th[g]&&(td[h.name]=th[g])}),null!=to&&to.forEach(function(h){return td[h.name]=null}),{value:tl,grads:td}}(h,g)},o.prototype.dispose=function(){null!=this.iterations_&&tn(this.iterations_)},o.prototype.saveIterations=function(){return n(this,void 0,void 0,function(){return r(this,function(h){return null==this.iterations_&&(this.iterations_=0),[2,{name:"iter",tensor:On(this.iterations_,"int32")}]})})},o.prototype.getWeights=function(){return n(this,void 0,void 0,function(){return r(this,function(h){throw Error("getWeights() is not implemented for this optimizer yet.")})})},o.prototype.setWeights=function(h){return n(this,void 0,void 0,function(){return r(this,function(h){throw Error("setWeights() is not implemented for this optimizer class "+this.getClassName())})})},o.prototype.extractIterations=function(h){return n(this,void 0,void 0,function(){var g;return r(this,function(te){switch(te.label){case 0:return g=this,[4,h[0].tensor.data()];case 1:return g.iterations_=te.sent()[0],[2,h.slice(1)]}})})},o}(a1);Object.defineProperty(a3,Symbol.hasInstance,{value:function(h){return null!=h.minimize&&null!=h.computeGradients&&null!=h.applyGradients}});var a4=function(h){function o(g,te,tr){void 0===tr&&(tr=null);var to=h.call(this)||this;return to.learningRate=g,to.rho=te,to.epsilon=tr,to.accumulatedGrads=[],to.accumulatedUpdates=[],null==tr&&(to.epsilon=tM.backend.epsilon()),to}return e(o,h),o.prototype.applyGradients=function(h){var g=this;(Array.isArray(h)?h.map(function(h){return h.name}):Object.keys(h)).forEach(function(te,tr){var to=tM.registeredVariables[te];null==g.accumulatedGrads[tr]&&(g.accumulatedGrads[tr]={originalName:te+"/accum_grad",variable:Ze(function(){return t0(to).variable(!1)})}),null==g.accumulatedUpdates[tr]&&(g.accumulatedUpdates[tr]={originalName:te+"/accum_var",variable:Ze(function(){return t0(to).variable(!1)})});var tu=Array.isArray(h)?h[tr].tensor:h[te];if(null!=tu){var tc=g.accumulatedGrads[tr].variable,tl=g.accumulatedUpdates[tr].variable;Ze(function(){var h=tc.mul(g.rho).add(tu.square().mul(1-g.rho)),te=tl.add(g.epsilon).sqrt().div(tc.add(g.epsilon).sqrt()).mul(tu),tr=tl.mul(g.rho).add(te.square().mul(1-g.rho));tc.assign(h),tl.assign(tr);var th=te.mul(-g.learningRate).add(to);to.assign(th)})}}),this.incrementIterations()},o.prototype.dispose=function(){null!=this.accumulatedUpdates&&(tn(this.accumulatedGrads.map(function(h){return h.variable})),tn(this.accumulatedUpdates.map(function(h){return h.variable})))},o.prototype.getWeights=function(){return n(this,void 0,void 0,function(){var h;return r(this,function(g){switch(g.label){case 0:return h=this.accumulatedGrads.concat(this.accumulatedUpdates),[4,this.saveIterations()];case 1:return[2,[g.sent()].concat(h.map(function(h){return{name:h.originalName,tensor:h.variable}}))]}})})},o.prototype.setWeights=function(h){return n(this,void 0,void 0,function(){var g;return r(this,function(te){switch(te.label){case 0:return[4,this.extractIterations(h)];case 1:return g=(h=te.sent()).length/2,this.accumulatedGrads=h.slice(0,g).map(function(h){return{originalName:h.name,variable:h.tensor.variable(!1)}}),this.accumulatedUpdates=h.slice(g,2*g).map(function(h){return{originalName:h.name,variable:h.tensor.variable(!1)}}),[2]}})})},o.prototype.getConfig=function(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}},o.fromConfig=function(h,g){return new h(g.learningRate,g.rho,g.epsilon)},o.className="Adadelta",o}(a3);cd(a4);var a5=function(h){function o(g,te){void 0===te&&(te=.1);var tr=h.call(this)||this;return tr.learningRate=g,tr.initialAccumulatorValue=te,tr.accumulatedGrads=[],tr}return e(o,h),o.prototype.applyGradients=function(h){var g=this;(Array.isArray(h)?h.map(function(h){return h.name}):Object.keys(h)).forEach(function(te,tr){var to=tM.registeredVariables[te];null==g.accumulatedGrads[tr]&&(g.accumulatedGrads[tr]={originalName:te+"/accumulator",variable:Ze(function(){return Hn(to.shape,g.initialAccumulatorValue).variable(!1)})});var tu=Array.isArray(h)?h[tr].tensor:h[te];if(null!=tu){var tc=g.accumulatedGrads[tr].variable;Ze(function(){var h=tc.add(tu.square());tc.assign(h);var te=tu.div(h.add(tM.backend.epsilon()).sqrt()).mul(-g.learningRate).add(to);to.assign(te)})}}),this.incrementIterations()},o.prototype.dispose=function(){null!=this.accumulatedGrads&&tn(this.accumulatedGrads.map(function(h){return h.variable}))},o.prototype.getWeights=function(){return n(this,void 0,void 0,function(){return r(this,function(h){switch(h.label){case 0:return[4,this.saveIterations()];case 1:return[2,[h.sent()].concat(this.accumulatedGrads.map(function(h){return{name:h.originalName,tensor:h.variable}}))]}})})},o.prototype.setWeights=function(h){return n(this,void 0,void 0,function(){return r(this,function(g){switch(g.label){case 0:return[4,this.extractIterations(h)];case 1:return h=g.sent(),this.accumulatedGrads=h.map(function(h){return{originalName:h.name,variable:h.tensor.variable(!1)}}),[2]}})})},o.prototype.getConfig=function(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}},o.fromConfig=function(h,g){return new h(g.learningRate,g.initialAccumulatorValue)},o.className="Adagrad",o}(a3);cd(a5);var a6=function(h){function o(g,te,tr,to){void 0===to&&(to=null);var tu=h.call(this)||this;return tu.learningRate=g,tu.beta1=te,tu.beta2=tr,tu.epsilon=to,tu.accumulatedFirstMoment=[],tu.accumulatedSecondMoment=[],Ze(function(){tu.accBeta1=On(te).variable(),tu.accBeta2=On(tr).variable()}),null==to&&(tu.epsilon=tM.backend.epsilon()),tu}return e(o,h),o.prototype.applyGradients=function(h){var g=this,te=Array.isArray(h)?h.map(function(h){return h.name}):Object.keys(h);Ze(function(){var tr=rU(1,g.accBeta1),to=rU(1,g.accBeta2);te.forEach(function(te,tu){var tc=tM.registeredVariables[te];null==g.accumulatedFirstMoment[tu]&&(g.accumulatedFirstMoment[tu]={originalName:te+"/m",variable:Ze(function(){return t0(tc).variable(!1)})}),null==g.accumulatedSecondMoment[tu]&&(g.accumulatedSecondMoment[tu]={originalName:te+"/v",variable:Ze(function(){return t0(tc).variable(!1)})});var tl=Array.isArray(h)?h[tu].tensor:h[te];if(null!=tl){var th=g.accumulatedFirstMoment[tu].variable,td=g.accumulatedSecondMoment[tu].variable,tf=th.mul(g.beta1).add(tl.mul(1-g.beta1)),tp=td.mul(g.beta2).add(tl.square().mul(1-g.beta2)),tv=tf.div(tr),tm=tp.div(to);th.assign(tf),td.assign(tp);var tg=tv.div(tm.sqrt().add(g.epsilon)).mul(-g.learningRate).add(tc);tc.assign(tg)}}),g.accBeta1.assign(g.accBeta1.mul(g.beta1)),g.accBeta2.assign(g.accBeta2.mul(g.beta2))}),this.incrementIterations()},o.prototype.dispose=function(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&tn(this.accumulatedFirstMoment.map(function(h){return h.variable})),null!=this.accumulatedSecondMoment&&tn(this.accumulatedSecondMoment.map(function(h){return h.variable}))},o.prototype.getWeights=function(){return n(this,void 0,void 0,function(){var h;return r(this,function(g){switch(g.label){case 0:return h=this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment),[4,this.saveIterations()];case 1:return[2,[g.sent()].concat(h.map(function(h){return{name:h.originalName,tensor:h.variable}}))]}})})},o.prototype.setWeights=function(h){return n(this,void 0,void 0,function(){var g,te=this;return r(this,function(tr){switch(tr.label){case 0:return[4,this.extractIterations(h)];case 1:return h=tr.sent(),Ze(function(){te.accBeta1.assign(rL(te.beta1,te.iterations_+1)),te.accBeta2.assign(rL(te.beta2,te.iterations_+1))}),g=h.length/2,this.accumulatedFirstMoment=h.slice(0,g).map(function(h){return{originalName:h.name,variable:h.tensor.variable(!1)}}),this.accumulatedSecondMoment=h.slice(g,2*g).map(function(h){return{originalName:h.name,variable:h.tensor.variable(!1)}}),[2]}})})},o.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}},o.fromConfig=function(h,g){return new h(g.learningRate,g.beta1,g.beta2,g.epsilon)},o.className="Adam",o}(a3);cd(a6);var a8=function(h){function o(g,te,tr,to,tu){void 0===to&&(to=null),void 0===tu&&(tu=0);var tc=h.call(this)||this;return tc.learningRate=g,tc.beta1=te,tc.beta2=tr,tc.epsilon=to,tc.decay=tu,tc.accumulatedFirstMoment=[],tc.accumulatedWeightedInfNorm=[],Ze(function(){tc.iteration=On(0).variable(),tc.accBeta1=On(te).variable()}),null==to&&(tc.epsilon=tM.backend.epsilon()),tc}return e(o,h),o.prototype.applyGradients=function(h){var g=this,te=Array.isArray(h)?h.map(function(h){return h.name}):Object.keys(h);Ze(function(){var tr=rU(1,g.accBeta1),to=rk(-g.learningRate,g.iteration.mul(g.decay).add(1));te.forEach(function(te,tu){var tc=tM.registeredVariables[te];null==g.accumulatedFirstMoment[tu]&&(g.accumulatedFirstMoment[tu]={originalName:te+"/m",variable:t0(tc).variable(!1)}),null==g.accumulatedWeightedInfNorm[tu]&&(g.accumulatedWeightedInfNorm[tu]={originalName:te+"/v",variable:t0(tc).variable(!1)});var tl=Array.isArray(h)?h[tu].tensor:h[te];if(null!=tl){var th=g.accumulatedFirstMoment[tu].variable,td=g.accumulatedWeightedInfNorm[tu].variable,tf=th.mul(g.beta1).add(tl.mul(1-g.beta1)),tp=td.mul(g.beta2),tv=tl.abs(),tm=tp.maximum(tv);th.assign(tf),td.assign(tm);var tg=to.div(tr).mul(tf.div(tm.add(g.epsilon))).add(tc);tc.assign(tg)}}),g.iteration.assign(g.iteration.add(1)),g.accBeta1.assign(g.accBeta1.mul(g.beta1))}),this.incrementIterations()},o.prototype.dispose=function(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&tn(this.accumulatedFirstMoment.map(function(h){return h.variable})),null!=this.accumulatedWeightedInfNorm&&tn(this.accumulatedWeightedInfNorm.map(function(h){return h.variable}))},o.prototype.getWeights=function(){return n(this,void 0,void 0,function(){return r(this,function(h){throw Error("getWeights() is not implemented for Adamax yet.")})})},o.prototype.setWeights=function(h){return n(this,void 0,void 0,function(){return r(this,function(h){throw Error("setWeights() is not implemented for Adamax yet.")})})},o.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}},o.fromConfig=function(h,g){return new h(g.learningRate,g.beta1,g.beta2,g.epsilon,g.decay)},o.className="Adamax",o}(a3);cd(a8);var a7=function(h){function o(g){var te=h.call(this)||this;return te.learningRate=g,te.setLearningRate(g),te}return e(o,h),o.prototype.applyGradients=function(h){var g=this;(Array.isArray(h)?h.map(function(h){return h.name}):Object.keys(h)).forEach(function(te,tr){var to=Array.isArray(h)?h[tr].tensor:h[te];if(null!=to){var tu=tM.registeredVariables[te];Ze(function(){var h=g.c.mul(to).add(tu);tu.assign(h)})}}),this.incrementIterations()},o.prototype.setLearningRate=function(h){var g;this.learningRate=h,null!=this.c&&this.c.dispose(),this.c=(g=On(-h),tM.keep(g))},o.prototype.dispose=function(){this.c.dispose()},o.prototype.getWeights=function(){return n(this,void 0,void 0,function(){return r(this,function(h){switch(h.label){case 0:return[4,this.saveIterations()];case 1:return[2,[h.sent()]]}})})},o.prototype.setWeights=function(h){return n(this,void 0,void 0,function(){return r(this,function(g){switch(g.label){case 0:return[4,this.extractIterations(h)];case 1:if(0!==(h=g.sent()).length)throw Error("SGD optimizer does not have settable weights.");return[2]}})})},o.prototype.getConfig=function(){return{learningRate:this.learningRate}},o.fromConfig=function(h,g){return new h(g.learningRate)},o.className="SGD",o}(a3);cd(a7);var a9=function(h){function o(g,te,tr){void 0===tr&&(tr=!1);var to=h.call(this,g)||this;return to.learningRate=g,to.momentum=te,to.useNesterov=tr,to.accumulations=[],to.m=On(to.momentum),to}return e(o,h),o.prototype.applyGradients=function(h){var g=this;(Array.isArray(h)?h.map(function(h){return h.name}):Object.keys(h)).forEach(function(te,tr){var to=tM.registeredVariables[te];null==g.accumulations[tr]&&(g.accumulations[tr]={originalName:te+"/momentum",variable:Ze(function(){return t0(to).variable(!1)})});var tu=g.accumulations[tr].variable,tc=Array.isArray(h)?h[tr].tensor:h[te];null!=tc&&Ze(function(){var h,te=g.m.mul(tu).add(tc);h=g.useNesterov?g.c.mul(tc.add(te.mul(g.m))).add(to):g.c.mul(te).add(to),tu.assign(te),to.assign(h)})}),this.incrementIterations()},o.prototype.dispose=function(){this.m.dispose(),null!=this.accumulations&&tn(this.accumulations.map(function(h){return h.variable}))},o.prototype.setMomentum=function(h){this.momentum=h},o.prototype.getWeights=function(){return n(this,void 0,void 0,function(){return r(this,function(h){switch(h.label){case 0:return[4,this.saveIterations()];case 1:return[2,[h.sent()].concat(this.accumulations.map(function(h){return{name:h.originalName,tensor:h.variable}}))]}})})},o.prototype.setWeights=function(h){return n(this,void 0,void 0,function(){return r(this,function(g){switch(g.label){case 0:return[4,this.extractIterations(h)];case 1:return h=g.sent(),this.accumulations=h.map(function(h){return{originalName:h.name,variable:h.tensor.variable(!1)}}),[2]}})})},o.prototype.getConfig=function(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}},o.fromConfig=function(h,g){return new h(g.learningRate,g.momentum,g.useNesterov)},o.className="Momentum",o}(a7);cd(a9);var ie=function(h){function o(g,te,tr,to,tu){void 0===te&&(te=.9),void 0===tr&&(tr=0),void 0===to&&(to=null),void 0===tu&&(tu=!1);var tc=h.call(this)||this;if(tc.learningRate=g,tc.decay=te,tc.momentum=tr,tc.epsilon=to,tc.accumulatedMeanSquares=[],tc.accumulatedMoments=[],tc.accumulatedMeanGrads=[],tc.centered=tu,null==to&&(tc.epsilon=tM.backend.epsilon()),null==g)throw Error("learningRate for RMSPropOptimizer must be defined.");return tc}return e(o,h),o.prototype.applyGradients=function(h){var g=this;(Array.isArray(h)?h.map(function(h){return h.name}):Object.keys(h)).forEach(function(te,tr){var to=tM.registeredVariables[te];null==g.accumulatedMeanSquares[tr]&&(g.accumulatedMeanSquares[tr]={originalName:te+"/rms",variable:Ze(function(){return t0(to).variable(!1)})}),null==g.accumulatedMoments[tr]&&(g.accumulatedMoments[tr]={originalName:te+"/momentum",variable:Ze(function(){return t0(to).variable(!1)})}),null==g.accumulatedMeanGrads[tr]&&g.centered&&(g.accumulatedMeanGrads[tr]={originalName:te+"/mg",variable:Ze(function(){return t0(to).variable(!1)})});var tu=Array.isArray(h)?h[tr].tensor:h[te];if(null!=tu){var tc=g.accumulatedMeanSquares[tr].variable,tl=g.accumulatedMoments[tr].variable;Ze(function(){var h=tc.mul(g.decay).add(tu.square().mul(1-g.decay));if(g.centered){var te=g.accumulatedMeanGrads[tr].variable,th=te.mul(g.decay).add(tu.mul(1-g.decay)),td=tl.mul(g.momentum).add(tu.mul(g.learningRate).div(h.sub(th.square().add(g.epsilon)).sqrt()));tc.assign(h),te.assign(th),tl.assign(td);var tf=to.sub(td);to.assign(tf)}else{var tp=tc.mul(g.decay).add(tu.square().mul(1-g.decay));td=tl.mul(g.momentum).add(tu.mul(g.learningRate).div(tp.add(g.epsilon).sqrt())),tc.assign(tp),tl.assign(td),tf=to.sub(td),to.assign(tf)}})}}),this.incrementIterations()},o.prototype.dispose=function(){null!=this.accumulatedMeanSquares&&tn(this.accumulatedMeanSquares.map(function(h){return h.variable})),null!=this.accumulatedMeanGrads&&this.centered&&tn(this.accumulatedMeanGrads.map(function(h){return h.variable})),null!=this.accumulatedMoments&&tn(this.accumulatedMoments.map(function(h){return h.variable}))},o.prototype.getWeights=function(){return n(this,void 0,void 0,function(){var h;return r(this,function(g){switch(g.label){case 0:return h=this.accumulatedMeanSquares.concat(this.accumulatedMoments),this.centered&&h.push.apply(h,this.accumulatedMeanGrads),[4,this.saveIterations()];case 1:return[2,[g.sent()].concat(h.map(function(h){return{name:h.originalName,tensor:h.variable}}))]}})})},o.prototype.setWeights=function(h){return n(this,void 0,void 0,function(){var g;return r(this,function(te){switch(te.label){case 0:return[4,this.extractIterations(h)];case 1:return h=te.sent(),g=this.centered?h.length/3:h.length/2,this.accumulatedMeanSquares=h.slice(0,g).map(function(h){return{originalName:h.name,variable:h.tensor.variable(!1)}}),this.accumulatedMoments=h.slice(g,2*g).map(function(h){return{originalName:h.name,variable:h.tensor.variable(!1)}}),this.centered&&(this.accumulatedMeanGrads=h.slice(2*g,3*g).map(function(h){return{originalName:h.name,variable:h.tensor.variable(!1)}})),[2]}})})},o.prototype.getConfig=function(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}},o.fromConfig=function(h,g){return new h(g.learningRate,g.decay,g.momentum,g.epsilon,g.centered)},o.className="RMSProp",o}(a3);cd(ie);var ir=function(){function t(){}return t.sgd=function(h){return new a7(h)},t.momentum=function(h,g,te){return void 0===te&&(te=!1),new a9(h,g,te)},t.rmsprop=function(h,g,te,tr,to){return void 0===g&&(g=.9),void 0===te&&(te=0),void 0===tr&&(tr=null),void 0===to&&(to=!1),new ie(h,g,te,tr,to)},t.adam=function(h,g,te,tr){return void 0===h&&(h=.001),void 0===g&&(g=.9),void 0===te&&(te=.999),void 0===tr&&(tr=null),new a6(h,g,te,tr)},t.adadelta=function(h,g,te){return void 0===h&&(h=.001),void 0===g&&(g=.95),void 0===te&&(te=null),new a4(h,g,te)},t.adamax=function(h,g,te,tr,to){return void 0===h&&(h=.002),void 0===g&&(g=.9),void 0===te&&(te=.999),void 0===tr&&(tr=null),void 0===to&&(to=0),new a8(h,g,te,tr,to)},t.adagrad=function(h,g){return void 0===g&&(g=.1),new a5(h,g)},t}();ir.sgd,ir.momentum,ir.adadelta,ir.adagrad,ir.rmsprop,ir.adamax,ir.adam,"undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate&&setImmediate,tx.prototype.squaredDifference=function(h){return eT(this,h)},tg=aw}}]);