"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[711],{4277:function(g,te,tr){tr.d(te,{B10:function(){return ol},BHj:function(){return aA},CnO:function(){return oF},Fp7:function(){return oW},Gg6:function(){return nW},HHK:function(){return nU},IHx:function(){return rS},OI3:function(){return om},Qqt:function(){return eY},RRF:function(){return Mn},Tek:function(){return on},UYe:function(){return oX},U_I:function(){return of},W76:function(){return e2},XAC:function(){return nz},XD2:function(){return e6},XLQ:function(){return nM},XeE:function(){return Fn},Xhn:function(){return a6},_sB:function(){return oR},_wD:function(){return tk},dC7:function(){return rz},dt4:function(){return nw},esB:function(){return tb},hiC:function(){return rF},hlL:function(){return Hn},iD$:function(){return On},iUl:function(){return eK},io:function(){return a5},knu:function(){return nL},lls:function(){return Gn},luU:function(){return rj},lub:function(){return Ze},odF:function(){return Bn},p4s:function(){return oJ},tPi:function(){return oD},tgs:function(){return rx},vku:function(){return nk},wOQ:function(){return Pn},wS1:function(){return oI},yXz:function(){return Ln},zoF:function(){return t2}});var to,tu=tr(2601),tc=tr(263).Buffer,t=function(g,te){return(t=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(g,te){g.__proto__=te}||function(g,te){for(var tr in te)te.hasOwnProperty(tr)&&(g[tr]=te[tr])})(g,te)};function e(g,te){function r(){this.constructor=g}t(g,te),g.prototype=null===te?Object.create(te):(r.prototype=te.prototype,new r)}function n(g,te,tr,to){return new(tr||(tr=Promise))(function(tu,tc){function i(g){try{u(to.next(g))}catch(g){tc(g)}}function s(g){try{u(to.throw(g))}catch(g){tc(g)}}function u(g){g.done?tu(g.value):new tr(function(te){te(g.value)}).then(i,s)}u((to=to.apply(g,te||[])).next())})}function r(g,te){var tr,to,tu,tc,tl={label:0,sent:function(){if(1&tu[0])throw tu[1];return tu[1]},trys:[],ops:[]};return tc={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(tc[Symbol.iterator]=function(){return this}),tc;function s(tc){return function(th){return function(tc){if(tr)throw TypeError("Generator is already executing.");for(;tl;)try{if(tr=1,to&&(tu=2&tc[0]?to.return:tc[0]?to.throw||((tu=to.return)&&tu.call(to),0):to.next)&&!(tu=tu.call(to,tc[1])).done)return tu;switch(to=0,tu&&(tc=[2&tc[0],tu.value]),tc[0]){case 0:case 1:tu=tc;break;case 4:return tl.label++,{value:tc[1],done:!1};case 5:tl.label++,to=tc[1],tc=[0];continue;case 7:tc=tl.ops.pop(),tl.trys.pop();continue;default:if(!(tu=(tu=tl.trys).length>0&&tu[tu.length-1])&&(6===tc[0]||2===tc[0])){tl=0;continue}if(3===tc[0]&&(!tu||tc[1]>tu[0]&&tc[1]<tu[3])){tl.label=tc[1];break}if(6===tc[0]&&tl.label<tu[1]){tl.label=tu[1],tu=tc;break}if(tu&&tl.label<tu[2]){tl.label=tu[2],tl.ops.push(tc);break}tu[2]&&tl.ops.pop(),tl.trys.pop();continue}tc=te.call(g,tl)}catch(g){tc=[6,g],to=0}finally{tr=tu=0}if(5&tc[0])throw tc[1];return{value:tc[0]?tc[1]:void 0,done:!0}}([tc,th])}}}var tl=function(){function t(g){this.global=g,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}return t.prototype.setPlatform=function(g,te){null!=this.platform&&console.warn("Platform "+this.platformName+" has already been set. Overwriting the platform with "+te+"."),this.platformName=g,this.platform=te},t.prototype.registerFlag=function(g,te,tr){if(this.flagRegistry[g]={evaluationFn:te,setHook:tr},null!=this.urlFlags[g]){var to=this.urlFlags[g];console.warn("Setting feature override from URL "+g+": "+to+"."),this.set(g,to)}},t.prototype.get=function(g){return g in this.flags||(this.flags[g]=this.evaluateFlag(g)),this.flags[g]},t.prototype.getNumber=function(g){return this.get(g)},t.prototype.getBool=function(g){return this.get(g)},t.prototype.getFlags=function(){return this.flags},Object.defineProperty(t.prototype,"features",{get:function(){return this.flags},enumerable:!0,configurable:!0}),t.prototype.set=function(g,te){if(null==this.flagRegistry[g])throw Error("Cannot set flag "+g+" as it has not been registered.");this.flags[g]=te,null!=this.flagRegistry[g].setHook&&this.flagRegistry[g].setHook(te)},t.prototype.evaluateFlag=function(g){if(null==this.flagRegistry[g])throw Error("Cannot evaluate flag '"+g+"': no evaluation function found.");return this.flagRegistry[g].evaluationFn()},t.prototype.setFlags=function(g){this.flags=Object.assign({},g)},t.prototype.reset=function(){this.flags={},this.urlFlags={},this.populateURLFlags()},t.prototype.populateURLFlags=function(){var g=this;if(void 0!==this.global&&void 0!==this.global.location&&void 0!==this.global.location.search){var te,tr,to=(te=this.global.location.search,tr={},te.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,function(g){for(var te=[],to=1;to<arguments.length;to++)te[to-1]=arguments[to];return a(tr,te[0],te[1]),te.join("=")}),tr);"tfjsflags"in to&&to.tfjsflags.split(",").forEach(function(te){var tr=te.split(":"),to=tr[0],tu=tr[1];g.urlFlags[to]=function(g,te){if("true"===(te=te.toLowerCase())||"false"===te)return"true"===te;if(""+ +te===te)return+te;throw Error("Could not parse value flag value "+te+" for flag "+g+".")}(to,tu)})}},t}();function a(g,te,tr){g[decodeURIComponent(te)]=decodeURIComponent(tr||"")}var th=null,td=new Map,tf=new Map;function l(g,te){var tr=te+"_"+g;return td.get(tr)}function h(g){return tf.get(g)}function f(g){for(var te=td.entries(),tr=[];;){var to=te.next(),tu=to.done,tc=to.value;if(tu)break;var tl=tc[0],th=tc[1];tl.split("_")[0]===g&&tr.push(th)}return tr}function d(g){var te=g.kernelName,tr=g.backendName,to=tr+"_"+te;if(td.has(to))throw Error("The kernel '"+te+"' for backend '"+tr+"' is already registered");td.set(to,g)}function p(g){var te=g.kernelName;tf.has(te)&&console.warn("Overriding the gradient for '"+te+"'"),tf.set(te,g)}function y(g){for(var te=g.length,tr=0,to=0;te>0;)to=Math.random()*te|0,tr=g[--te],g[te]=g[to],g[to]=tr}function x(g,te,tr){return Math.max(g,Math.min(te,tr))}function b(g){return g%2==0?g:g+1}function w(g){for(var te=0,tr=0;tr<g.length;tr++)te+=g[tr];return te}function C(g,te){if(!g)throw Error("string"==typeof te?te:te())}function E(g,te,tr){void 0===tr&&(tr=""),C(S(g,te),function(){return tr+" Shapes "+g+" and "+te+" must match"})}function R(g){C(null!=g,function(){return"The input to the tensor constructor must be a non-null value."})}function I(g,te,tr){if(void 0===te&&(te=[]),void 0===tr&&(tr=!1),null==te&&(te=[]),Array.isArray(g)||V(g)&&!tr)for(var to=0;to<g.length;++to)I(g[to],te,tr);else te.push(g);return te}function k(g){if(0===g.length)return 1;for(var te=g[0],tr=1;tr<g.length;tr++)te*=g[tr];return te}function S(g,te){if(g===te)return!0;if(null==g||null==te||g.length!==te.length)return!1;for(var tr=0;tr<g.length;tr++)if(g[tr]!==te[tr])return!1;return!0}function A(g){return g%1==0}function D(g){if(null!=Math.tanh)return Math.tanh(g);if(g===1/0)return 1;if(g===-1/0)return -1;var te=Math.exp(2*g);return(te-1)/(te+1)}function T(g){var te=Math.ceil(Math.sqrt(g));return[te,Math.ceil(g/te)]}function N(g,te){return te<=g.length?g:g+" ".repeat(te-g.length)}function F(g,te,tr){return void 0===te&&(te=function(g){return 0}),new Promise(function(to,tu){var tc=0,i=function(){if(g())to();else{tc++;var tl=te(tc);null!=tr&&tc>=tr?tu():setTimeout(i,tl)}};i()})}function _(g,te){for(var tr=1,to=-1,tu=0;tu<g.length;++tu)if(g[tu]>=0)tr*=g[tu];else if(-1===g[tu]){if(-1!==to)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+to+" and dim "+tu);to=tu}else if(g[tu]<0)throw Error("Shapes can not be < 0. Found "+g[tu]+" at dim "+tu);if(-1===to){if(te>0&&te!==tr)throw Error("Size("+te+") must match the product of shape "+g);return g}if(0===tr)throw Error("Cannot infer the missing size in ["+g+"] when there are 0 elements");if(te%tr!=0)throw Error("The implicit shape can't be a fractional number. Got "+te+" / "+tr);var tc=g.slice();return tc[to]=te/tr,tc}function O(g,te){var tr=te.length;return C((g=null==g?te.map(function(g,te){return te}):[].concat(g)).every(function(g){return g>=-tr&&g<tr}),function(){return"All values in axis param must be in range [-"+tr+", "+tr+") but got axis "+g}),C(g.every(function(g){return A(g)}),function(){return"All values in axis param must be integers but got axis "+g}),g.map(function(g){return g<0?tr+g:g})}function M(g,te){for(var tr=[],to=[],tu=null!=te&&Array.isArray(te)&&0===te.length,tc=null==te||tu?null:O(te,g).sort(),tl=0,th=0;th<g.length;++th){if(null!=tc){if(tc[tl]===th&&1!==g[th])throw Error("Can't squeeze axis "+th+" since its dim '"+g[th]+"' is not 1");(null==tc[tl]||tc[tl]>th)&&1===g[th]&&(tr.push(g[th]),to.push(th)),tc[tl]<=th&&tl++}1!==g[th]&&(tr.push(g[th]),to.push(th))}return{newShape:tr,keptDims:to}}function B(g,te){var tr=null;if(null==g||"float32"===g)tr=new Float32Array(te);else if("int32"===g)tr=new Int32Array(te);else{if("bool"!==g)throw Error("Unknown data type "+g);tr=new Uint8Array(te)}return tr}function P(g,te){var tr=null;if(null==g||"float32"===g)tr=new Float32Array(te);else if("int32"===g)tr=new Int32Array(te);else if("bool"===g)tr=new Uint8Array(te);else{if("string"!==g)throw Error("Unknown data type "+g);tr=Array(te)}return tr}function L(g,te){for(var tr=0;tr<g.length;tr++){var to=g[tr];if(isNaN(to)||!isFinite(to))throw Error("A tensor of type "+te+" being uploaded contains "+to+".")}}function W(g){return"bool"===g||"complex64"===g||"float32"===g||"int32"===g||"string"===g}function U(g,te){return"complex64"!==te&&("float32"!==te||"complex64"===g)&&("int32"!==te||"float32"===g||"complex64"===g)&&("bool"!==te||"bool"!==g)}function V(g){return g instanceof Float32Array||g instanceof Int32Array||g instanceof Uint8Array}function z(g){if("float32"===g||"int32"===g)return 4;if("complex64"===g)return 8;if("bool"===g)return 1;throw Error("Unknown dtype "+g)}function G(g){if(null==g)return 0;var te=0;return g.forEach(function(g){return te+=g.length}),te}function H(g){return"string"==typeof g||g instanceof String}function q(g){return"boolean"==typeof g}function K(g){return"number"==typeof g}function j(g){return Array.isArray(g)?j(g[0]):g instanceof Float32Array?"float32":g instanceof Int32Array||g instanceof Uint8Array?"int32":K(g)?"float32":H(g)?"string":q(g)?"bool":"float32"}function X(g){return!!(g&&g.constructor&&g.call&&g.apply)}function Y(g,te){for(var tr=te;tr<g;++tr)if(g%tr==0)return tr;return g}function $(g){var te=g.length;if(te<2)return[];var tr=Array(te-1);tr[te-2]=g[te-1];for(var to=te-3;to>=0;--to)tr[to]=tr[to+1]*g[to+1];return tr}function Q(g,te,tr){if("string"===te)throw Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(g)&&(g=I(g)),tr&&L(g,te),(to=g)instanceof Float32Array&&"float32"===te||to instanceof Int32Array&&"int32"===te||to instanceof Uint8Array&&"bool"===te)return g;if(null==te||"float32"===te||"complex64"===te)return new Float32Array(g);if("int32"===te)return new Int32Array(g);if("bool"===te){for(var to,tu=new Uint8Array(g.length),tc=0;tc<tu.length;++tc)0!==Math.round(g[tc])&&(tu[tc]=1);return tu}throw Error("Unknown data type "+te)}function J(g,te){if(0===g.length)return te[0];var tr=g.reduce(function(g,te){return g*te});if(0===tr)return[];if(tr!==te.length)throw Error("["+g+"] does not match the input size.");return function t(g,te,tr){var to=[];if(1===te.length)for(var tu=te[0],tc=0;tc<tu;tc++)to[tc]=tr[g+tc];else{tu=te[0];var tl=te.slice(1),th=tl.reduce(function(g,te){return g*te});for(tc=0;tc<tu;tc++)to[tc]=t(g+tc*th,tl,tr)}return to}(0,g,te)}function Z(g,te){for(var tr=tt(g,te),to=0;to<tr.length;to++)tr[to]=1;return tr}function tt(g,te){if(null==te||"float32"===te||"complex64"===te)return new Float32Array(g);if("int32"===te)return new Int32Array(g);if("bool"===te)return new Uint8Array(g);throw Error("Unknown data type "+te)}function et(){return th.platform.now()}function nt(g){g.forEach(function(te){C(Number.isInteger(te)&&te>=0,function(){return"Tensor must have a shape comprised of positive integers but got shape ["+g+"]."})})}function rt(g,te){return void 0===te&&(te="utf-8"),te=te||"utf-8",th.platform.encode(g,te)}function ot(g,te){return void 0===te&&(te="utf-8"),te=te||"utf-8",th.platform.decode(g,te)}function at(g,te,tr){if(0===te)return 0;if(1===te)return g[0];for(var to=g[g.length-1],tu=0;tu<g.length-1;++tu)to+=tr[tu]*g[tu];return to}function it(g,te,tr){if(0===te)return[];if(1===te)return[g];for(var to=Array(te),tu=0;tu<to.length-1;++tu)to[tu]=Math.floor(g/tr[tu]),g-=to[tu]*tr[tu];return to[to.length-1]=g,to}Object.freeze({shuffle:y,clamp:x,nearestLargerEven:b,sum:w,randUniform:function(g,te){var tr=Math.random();return te*tr+(1-tr)*g},distSquared:function(g,te){for(var tr=0,to=0;to<g.length;to++){var tu=Number(g[to])-Number(te[to]);tr+=tu*tu}return tr},assert:C,assertShapesMatch:E,assertNonNull:R,flatten:I,sizeFromShape:k,isScalarShape:function(g){return 0===g.length},arraysEqual:S,isInt:A,tanh:D,sizeToSquarishShape:T,createShuffledIndices:function(g){for(var te=new Uint32Array(g),tr=0;tr<g;++tr)te[tr]=tr;return y(te),te},rightPad:N,repeatedTry:F,inferFromImplicitShape:_,parseAxisParam:O,squeezeShape:M,getTypedArrayFromDType:B,getArrayFromDType:P,checkConversionForErrors:L,isValidDtype:W,hasEncodingLoss:U,isTypedArray:V,bytesPerElement:z,bytesFromStringArray:G,isString:H,isBoolean:q,isNumber:K,inferDtype:j,isFunction:X,nearestDivisor:Y,computeStrides:$,toTypedArray:Q,toNestedArray:J,makeOnesTypedArray:Z,makeZerosTypedArray:tt,now:et,assertNonNegativeIntegerDimensions:nt,fetch:function(g,te){return th.platform.fetch(g,te)},encodeString:rt,decodeString:ot,locToIndex:at,indexToLoc:it});var tp=function(){function t(g,te){this.backendTimer=g,this.logger=te,null==te&&(this.logger=new tv)}return t.prototype.profileKernel=function(g,te,tr){var to,tu=this,tc=this.backendTimer.time(function(){to=tr()});return to.forEach(function(tr){tr.data().then(function(to){(function(g,te,tr){if("float32"===te)for(var to=0;to<g.length;to++){var tu=g[to];if(isNaN(tu)||!isFinite(tu))return console.warn("Found "+tu+" in the result of '"+tr+"'"),!0}})(to,tr.dtype,g),tc.then(function(tc){var tl="";null!=tc.getExtraProfileInfo&&(tl=tc.getExtraProfileInfo()),tu.logger.logKernelProfile(g,tr,to,tc.kernelMs,te,tl)})})}),to},t}(),tv=function(){function t(){}return t.prototype.logKernelProfile=function(g,te,tr,to,tu,tc){var tl="number"==typeof to?N(to+"ms",9):to.error,th=N(g,25),td=te.rank,tf=te.size,tp=N(te.shape.toString(),14),tv="";for(var tm in tu){var tg=tu[tm].shape||te.shape,ty=tg.length;tv+=tm+": "+ty+"D "+(ty>0?tg:"")+" "}console.log("%c"+th+"	%c"+tl+"	%c"+td+"D "+tp+"	%c"+tf+"	%c"+tv+"	%c"+tc,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")},t}();function dt(g,te,tr,to){var tu=$(te),tc=function(g,te,tr,to){var tu=k(te),tc=to[to.length-1],tl=Array(tc).fill(0),th=te.length,td="complex64"===tr?mt(g):g;if(th>1)for(var tf=0;tf<tu/tc;tf++)for(var tp=tf*tc,tv=0;tv<tc;tv++)tl[tv]=Math.max(tl[tv],pt(td[tp+tv],0,tr).length);return tl}(g,te,tr,tu),tl=te.length,th=function t(g,te,tr,to,tu,tc){void 0===tc&&(tc=!0);var tl,th="complex64"===tr?2:1,td=te[0],tf=te.length;if(0===tf)return"complex64"===tr?[pt(mt(g)[0],0,tr)]:"bool"===tr?[vt(g[0])]:[g[0].toString()];if(1===tf){if(td>20){var tp=3*th,tv=Array.from(g.slice(0,tp)),tm=Array.from(g.slice((td-3)*th,td*th));return"complex64"===tr&&(tv=mt(tv),tm=mt(tm)),["["+tv.map(function(g,te){return pt(g,tu[te],tr)}).join(", ")+", ..., "+tm.map(function(g,te){return pt(g,tu[td-3+te],tr)}).join(", ")+"]"]}return["["+("complex64"===tr?mt(g):Array.from(g)).map(function(g,te){return pt(g,tu[te],tr)}).join(", ")+"]"]}var tg=te.slice(1),ty=to.slice(1),tx=to[0]*th,tb=[];if(td>20){for(var tC=0;tC<3;tC++){var tw=(tl=tC*tx)+tx;tb.push.apply(tb,t(g.slice(tl,tw),tg,tr,ty,tu,!1))}for(tb.push("..."),tC=td-3;tC<td;tC++)tw=(tl=tC*tx)+tx,tb.push.apply(tb,t(g.slice(tl,tw),tg,tr,ty,tu,tC===td-1))}else for(tC=0;tC<td;tC++)tw=(tl=tC*tx)+tx,tb.push.apply(tb,t(g.slice(tl,tw),tg,tr,ty,tu,tC===td-1));var tE=2===tf?",":"";for(tC=1,tb[0]="["+tb[0]+tE;tC<tb.length-1;tC++)tb[tC]=" "+tb[tC]+tE;var tR=",\n";for(tC=2;tC<tf;tC++)tR+="\n";return tb[tb.length-1]=" "+tb[tb.length-1]+"]"+(tc?"":tR),tb}(g,te,tr,tu,tc),td=["Tensor"];return to&&(td.push("  dtype: "+tr),td.push("  rank: "+tl),td.push("  shape: ["+te+"]"),td.push("  values:")),td.push(th.map(function(g){return"    "+g}).join("\n")),td.join("\n")}function pt(g,te,tr){return N(Array.isArray(g)?parseFloat(g[0].toFixed(7))+" + "+parseFloat(g[1].toFixed(7))+"j":H(g)?"'"+g+"'":"bool"===tr?vt(g):parseFloat(g.toFixed(7)).toString(),te)}function vt(g){return 0===g?"false":"true"}function mt(g){for(var te=[],tr=0;tr<g.length;tr+=2)te.push([g[tr],g[tr+1]]);return te}var tm=function(){function t(g,te,tr){var to=this;if(this.dtype=te,this.shape=g.slice(),this.size=k(g),null!=tr){var tu=tr.length;C(tu===this.size,function(){return"Length of values '"+tu+"' does not match the size inferred by the shape '"+to.size+"'."})}if("complex64"===te)throw Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=tr||P(te,this.size),this.strides=$(g)}return t.prototype.set=function(g){for(var te=this,tr=[],to=1;to<arguments.length;to++)tr[to-1]=arguments[to];0===tr.length&&(tr=[0]),C(tr.length===this.rank,function(){return"The number of provided coordinates ("+tr.length+") must match the rank ("+te.rank+")"});var tu=this.locToIndex(tr);this.values[tu]=g},t.prototype.get=function(){for(var g=[],te=0;te<arguments.length;te++)g[te]=arguments[te];0===g.length&&(g=[0]);for(var tr=0,to=0,tu=g;to<tu.length;to++){var tc=tu[to];if(tc<0||tc>=this.shape[tr])throw Error("Requested out of range element at "+g+".   Buffer shape="+this.shape);tr++}for(var tl=g[g.length-1],th=0;th<g.length-1;++th)tl+=this.strides[th]*g[th];return this.values[tl]},t.prototype.locToIndex=function(g){if(0===this.rank)return 0;if(1===this.rank)return g[0];for(var te=g[g.length-1],tr=0;tr<g.length-1;++tr)te+=this.strides[tr]*g[tr];return te},t.prototype.indexToLoc=function(g){if(0===this.rank)return[];if(1===this.rank)return[g];for(var te=Array(this.shape.length),tr=0;tr<te.length-1;++tr)te[tr]=Math.floor(g/this.strides[tr]),g-=te[tr]*this.strides[tr];return te[te.length-1]=g,te},Object.defineProperty(t.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),t.prototype.toTensor=function(){return tg().makeTensor(this.values,this.shape,this.dtype)},t}(),tg=null,ty=null,tx=null,tb=function(){function t(g,te,tr,to){this.kept=!1,this.isDisposedInternal=!1,this.shape=g.slice(),this.dtype=te||"float32",this.size=k(g),this.strides=$(g),this.dataId=tr,this.id=to,this.rankType=this.rank<5?this.rank.toString():"higher"}return t.prototype.flatten=function(){return this.throwIfDisposed(),this.as1D()},t.prototype.asScalar=function(){return this.throwIfDisposed(),C(1===this.size,function(){return"The array must have only 1 element."}),this.reshape([])},t.prototype.as1D=function(){return this.throwIfDisposed(),this.reshape([this.size])},t.prototype.as2D=function(g,te){return this.throwIfDisposed(),this.reshape([g,te])},t.prototype.as3D=function(g,te,tr){return this.throwIfDisposed(),this.reshape([g,te,tr])},t.prototype.as4D=function(g,te,tr,to){return this.throwIfDisposed(),this.reshape([g,te,tr,to])},t.prototype.as5D=function(g,te,tr,to,tu){return this.throwIfDisposed(),this.reshape([g,te,tr,to,tu])},t.prototype.asType=function(g){return this.throwIfDisposed(),ty.cast(this,g)},Object.defineProperty(t.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),t.prototype.buffer=function(){return n(this,void 0,void 0,function(){var g;return r(this,function(te){switch(te.label){case 0:return[4,this.data()];case 1:return g=te.sent(),[2,ty.buffer(this.shape,this.dtype,g)]}})})},t.prototype.bufferSync=function(){return ty.buffer(this.shape,this.dtype,this.dataSync())},t.prototype.array=function(){return n(this,void 0,void 0,function(){var g;return r(this,function(te){switch(te.label){case 0:return[4,this.data()];case 1:return g=te.sent(),[2,J(this.shape,g)]}})})},t.prototype.arraySync=function(){return J(this.shape,this.dataSync())},t.prototype.data=function(){return n(this,void 0,void 0,function(){var g,te;return r(this,function(tr){switch(tr.label){case 0:return this.throwIfDisposed(),g=tg().read(this.dataId),"string"!==this.dtype?[3,2]:[4,g];case 1:te=tr.sent();try{return[2,te.map(function(g){return ot(g)})]}catch(g){throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}tr.label=2;case 2:return[2,g]}})})},t.prototype.dataSync=function(){this.throwIfDisposed();var g=tg().readSync(this.dataId);if("string"===this.dtype)try{return g.map(function(g){return ot(g)})}catch(g){throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return g},t.prototype.bytes=function(){return n(this,void 0,void 0,function(){var g;return r(this,function(te){switch(te.label){case 0:return this.throwIfDisposed(),[4,tg().read(this.dataId)];case 1:return g=te.sent(),"string"===this.dtype?[2,g]:[2,new Uint8Array(g.buffer)]}})})},t.prototype.dispose=function(){this.isDisposed||(tg().disposeTensor(this),this.isDisposedInternal=!0)},Object.defineProperty(t.prototype,"isDisposed",{get:function(){return this.isDisposedInternal},enumerable:!0,configurable:!0}),t.prototype.throwIfDisposed=function(){if(this.isDisposed)throw Error("Tensor is disposed.")},t.prototype.toFloat=function(){return this.asType("float32")},t.prototype.toInt=function(){return this.asType("int32")},t.prototype.toBool=function(){return this.asType("bool")},t.prototype.print=function(g){return void 0===g&&(g=!1),ty.print(this,g)},t.prototype.reshape=function(g){return this.throwIfDisposed(),ty.reshape(this,g)},t.prototype.reshapeAs=function(g){return this.throwIfDisposed(),this.reshape(g.shape)},t.prototype.expandDims=function(g){return void 0===g&&(g=0),ty.expandDims(this,g)},t.prototype.cumsum=function(g,te,tr){return void 0===g&&(g=0),void 0===te&&(te=!1),void 0===tr&&(tr=!1),ty.cumsum(this,g,te,tr)},t.prototype.squeeze=function(g){return this.throwIfDisposed(),ty.squeeze(this,g)},t.prototype.clone=function(){return this.throwIfDisposed(),ty.clone(this)},t.prototype.oneHot=function(g,te,tr){return this.throwIfDisposed(),ty.oneHot(this,g,te,tr)},t.prototype.toString=function(g){return void 0===g&&(g=!1),dt(this.dataSync(),this.shape,this.dtype,g)},t.prototype.tile=function(g){return this.throwIfDisposed(),ty.tile(this,g)},t.prototype.gather=function(g,te){return void 0===te&&(te=0),this.throwIfDisposed(),ty.gather(this,g,te)},t.prototype.matMul=function(g,te,tr){return void 0===te&&(te=!1),void 0===tr&&(tr=!1),this.throwIfDisposed(),ty.matMul(this,g,te,tr)},t.prototype.dot=function(g){return this.throwIfDisposed(),ty.dot(this,g)},t.prototype.norm=function(g,te,tr){return void 0===g&&(g="euclidean"),void 0===te&&(te=null),void 0===tr&&(tr=!1),this.throwIfDisposed(),ty.norm(this,g,te,tr)},t.prototype.slice=function(g,te){return this.throwIfDisposed(),ty.slice(this,g,te)},t.prototype.reverse=function(g){return this.throwIfDisposed(),ty.reverse(this,g)},t.prototype.concat=function(g,te){return void 0===te&&(te=0),this.throwIfDisposed(),g instanceof t&&(g=[g]),ty.concat([this].concat(g),te)},t.prototype.split=function(g,te){return void 0===te&&(te=0),this.throwIfDisposed(),ty.split(this,g,te)},t.prototype.stack=function(g,te){return void 0===te&&(te=0),ty.stack([this,g],te)},t.prototype.unstack=function(g){return void 0===g&&(g=0),ty.unstack(this,g)},t.prototype.pad=function(g,te){return void 0===te&&(te=0),ty.pad(this,g,te)},t.prototype.batchNormalization=function(g,te,tr,to,tu){return void 0===tr&&(tr=.001),tx("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"),this.batchNorm(g,te,tu,to,tr)},t.prototype.batchNorm=function(g,te,tr,to,tu){return void 0===tu&&(tu=.001),this.throwIfDisposed(),ty.batchNorm(this,g,te,tr,to,tu)},t.prototype.all=function(g,te){return void 0===g&&(g=null),void 0===te&&(te=!1),this.throwIfDisposed(),ty.all(this,g,te)},t.prototype.any=function(g,te){return void 0===g&&(g=null),void 0===te&&(te=!1),this.throwIfDisposed(),ty.any(this,g,te)},t.prototype.logSumExp=function(g,te){return void 0===g&&(g=null),void 0===te&&(te=!1),this.throwIfDisposed(),ty.logSumExp(this,g,te)},t.prototype.sum=function(g,te){return void 0===g&&(g=null),void 0===te&&(te=!1),this.throwIfDisposed(),ty.sum(this,g,te)},t.prototype.prod=function(g,te){return void 0===g&&(g=null),void 0===te&&(te=!1),this.throwIfDisposed(),ty.prod(this,g,te)},t.prototype.mean=function(g,te){return void 0===g&&(g=null),void 0===te&&(te=!1),this.throwIfDisposed(),ty.mean(this,g,te)},t.prototype.min=function(g,te){return void 0===g&&(g=null),void 0===te&&(te=!1),this.throwIfDisposed(),ty.min(this,g,te)},t.prototype.max=function(g,te){return void 0===g&&(g=null),void 0===te&&(te=!1),this.throwIfDisposed(),ty.max(this,g,te)},t.prototype.argMin=function(g){return void 0===g&&(g=null),this.throwIfDisposed(),ty.argMin(this,g)},t.prototype.argMax=function(g){return void 0===g&&(g=null),this.throwIfDisposed(),ty.argMax(this,g)},t.prototype.cast=function(g){return this.throwIfDisposed(),ty.cast(this,g)},t.prototype.add=function(g){return this.throwIfDisposed(),ty.add(this,g)},t.prototype.addStrict=function(g){return this.throwIfDisposed(),ty.addStrict(this,g)},t.prototype.atan2=function(g){return this.throwIfDisposed(),ty.atan2(this,g)},t.prototype.sub=function(g){return this.throwIfDisposed(),ty.sub(this,g)},t.prototype.subStrict=function(g){return this.throwIfDisposed(),ty.subStrict(this,g)},t.prototype.pow=function(g){return this.throwIfDisposed(),ty.pow(this,g)},t.prototype.powStrict=function(g){return this.throwIfDisposed(),ty.powStrict(this,g)},t.prototype.mul=function(g){return this.throwIfDisposed(),ty.mul(this,g)},t.prototype.mulStrict=function(g){return this.throwIfDisposed(),ty.mulStrict(this,g)},t.prototype.div=function(g){return this.throwIfDisposed(),ty.div(this,g)},t.prototype.divNoNan=function(g){return this.throwIfDisposed(),ty.divNoNan(this,g)},t.prototype.floorDiv=function(g){return this.throwIfDisposed(),ty.floorDiv(this,g)},t.prototype.divStrict=function(g){return this.throwIfDisposed(),ty.divStrict(this,g)},t.prototype.minimum=function(g){return this.throwIfDisposed(),ty.minimum(this,g)},t.prototype.minimumStrict=function(g){return this.throwIfDisposed(),ty.minimumStrict(this,g)},t.prototype.maximum=function(g){return this.throwIfDisposed(),ty.maximum(this,g)},t.prototype.maximumStrict=function(g){return this.throwIfDisposed(),ty.maximumStrict(this,g)},t.prototype.mod=function(g){return this.throwIfDisposed(),ty.mod(this,g)},t.prototype.modStrict=function(g){return this.throwIfDisposed(),ty.modStrict(this,g)},t.prototype.squaredDifferenceStrict=function(g){return this.throwIfDisposed(),ty.squaredDifferenceStrict(this,g)},t.prototype.transpose=function(g){return this.throwIfDisposed(),ty.transpose(this,g)},t.prototype.notEqual=function(g){return this.throwIfDisposed(),ty.notEqual(this,g)},t.prototype.notEqualStrict=function(g){return this.throwIfDisposed(),ty.notEqualStrict(this,g)},t.prototype.less=function(g){return this.throwIfDisposed(),ty.less(this,g)},t.prototype.lessStrict=function(g){return this.throwIfDisposed(),ty.lessStrict(this,g)},t.prototype.equal=function(g){return this.throwIfDisposed(),ty.equal(this,g)},t.prototype.equalStrict=function(g){return this.throwIfDisposed(),ty.equalStrict(this,g)},t.prototype.lessEqual=function(g){return this.throwIfDisposed(),ty.lessEqual(this,g)},t.prototype.lessEqualStrict=function(g){return this.throwIfDisposed(),ty.lessEqualStrict(this,g)},t.prototype.greater=function(g){return this.throwIfDisposed(),ty.greater(this,g)},t.prototype.greaterStrict=function(g){return this.throwIfDisposed(),ty.greaterStrict(this,g)},t.prototype.greaterEqual=function(g){return this.throwIfDisposed(),ty.greaterEqual(this,g)},t.prototype.greaterEqualStrict=function(g){return this.throwIfDisposed(),ty.greaterEqualStrict(this,g)},t.prototype.logicalAnd=function(g){return this.throwIfDisposed(),ty.logicalAnd(this,g)},t.prototype.logicalOr=function(g){return this.throwIfDisposed(),ty.logicalOr(this,g)},t.prototype.logicalNot=function(){return this.throwIfDisposed(),ty.logicalNot(this)},t.prototype.logicalXor=function(g){return this.throwIfDisposed(),ty.logicalXor(this,g)},t.prototype.where=function(g,te){return this.throwIfDisposed(),ty.where(g,this,te)},t.prototype.neg=function(){return this.throwIfDisposed(),ty.neg(this)},t.prototype.ceil=function(){return this.throwIfDisposed(),ty.ceil(this)},t.prototype.floor=function(){return this.throwIfDisposed(),ty.floor(this)},t.prototype.sign=function(){return this.throwIfDisposed(),ty.sign(this)},t.prototype.isNaN=function(){return this.throwIfDisposed(),ty.isNaN(this)},t.prototype.isInf=function(){return this.throwIfDisposed(),ty.isInf(this)},t.prototype.isFinite=function(){return this.throwIfDisposed(),ty.isFinite(this)},t.prototype.exp=function(){return this.throwIfDisposed(),ty.exp(this)},t.prototype.expm1=function(){return this.throwIfDisposed(),ty.expm1(this)},t.prototype.log=function(){return this.throwIfDisposed(),ty.log(this)},t.prototype.log1p=function(){return this.throwIfDisposed(),ty.log1p(this)},t.prototype.sqrt=function(){return this.throwIfDisposed(),ty.sqrt(this)},t.prototype.rsqrt=function(){return this.throwIfDisposed(),ty.rsqrt(this)},t.prototype.square=function(){return this.throwIfDisposed(),ty.square(this)},t.prototype.reciprocal=function(){return this.throwIfDisposed(),ty.reciprocal(this)},t.prototype.abs=function(){return this.throwIfDisposed(),ty.abs(this)},t.prototype.clipByValue=function(g,te){return this.throwIfDisposed(),ty.clipByValue(this,g,te)},t.prototype.relu=function(){return this.throwIfDisposed(),ty.relu(this)},t.prototype.relu6=function(){return this.throwIfDisposed(),ty.relu6(this)},t.prototype.elu=function(){return this.throwIfDisposed(),ty.elu(this)},t.prototype.selu=function(){return this.throwIfDisposed(),ty.selu(this)},t.prototype.leakyRelu=function(g){return void 0===g&&(g=.2),this.throwIfDisposed(),ty.leakyRelu(this,g)},t.prototype.prelu=function(g){return this.throwIfDisposed(),ty.prelu(this,g)},t.prototype.sigmoid=function(){return this.throwIfDisposed(),ty.sigmoid(this)},t.prototype.logSigmoid=function(){return this.throwIfDisposed(),ty.logSigmoid(this)},t.prototype.softplus=function(){return this.throwIfDisposed(),ty.softplus(this)},t.prototype.zerosLike=function(){return this.throwIfDisposed(),ty.zerosLike(this)},t.prototype.onesLike=function(){return this.throwIfDisposed(),ty.onesLike(this)},t.prototype.sin=function(){return this.throwIfDisposed(),ty.sin(this)},t.prototype.cos=function(){return this.throwIfDisposed(),ty.cos(this)},t.prototype.tan=function(){return this.throwIfDisposed(),ty.tan(this)},t.prototype.asin=function(){return this.throwIfDisposed(),ty.asin(this)},t.prototype.acos=function(){return this.throwIfDisposed(),ty.acos(this)},t.prototype.atan=function(){return this.throwIfDisposed(),ty.atan(this)},t.prototype.sinh=function(){return this.throwIfDisposed(),ty.sinh(this)},t.prototype.cosh=function(){return this.throwIfDisposed(),ty.cosh(this)},t.prototype.tanh=function(){return this.throwIfDisposed(),ty.tanh(this)},t.prototype.asinh=function(){return this.throwIfDisposed(),ty.asinh(this)},t.prototype.acosh=function(){return this.throwIfDisposed(),ty.acosh(this)},t.prototype.atanh=function(){return this.throwIfDisposed(),ty.atanh(this)},t.prototype.erf=function(){return this.throwIfDisposed(),ty.erf(this)},t.prototype.round=function(){return this.throwIfDisposed(),ty.round(this)},t.prototype.step=function(g){return void 0===g&&(g=0),this.throwIfDisposed(),ty.step(this,g)},t.prototype.softmax=function(g){return void 0===g&&(g=-1),this.throwIfDisposed(),ty.softmax(this,g)},t.prototype.logSoftmax=function(g){return void 0===g&&(g=-1),this.throwIfDisposed(),ty.logSoftmax(this,g)},t.prototype.resizeBilinear=function(g,te){return void 0===te&&(te=!1),this.throwIfDisposed(),ty.image.resizeBilinear(this,g,te)},t.prototype.resizeNearestNeighbor=function(g,te){return void 0===te&&(te=!1),this.throwIfDisposed(),ty.image.resizeNearestNeighbor(this,g,te)},t.prototype.conv1d=function(g,te,tr,to,tu,tc){return void 0===to&&(to="NWC"),void 0===tu&&(tu=1),this.throwIfDisposed(),ty.conv1d(this,g,te,tr,to,tu,tc)},t.prototype.conv2d=function(g,te,tr,to,tu,tc){return void 0===to&&(to="NHWC"),void 0===tu&&(tu=[1,1]),this.throwIfDisposed(),ty.conv2d(this,g,te,tr,to,tu,tc)},t.prototype.conv2dTranspose=function(g,te,tr,to,tu){return this.throwIfDisposed(),ty.conv2dTranspose(this,g,te,tr,to,tu)},t.prototype.depthwiseConv2D=function(g,te,tr,to,tu,tc){return void 0===to&&(to="NHWC"),void 0===tu&&(tu=[1,1]),this.throwIfDisposed(),ty.depthwiseConv2d(this,g,te,tr,to,tu,tc)},t.prototype.separableConv2d=function(g,te,tr,to,tu,tc){return void 0===tu&&(tu=[1,1]),void 0===tc&&(tc="NHWC"),this.throwIfDisposed(),ty.separableConv2d(this,g,te,tr,to,tu,tc)},t.prototype.avgPool=function(g,te,tr,to){return this.throwIfDisposed(),ty.avgPool(this,g,te,tr,to)},t.prototype.maxPool=function(g,te,tr,to){return this.throwIfDisposed(),ty.maxPool(this,g,te,tr,to)},t.prototype.localResponseNormalization=function(g,te,tr,to){return void 0===g&&(g=5),void 0===te&&(te=1),void 0===tr&&(tr=1),void 0===to&&(to=.5),ty.localResponseNormalization(this,g,te,tr,to)},t.prototype.pool=function(g,te,tr,to,tu){return this.throwIfDisposed(),ty.pool(this,g,te,tr,to,tu)},t.prototype.variable=function(g,te,tr){return void 0===g&&(g=!0),this.throwIfDisposed(),tg().makeVariable(this,g,te,tr)},t.prototype.unsortedSegmentSum=function(g,te){return this.throwIfDisposed(),ty.unsortedSegmentSum(this,g,te)},t.prototype.batchToSpaceND=function(g,te){return this.throwIfDisposed(),ty.batchToSpaceND(this,g,te)},t.prototype.spaceToBatchND=function(g,te){return this.throwIfDisposed(),ty.spaceToBatchND(this,g,te)},t.prototype.topk=function(g,te){return void 0===g&&(g=1),void 0===te&&(te=!0),this.throwIfDisposed(),ty.topk(this,g,te)},t.prototype.stridedSlice=function(g,te,tr,to,tu,tc,tl,th){return void 0===to&&(to=0),void 0===tu&&(tu=0),void 0===tc&&(tc=0),void 0===tl&&(tl=0),void 0===th&&(th=0),this.throwIfDisposed(),ty.stridedSlice(this,g,te,tr,to,tu,tc,tl,th)},t.prototype.depthToSpace=function(g,te){return this.throwIfDisposed(),ty.depthToSpace(this,g,te)},t.prototype.fft=function(){return this.throwIfDisposed(),ty.spectral.fft(this)},t.prototype.ifft=function(){return this.throwIfDisposed(),ty.spectral.ifft(this)},t.prototype.rfft=function(){return this.throwIfDisposed(),ty.spectral.rfft(this)},t.prototype.irfft=function(){return this.throwIfDisposed(),ty.spectral.irfft(this)},t}();Object.defineProperty(tb,Symbol.hasInstance,{value:function(g){return!!g&&null!=g.dataId&&null!=g.shape&&null!=g.dtype}});var tC,tw,tE,tR,tI,tk=function(g){function n(te,tr,to,tu){var tc=g.call(this,te.shape,te.dtype,te.dataId,tu)||this;return tc.trainable=tr,tc.name=to,tc}return e(n,g),n.prototype.assign=function(g){if(g.dtype!==this.dtype)throw Error("dtype of the new value ("+g.dtype+") and previous value ("+this.dtype+") must match");if(!S(g.shape,this.shape))throw Error("shape of the new value ("+g.shape+") and previous value ("+this.shape+") must match");tg().disposeTensor(this),this.dataId=g.dataId,tg().incRef(this,null)},n.prototype.dispose=function(){tg().disposeVariable(this),this.isDisposedInternal=!0},n}(tb);Object.defineProperty(tk,Symbol.hasInstance,{value:function(g){return g instanceof tb&&null!=g.assign&&g.assign instanceof Function}}),(tS=tC||(tC={})).R0="R0",tS.R1="R1",tS.R2="R2",tS.R3="R3",tS.R4="R4",tS.R5="R5",tS.R6="R6",(tD=tw||(tw={})).float32="float32",tD.int32="int32",tD.bool="int32",tD.complex64="complex64",(tN=tE||(tE={})).float32="float32",tN.int32="int32",tN.bool="bool",tN.complex64="complex64",(tT=tR||(tR={})).float32="float32",tT.int32="float32",tT.bool="float32",tT.complex64="complex64",(tF=tI||(tI={})).float32="complex64",tF.int32="complex64",tF.bool="complex64",tF.complex64="complex64";var tA={float32:tR,int32:tw,bool:tE,complex64:tI};function Dt(g,te){if("string"===g||"string"===te){if("string"===g&&"string"===te)return"string";throw Error("Can not upcast "+g+" with "+te)}return tA[g][te]}function Tt(g){return Dt(g,"int32")}function Nt(g,te){if(g.dtype===te.dtype)return[g,te];var tr=Dt(g.dtype,te.dtype);return[g.cast(tr),te.cast(tr)]}function Ft(g,te){C(g.dtype===te.dtype,function(){return"The dtypes of the first("+g.dtype+") and second("+te.dtype+") input must match"})}function _t(g){var te=[];return function t(g,te,tr){if(null!=g){if(g instanceof tb)return void te.push(g);if(Array.isArray(g)||"object"==typeof g)for(var to in g){var tu=g[to];tr.has(tu)||(tr.add(tu),t(tu,te,tr))}}}(g,te,new Set),te}Object.freeze({makeTypesMatch:Nt,assertTypesMatch:Ft,isTensorInList:function(g,te){return te.some(function(te){return te.id===g.id})},getTensorsInContainer:_t});var tS,tD,tN,tT,tF,tO,t_=function(){function t(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}return t.prototype.dispose=function(){for(var g in this.registeredVariables)this.registeredVariables[g].dispose()},t}(),tM=function(){function t(g){this.ENV=g,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new t_}return t.prototype.ready=function(){return n(this,void 0,void 0,function(){var g,te,tr;return r(this,function(to){switch(to.label){case 0:if(null!=this.pendingBackendInit)return[2,this.pendingBackendInit.then(function(){})];if(null!=this.backendInstance)return[2];g=this.getSortedBackends(),te=0,to.label=1;case 1:return te<g.length?(tr=g[te],[4,this.initializeBackend(tr).success]):[3,5];case 2:return to.sent()?[4,this.setBackend(tr)]:[3,4];case 3:return to.sent(),[2];case 4:return te++,[3,1];case 5:throw Error("Could not initialize any backends, all backend initializations failed.")}})})},Object.defineProperty(t.prototype,"backend",{get:function(){if(null!=this.pendingBackendInit)throw Error("Backend '"+this.backendName+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){var g=this.initializeBackendsAndReturnBest(),te=g.name;if(g.asyncInit)throw Error("The highest priority backend '"+te+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(te)}return this.backendInstance},enumerable:!0,configurable:!0}),t.prototype.backendNames=function(){return Object.keys(this.registryFactory)},t.prototype.findBackend=function(g){return g in this.registry||g in this.registryFactory&&!this.initializeBackend(g).asyncInit?this.registry[g]:null},t.prototype.findBackendFactory=function(g){return g in this.registryFactory?this.registryFactory[g].factory:null},t.prototype.registerBackend=function(g,te,tr){return void 0===tr&&(tr=1),g in this.registryFactory?(console.warn(g+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[g]={factory:te,priority:tr},!0)},t.prototype.setBackend=function(g){return n(this,void 0,void 0,function(){var te,tr,to;return r(this,function(tu){switch(tu.label){case 0:if(null==this.registryFactory[g])throw Error("Backend name '"+g+"' not found in registry");return this.backendName=g,null!=this.registry[g]?[3,4]:(this.backendInstance=null,tr=(te=this.initializeBackend(g)).success,te.asyncInit?[4,tr]:[3,2]);case 1:return to=tu.sent(),[3,3];case 2:to=tr,tu.label=3;case 3:if(!to)return[2,!1];tu.label=4;case 4:return this.backendInstance=this.registry[g],this.setupRegisteredKernels(),this.profiler=new tp(this.backendInstance),[2,!0]}})})},t.prototype.setupRegisteredKernels=function(){var g=this;f(this.backendName).forEach(function(te){null!=te.setupFunc&&te.setupFunc(g.backendInstance)})},t.prototype.disposeRegisteredKernels=function(g){var te=this;f(g).forEach(function(tr){null!=tr.disposeFunc&&tr.disposeFunc(te.registry[g])})},t.prototype.initializeBackend=function(g){var te=this,tr=this.registryFactory[g];if(null==tr)throw Error("Cannot initialize backend "+g+", no registration found.");try{var to=tr.factory();if(Promise.resolve(to)===to){var tu=++this.pendingBackendInitId,tc=to.then(function(tr){return!(tu<te.pendingBackendInitId)&&(te.registry[g]=tr,te.pendingBackendInit=null,!0)}).catch(function(tr){return!(tu<te.pendingBackendInitId)&&(te.pendingBackendInit=null,console.warn("Initialization of backend "+g+" failed"),console.warn(tr.stack||tr.message),!1)});return this.pendingBackendInit=tc,{success:tc,asyncInit:!0}}return this.registry[g]=to,{success:!0,asyncInit:!1}}catch(te){return console.warn("Initialization of backend "+g+" failed"),console.warn(te.stack||te.message),{success:!1,asyncInit:!1}}},t.prototype.removeBackend=function(g){if(!(g in this.registryFactory))throw Error(g+" backend not found in registry");this.backendName===g&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,g in this.registry&&(this.disposeRegisteredKernels(g),this.registry[g].dispose(),delete this.registry[g]),delete this.registryFactory[g],this.backendName===g&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)},t.prototype.getSortedBackends=function(){var g=this;if(0===Object.keys(this.registryFactory).length)throw Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(function(te,tr){return g.registryFactory[tr].priority-g.registryFactory[te].priority})},t.prototype.initializeBackendsAndReturnBest=function(){for(var g=this.getSortedBackends(),te=0;te<g.length;te++){var tr=g[te],to=this.initializeBackend(tr),tu=to.success,tc=to.asyncInit;if(tc||tu)return{name:tr,asyncInit:tc}}throw Error("Could not initialize any backends, all backend initializations failed.")},t.prototype.moveData=function(g,te){var tr=this.state.tensorInfo.get(te),to=tr.backend,tu=this.readSync(te);to.disposeData(te),tr.backend=g,g.move(te,tu,tr.shape,tr.dtype),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++},t.prototype.tidy=function(g,te){var tr,to=this,tu=null;if(null==te){if("function"!=typeof g)throw Error("Please provide a function to tidy()");te=g}else{if("string"!=typeof g&&!(g instanceof String))throw Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof te)throw Error("When calling with two arguments, the 2nd argument to tidy() must be a function");tu=g}return this.scopedRun(function(){return to.startScope(tu)},function(){return to.endScope(tr)},function(){return(tr=te())instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),tr})},t.prototype.scopedRun=function(g,te,tr){g();try{var to=tr();return te(),to}catch(g){throw te(),g}},t.prototype.nextTensorId=function(){return t.nextTensorId++},t.prototype.nextVariableId=function(){return t.nextVariableId++},t.prototype.clone=function(g){var te=this.makeTensorFromDataId(g.dataId,g.shape,g.dtype);return this.addTapeNode(this.state.activeScope.name,{x:g},[te],function(g){return{x:function(){return g.toFloat()}}},[]),te},t.prototype.runKernel=function(g,te,tr,to,tu){return this.runKernelFunc(null,te,null,g,tr,to,tu)},t.prototype.shouldCheckForMemLeaks=function(){return this.ENV.getBool("IS_TEST")},t.prototype.checkKernelForMemLeak=function(g,te,tr){var to=this.backend.numDataIds(),tu=0;tr.forEach(function(g){tu+="complex64"===g.dtype?3:1});var tc=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],tl=to-te-tu-tc;if(tl>0)throw Error("Backend '"+this.backendName+"' has an internal memory leak ("+tl+" data ids) after running '"+g+"'")},t.prototype.runKernelFunc=function(g,te,tr,to,tu,tc,tl){var th,td=this;void 0===tc&&(tc=[]),void 0===tl&&(tl=[]);var tf=[],tp=this.isTapeOn();null==to&&(to=null!=this.state.activeScope?this.state.activeScope.name:"");var tv,d=function(g){tp&&(tf=g.map(function(g){return td.keep(td.clone(g))}))},tm=this.state.numBytes,tg=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);var ty,tx=l(to,this.backendName);return tv=null!=tx?function(){var g=td.backend.numDataIds(),tr=Array.isArray(ty=tx.kernelFunc({inputs:te,attrs:tu,backend:td.backend}))?ty:[ty];td.shouldCheckForMemLeaks()&&td.checkKernelForMemLeak(to,g,tr);var th=tr.map(function(g){var te=g.dataId,tr=g.shape,to=g.dtype;return td.makeTensorFromDataId(te,tr,to)}),tf=th.filter(function(g,te){return tl[te]});return d((tc||[]).slice().concat(tf)),th}:function(){var te=td.backend.numDataIds(),tr=Array.isArray(ty=td.tidy(function(){return g(td.backend,d)}))?ty:[ty];return td.shouldCheckForMemLeaks()&&td.checkKernelForMemLeak(to,te,tr),tr},this.scopedRun(function(){return td.state.kernelDepth++},function(){return td.state.kernelDepth--},function(){th=td.ENV.getBool("DEBUG")?td.profiler.profileKernel(to,te,function(){return tv()}):tv()}),tp&&this.addTapeNode(to,te,th,tr,tf),this.state.profiling&&this.state.activeProfile.kernels.push({name:to,bytesAdded:this.state.numBytes-tm,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-tg,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(te).map(function(g){return te[g].shape}),outputShapes:th.map(function(g){return g.shape})}),Array.isArray(ty)?th:th[0]},t.prototype.makeTensor=function(g,te,tr,to){if(null==g)throw Error("Values passed to engine.makeTensor() are null");tr=tr||"float32",to=to||this.backend;var tu=g;"string"===tr&&H(g[0])&&(tu=g.map(function(g){return rt(g)}));var tc=to.write(tu,te,tr),tl=new tb(te,tr,tc,this.nextTensorId());if(this.incRef(tl,to),"string"===tr){var th=this.state.tensorInfo.get(tc),td=G(tu);this.state.numBytes+=td-th.bytes,th.bytes=td}return tl},t.prototype.makeTensorFromDataId=function(g,te,tr,to){var tu=new tb(te,tr=tr||"float32",g,this.nextTensorId());return this.incRef(tu,to),tu},t.prototype.makeVariable=function(g,te,tr,to){void 0===te&&(te=!0),tr=tr||this.nextVariableId().toString(),null!=to&&to!==g.dtype&&(g=g.asType(to));var tu=new tk(g,te,tr,this.nextTensorId());if(null!=this.state.registeredVariables[tu.name])throw Error("Variable with name "+tu.name+" was already registered");return this.state.registeredVariables[tu.name]=tu,this.incRef(tu,this.backend),tu},t.prototype.incRef=function(g,te){var tr=this.state.tensorInfo.has(g.dataId)?this.state.tensorInfo.get(g.dataId).refCount:0;if(this.state.numTensors++,"string"===g.dtype&&this.state.numStringTensors++,0===tr){this.state.numDataBuffers++;var to=0;"complex64"!==g.dtype&&"string"!==g.dtype&&(to=g.size*z(g.dtype)),this.state.tensorInfo.set(g.dataId,{backend:te||this.backend,dtype:g.dtype,shape:g.shape,bytes:to,refCount:0}),this.state.numBytes+=to}this.state.tensorInfo.get(g.dataId).refCount++,g instanceof tk||this.track(g)},t.prototype.disposeTensor=function(g){if(this.state.tensorInfo.has(g.dataId)){this.state.numTensors--,"string"===g.dtype&&this.state.numStringTensors--;var te=this.state.tensorInfo.get(g.dataId);te.refCount<=1?("complex64"!==g.dtype&&(this.state.numBytes-=te.bytes),this.state.numDataBuffers--,te.backend.disposeData(g.dataId),this.state.tensorInfo.delete(g.dataId)):this.state.tensorInfo.get(g.dataId).refCount--}},t.prototype.disposeVariables=function(){for(var g in this.state.registeredVariables){var te=this.state.registeredVariables[g];this.disposeVariable(te)}},t.prototype.disposeVariable=function(g){this.disposeTensor(g),null!=this.state.registeredVariables[g.name]&&delete this.state.registeredVariables[g.name]},t.prototype.memory=function(){var g=this.backend.memory();return g.numTensors=this.state.numTensors,g.numDataBuffers=this.state.numDataBuffers,g.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(g.unreliable=!0,null==g.reasons&&(g.reasons=[]),g.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),g},t.prototype.profile=function(g){return n(this,void 0,void 0,function(){var te,tr;return r(this,function(to){return this.state.profiling=!0,te=this.state.numBytes,tr=this.state.numTensors,this.state.activeProfile.kernels=[],this.state.activeProfile.result=g(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max.apply(Math,this.state.activeProfile.kernels.map(function(g){return g.totalBytesSnapshot})),this.state.activeProfile.newBytes=this.state.numBytes-te,this.state.activeProfile.newTensors=this.state.numTensors-tr,[2,this.state.activeProfile]})})},t.prototype.isTapeOn=function(){return this.state.gradientDepth>0&&0===this.state.kernelDepth},t.prototype.addTapeNode=function(g,te,tr,to,tu){var tc=this,tl={id:this.state.nextTapeNodeId++,kernelName:g,inputs:te,outputs:tr,saved:tu},th=h(g);null!=th&&(to=th.gradFunc),null!=to&&(tl.gradient=function(g){return g=g.map(function(g,te){if(null==g){var to=tr[te],tu=tt(to.size,to.dtype);return tc.makeTensor(tu,to.shape,to.dtype)}return g}),to(g.length>1?g:g[0],tu)}),this.state.activeTape.push(tl)},t.prototype.keep=function(g){return g.kept=!0,g},t.prototype.startTape=function(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++},t.prototype.endTape=function(){this.state.gradientDepth--},t.prototype.startScope=function(g){var te={track:[],name:"unnamed scope",id:this.state.nextScopeId++};g&&(te.name=g),this.state.scopeStack.push(te),this.state.activeScope=te},t.prototype.endScope=function(g){for(var te=this,tr=_t(g),to=new Set(tr.map(function(g){return g.id})),tu=0;tu<this.state.activeScope.track.length;tu++){var tc=this.state.activeScope.track[tu];tc.kept||to.has(tc.id)||tc.dispose()}var tl=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],tr.forEach(function(g){g.kept||g.scopeId!==tl.id||te.track(g)})},t.prototype.gradients=function(g,te,tr,to){var tu=this;if(void 0===to&&(to=!1),C(te.length>0,function(){return"gradients() received an empty list of xs."}),null!=tr&&"float32"!==tr.dtype)throw Error("dy must have 'float32' dtype, but has '"+tr.dtype+"'");var tc=this.scopedRun(function(){return tu.startTape()},function(){return tu.endTape()},function(){return tu.tidy("forward",g)});C(tc instanceof tb,function(){return"The result y returned by f() must be a tensor."});var tl=function(g,te,tr){for(var to,tu={},tc={},tl=0;tl<te.length;tl++)tu[te[tl].id]=!0;for(tl=0;tl<g.length;tl++){var th=(to=g[tl]).inputs;for(var td in th){for(var tf=th[td],tp=!1,tv=0;tv<te.length;tv++)if(tu[tf.id]){to.outputs.forEach(function(g){return tu[g.id]=!0}),tp=!0,tc[to.id]=!0;break}if(tp)break}}var tm={};tm[tr.id]=!0;var tg={};for(tl=g.length-1;tl>=0;tl--)for(th=(to=g[tl]).inputs,tv=0;tv<to.outputs.length;tv++)if(tm[to.outputs[tv].id]){for(var td in th)tm[th[td].id]=!0,tg[to.id]=!0;break}var ty=[];for(tl=0;tl<g.length;tl++)if(tc[(to=g[tl]).id]&&tg[to.id]){var tx={};for(var td in to.inputs){var tb=to.inputs[td];tu[tb.id]&&(tx[td]=tb)}var tC=Object.assign({},to);tC.inputs=tx,tC.outputs=to.outputs,ty.push(tC)}return ty}(this.state.activeTape,te,tc);if(!to&&0===tl.length&&te.length>0)throw Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",function(){var g,to,th={};th[tc.id]=null==tr?(to=Z(k(g=tc.shape),"float32"),tB.makeTensor(to,g,"float32")):tr,function(g,te,tr){for(var to=te.length-1;to>=0;to--)(function(to){var tu=te[to],tc=[];if(tu.outputs.forEach(function(te){var tr=g[te.id];null!=tr?tc.push(tr):tc.push(null)}),null==tu.gradient)throw Error("Cannot compute gradient: gradient function not found for "+tu.kernelName+".");var tl=tu.gradient(tc),s=function(te){if(!(te in tl))throw Error("Cannot backprop through input "+te+". Available gradients found: "+Object.keys(tl)+".");var to=tr(function(){return tl[te]()});if("float32"!==to.dtype)throw Error("Error in gradient for op "+tu.kernelName+". The gradient of input "+te+" must have 'float32' dtype, but has '"+to.dtype+"'");var tc=tu.inputs[te];if(!S(to.shape,tc.shape))throw Error("Error in gradient for op "+tu.kernelName+". The gradient of input '"+te+"' has shape '"+to.shape+"', which does not match the shape of the input '"+tc.shape+"'");if(null==g[tc.id])g[tc.id]=to;else{var th=g[tc.id];g[tc.id]=th.add(to),th.dispose()}};for(var th in tu.inputs)s(th)})(to)}(th,tl,function(g){return tu.tidy(g)});var td=te.map(function(g){return th[g.id]});return 0===tu.state.gradientDepth&&(tu.state.activeTape.forEach(function(g){for(var te=0,tr=g.saved;te<tr.length;te++)tr[te].dispose()}),tu.state.activeTape=null),{value:tc,grads:td}})},t.prototype.customGrad=function(g){var te=this;return C(X(g),function(){return"The f passed in customGrad(f) must be a function."}),function(){for(var tr,to=[],tu=0;tu<arguments.length;tu++)to[tu]=arguments[tu];C(to.every(function(g){return g instanceof tb}),function(){return"The args passed in customGrad(f)(x1, x2,...) must all be tensors"});var tc={};return to.forEach(function(g,te){tc[te]=g}),te.runKernelFunc(function(te,tu){return C((tr=g.apply(void 0,to.concat([tu]))).value instanceof tb,function(){return"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"}),C(X(tr.gradFunc),function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."}),tr.value},tc,function(g,te){var tu=tr.gradFunc(g,te),tc=Array.isArray(tu)?tu:[tu];C(tc.length===to.length,function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."}),C(tc.every(function(g){return g instanceof tb}),function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."});var tl={};return tc.forEach(function(g,te){tl[te]=function(){return g}}),tl})}},t.prototype.readSync=function(g){return this.state.tensorInfo.get(g).backend.readSync(g)},t.prototype.read=function(g){return this.state.tensorInfo.get(g).backend.read(g)},t.prototype.time=function(g){return n(this,void 0,void 0,function(){var te,tr;return r(this,function(to){switch(to.label){case 0:return te=et(),[4,this.backend.time(g)];case 1:return(tr=to.sent()).wallMs=et()-te,[2,tr]}})})},t.prototype.track=function(g){return null!=this.state.activeScope&&(g.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(g)),g},Object.defineProperty(t.prototype,"registeredVariables",{get:function(){return this.state.registeredVariables},enumerable:!0,configurable:!0}),t.prototype.reset=function(){for(var g in this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new t_,this.registry)this.disposeRegisteredKernels(g),this.registry[g].dispose(),delete this.registry[g];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null},t.nextTensorId=0,t.nextVariableId=0,t}(),tB=function(){var g=function(){if(null==tO){var g=void 0;if("undefined"!=typeof window)g=window;else if(void 0!==tr.g)g=tr.g;else if(void 0!==tu)g=tu;else{if("undefined"==typeof self)throw Error("Could not find a global object");tu=self}tO=g}return tO}();if(null==g._tfengine){var te=new tl(g);g._tfengine=new tM(te)}return th=g._tfengine.ENV,tg=function(){return g._tfengine},g._tfengine}();function Wt(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}var tP=th;tP.registerFlag("DEBUG",function(){return!1},function(g){g&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),tP.registerFlag("IS_BROWSER",function(){return Wt()}),tP.registerFlag("IS_NODE",function(){return void 0!==tu&&void 0!==tu.versions&&void 0!==tu.versions.node}),tP.registerFlag("IS_CHROME",function(){return"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)}),tP.registerFlag("PROD",function(){return!1}),tP.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",function(){return tP.getBool("DEBUG")}),tP.registerFlag("DEPRECATION_WARNINGS_ENABLED",function(){return!0}),tP.registerFlag("IS_TEST",function(){return!1});var tL,tW,tV,tU={},tz={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Kt(g,te){tU[g]=te}function jt(g){g in tU||(tU[g]=function(g){if(1!==g&&2!==g)throw Error("Cannot get WebGL rendering context, WebGL is disabled.");var te=function(g){if("undefined"!=typeof OffscreenCanvas&&2===g)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw Error("Cannot create a canvas in this context")}(g);return(te.addEventListener("webglcontextlost",function(te){te.preventDefault(),delete tU[g]},!1),1===g)?te.getContext("webgl",tz)||te.getContext("experimental-webgl",tz):te.getContext("webgl2",tz)}(g));var te=tU[g];return te.isContextLost()?(delete tU[g],jt(g)):(te.disable(te.DEPTH_TEST),te.disable(te.STENCIL_TEST),te.disable(te.BLEND),te.disable(te.DITHER),te.disable(te.POLYGON_OFFSET_FILL),te.disable(te.SAMPLE_COVERAGE),te.enable(te.SCISSOR_TEST),te.enable(te.CULL_FACE),te.cullFace(te.BACK),tU[g])}function Yt(g){return T(Math.ceil(k(g)/4))}function $t(g,te){return[Math.max(1,Math.ceil(te/2)),Math.max(1,Math.ceil(g/2))]}function Qt(g,te){var tr,to,tu,tc,tl,td,tf,tp,tv;return 2===th.getNumber("WEBGL_VERSION")?(tr=g.R32F,to=g.R16F,tu=g.RGBA16F,tc=g.RGBA32F,tl=g.RED,td=4,tf=1,tp=g.HALF_FLOAT):(tr=g.RGBA,to=g.RGBA,tu=g.RGBA,tc=g.RGBA,tl=g.RGBA,td=4,tf=4,tp=null!=te?te.HALF_FLOAT_OES:null),tv=g.FLOAT,{internalFormatFloat:tr,internalFormatHalfFloat:to,internalFormatPackedHalfFloat:tu,internalFormatPackedFloat:tc,textureFormatFloat:tl,downloadTextureFormat:g.RGBA,downloadUnpackNumChannels:td,defaultNumChannels:tf,textureTypeHalfFloat:tp,textureTypeFloat:tv}}function Jt(g,te,tr){var to=tr();return te&&function(g){var te=g.getError();if(te!==g.NO_ERROR)throw Error("WebGL Error: "+ne(g,te))}(g),to}function ee(g){return!!(th.getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===g||596e-10<Math.abs(g)&&65504>Math.abs(g))}function ne(g,te){switch(te){case g.NO_ERROR:return"NO_ERROR";case g.INVALID_ENUM:return"INVALID_ENUM";case g.INVALID_VALUE:return"INVALID_VALUE";case g.INVALID_OPERATION:return"INVALID_OPERATION";case g.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case g.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case g.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+te}}function re(g,te,tr){return ke(g,te,function(){return g.getExtension(tr)},'Extension "'+tr+'" not supported on this browser.')}function oe(g,te,tr){var to=ke(g,te,function(){return g.createShader(g.VERTEX_SHADER)},"Unable to create vertex WebGLShader.");if(Jt(g,te,function(){return g.shaderSource(to,tr)}),Jt(g,te,function(){return g.compileShader(to)}),!1===g.getShaderParameter(to,g.COMPILE_STATUS))throw console.log(g.getShaderInfoLog(to)),Error("Failed to compile vertex shader.");return to}function ae(g,te,tr){var to=ke(g,te,function(){return g.createShader(g.FRAGMENT_SHADER)},"Unable to create fragment WebGLShader.");if(Jt(g,te,function(){return g.shaderSource(to,tr)}),Jt(g,te,function(){return g.compileShader(to)}),!1===g.getShaderParameter(to,g.COMPILE_STATUS))throw function(g,te){var tr=tX.exec(te);if(null==tr)return console.log("Couldn't parse line number in error: "+te),void console.log(g);for(var to=+tr[1],tu=g.split("\n"),tc=tu.length.toString().length+2,tl=tu.map(function(g,te){return N((te+1).toString(),tc)+g}),th=0,td=0;td<tl.length;td++)th=Math.max(tl[td].length,th);var tf=tl.slice(0,to-1),tp=tl.slice(to-1,to),tv=tl.slice(to);console.log(tf.join("\n")),console.log(te.split("\n")[0]),console.log("%c "+N(tp[0],th),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(tv.join("\n"))}(tr,g.getShaderInfoLog(to)),Error("Failed to compile fragment shader.");return to}(tH=tL||(tL={}))[tH.DENSE=0]="DENSE",tH[tH.SHARED_BATCH=1]="SHARED_BATCH",(tG=tW||(tW={}))[tG.RENDER=0]="RENDER",tG[tG.UPLOAD=1]="UPLOAD",tG[tG.PIXELS=2]="PIXELS",tG[tG.DOWNLOAD=3]="DOWNLOAD",(tq=tV||(tV={}))[tq.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",tq[tq.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",tq[tq.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",tq[tq.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",tq[tq.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16";var tH,tG,tq,tK,tj,tX=/ERROR: [0-9]+:([0-9]+):/g;function ce(g,te){return ke(g,te,function(){return g.createProgram()},"Unable to create WebGLProgram.")}function le(g,te,tr){if(Jt(g,te,function(){return g.linkProgram(tr)}),!1===g.getProgramParameter(tr,g.LINK_STATUS))throw console.log(g.getProgramInfoLog(tr)),Error("Failed to link vertex and fragment shaders.")}function he(g,te,tr){if(Jt(g,te,function(){return g.validateProgram(tr)}),!1===g.getProgramParameter(tr,g.VALIDATE_STATUS))throw console.log(g.getProgramInfoLog(tr)),Error("Shader program validation failed.")}function fe(g,te,tr){var to=ke(g,te,function(){return g.createBuffer()},"Unable to create WebGLBuffer");return Jt(g,te,function(){return g.bindBuffer(g.ARRAY_BUFFER,to)}),Jt(g,te,function(){return g.bufferData(g.ARRAY_BUFFER,tr,g.STATIC_DRAW)}),to}function de(g,te,tr){var to=ke(g,te,function(){return g.createBuffer()},"Unable to create WebGLBuffer");return Jt(g,te,function(){return g.bindBuffer(g.ELEMENT_ARRAY_BUFFER,to)}),Jt(g,te,function(){return g.bufferData(g.ELEMENT_ARRAY_BUFFER,tr,g.STATIC_DRAW)}),to}function pe(g,te){return ke(g,te,function(){return g.createTexture()},"Unable to create WebGLTexture.")}function ve(g,te){var tr=th.getNumber("WEBGL_MAX_TEXTURE_SIZE");if(g<=0||te<=0){var to="["+g+"x"+te+"]";throw Error("Requested texture size "+to+" is invalid.")}if(g>tr||te>tr)throw Error("Requested texture size "+(to="["+g+"x"+te+"]")+" greater than WebGL maximum on this browser / GPU "+("["+tr)+"x"+tr+"].")}function me(g,te){return ke(g,te,function(){return g.createFramebuffer()},"Unable to create WebGLFramebuffer.")}function ge(g,te,tr,to,tu,tc,tl,th){var td=g.getAttribLocation(tr,to);return -1!==td&&(Jt(g,te,function(){return g.bindBuffer(g.ARRAY_BUFFER,tu)}),Jt(g,te,function(){return g.vertexAttribPointer(td,tc,g.FLOAT,!1,tl,th)}),Jt(g,te,function(){return g.enableVertexAttribArray(td)}),!0)}function ye(g,te,tr,to){Se(g,to),Jt(g,te,function(){return g.activeTexture(g.TEXTURE0+to)}),Jt(g,te,function(){return g.bindTexture(g.TEXTURE_2D,tr)})}function xe(g,te,tr,to){return ke(g,te,function(){return g.getUniformLocation(tr,to)},'uniform "'+to+'" not present in program.')}function be(g,te,tr){return g.getUniformLocation(te,tr)}function we(g,te,tr,to,tu,tc){Jt(g,te,function(){return ye(g,te,to,tc)}),Jt(g,te,function(){return g.uniform1i(tu,tc)})}function Ce(g,te,tr,to){Jt(g,te,function(){return g.bindFramebuffer(g.FRAMEBUFFER,to)}),Jt(g,te,function(){return g.framebufferTexture2D(g.FRAMEBUFFER,g.COLOR_ATTACHMENT0,g.TEXTURE_2D,tr,0)})}function Ee(g,te,tr){Jt(g,te,function(){return g.bindFramebuffer(g.FRAMEBUFFER,tr)}),Jt(g,te,function(){return g.framebufferTexture2D(g.FRAMEBUFFER,g.COLOR_ATTACHMENT0,g.TEXTURE_2D,null,0)})}function Re(g){var te=g.checkFramebufferStatus(g.FRAMEBUFFER);if(te!==g.FRAMEBUFFER_COMPLETE)throw Error("Error binding framebuffer: "+Ie(g,te))}function Ie(g,te){switch(te){case g.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case g.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case g.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case g.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+te}}function ke(g,te,tr,to){var tu=Jt(g,te,function(){return tr()});if(null==tu)throw Error(to);return tu}function Se(g,te){var tr=g.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,to=te+g.TEXTURE0;if(to<g.TEXTURE0||to>tr)throw Error("textureUnit must be in [gl.TEXTURE0, gl.TEXTURE"+tr+"].")}function Ae(g,te){return void 0===te&&(te=2),k(g.slice(0,g.length-te))}function De(g){if(0===g.length)throw Error("Cannot get rows and columns of an empty shape array.");return[g.length>1?g[g.length-2]:1,g[g.length-1]]}function Te(g){var te=[1,1,1];return 0===g.length||1===g.length&&1===g[0]||(te=[Ae(g)].concat(De(g))),te}function Ne(g,te){void 0===te&&(te=!1);var tr,to=th.getNumber("WEBGL_MAX_TEXTURE_SIZE");te&&(to*=2,1===(g=g.map(function(te,tr){return tr>=g.length-2?b(g[tr]):g[tr]})).length&&(g=[2,g[0]])),2!==g.length&&(g=M(g).newShape);var tu=k(g);if(g.length<=1&&tu<=to)return[1,tu];if(2===g.length&&g[0]<=to&&g[1]<=to)return g;if(3===g.length&&g[0]*g[1]<=to&&g[2]<=to)return[g[0]*g[1],g[2]];if(3===g.length&&g[0]<=to&&g[1]*g[2]<=to)return[g[0],g[1]*g[2]];if(4===g.length&&g[0]*g[1]*g[2]<=to&&g[3]<=to)return[g[0]*g[1]*g[2],g[3]];if(4===g.length&&g[0]<=to&&g[1]*g[2]*g[3]<=to)return[g[0],g[1]*g[2]*g[3]];if(te){var tc=Ae(g),tl=2,td=2;return g.length&&(tl=(tr=De(g))[0],td=tr[1]),T(tu=tc*(tl/2)*(td/2)).map(function(g){return 2*g})}return T(tu)}function _e(g,te){if(S(g=g.slice(-2),te=te.slice(-2))||!g.length||!te.length||0===g[0]||0===g[1]||0===te[0]||0===te[1])return!0;if(g.length!==te.length){var tr=g.slice(-1)[0],to=te.slice(-1)[0];if(tr===to||tr%2==0&&to%2==0&&(1===g[0]||1===te[0]))return!0}return g[1]===te[1]&&g[0]%2==0&&te[0]%2==0}function Oe(g){if(null==tK){var te=jt(g);tK=te.getParameter(te.MAX_TEXTURE_SIZE)}return tK}function Me(g){if(null==tj){var te=jt(g);tj=te.getParameter(te.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,tj)}function Be(g){if(0===g)return 0;var te=jt(g);return Pe(te,"EXT_disjoint_timer_query_webgl2")&&2===g?2:Pe(te,"EXT_disjoint_timer_query")?1:0}function Pe(g,te){return null!=g.getExtension(te)}function Le(g){try{if(null!=jt(g))return!0}catch(g){}return!1}function We(g){if(0===g)return!1;var te=jt(g);if(1===g){if(!Pe(te,"OES_texture_float"))return!1}else if(!Pe(te,"EXT_color_buffer_float"))return!1;return Ve(te)}function Ue(g){if(0===g)return!1;var te=jt(g);if(1!==g){if(Pe(te,"EXT_color_buffer_float"))return Ve(te);if(Pe(te,"EXT_color_buffer_half_float")){var tr,to,tu,tc,tl=te.getExtension("EXT_color_buffer_half_float");return tr=Qt(te,tl),to=te.createTexture(),te.bindTexture(te.TEXTURE_2D,to),te.texImage2D(te.TEXTURE_2D,0,tr.internalFormatHalfFloat,1,1,0,tr.textureFormatFloat,tr.textureTypeHalfFloat,null),tu=te.createFramebuffer(),te.bindFramebuffer(te.FRAMEBUFFER,tu),te.framebufferTexture2D(te.FRAMEBUFFER,te.COLOR_ATTACHMENT0,te.TEXTURE_2D,to,0),tc=te.checkFramebufferStatus(te.FRAMEBUFFER)===te.FRAMEBUFFER_COMPLETE,te.bindTexture(te.TEXTURE_2D,null),te.bindFramebuffer(te.FRAMEBUFFER,null),te.deleteTexture(to),te.deleteFramebuffer(tu),tc}return!1}return!!Pe(te,"OES_texture_float")&&!!Pe(te,"WEBGL_color_buffer_float")&&Ve(te)}function Ve(g){var te=Qt(g),tr=g.createTexture();g.bindTexture(g.TEXTURE_2D,tr),g.texImage2D(g.TEXTURE_2D,0,te.internalFormatFloat,1,1,0,te.textureFormatFloat,te.textureTypeFloat,null);var to=g.createFramebuffer();g.bindFramebuffer(g.FRAMEBUFFER,to),g.framebufferTexture2D(g.FRAMEBUFFER,g.COLOR_ATTACHMENT0,g.TEXTURE_2D,tr,0);var tu=g.checkFramebufferStatus(g.FRAMEBUFFER)===g.FRAMEBUFFER_COMPLETE;return g.bindTexture(g.TEXTURE_2D,null),g.bindFramebuffer(g.FRAMEBUFFER,null),g.deleteTexture(tr),g.deleteFramebuffer(to),tu}function ze(g){return 2===g&&null!=jt(g).fenceSync}var t$=Object.freeze({callAndCheck:Jt,canBeRepresented:ee,getWebGLErrorMessage:ne,getExtensionOrThrow:re,createVertexShader:oe,createFragmentShader:ae,createProgram:ce,linkProgram:le,validateProgram:he,createStaticVertexBuffer:fe,createStaticIndexBuffer:de,getNumChannels:function(){return 2===th.getNumber("WEBGL_VERSION")?1:4},createTexture:pe,validateTextureSize:ve,createFramebuffer:me,bindVertexBufferToProgramAttribute:ge,bindTextureUnit:ye,unbindTextureUnit:function(g,te,tr){Se(g,tr),Jt(g,te,function(){return g.activeTexture(g.TEXTURE0+tr)}),Jt(g,te,function(){return g.bindTexture(g.TEXTURE_2D,null)})},getProgramUniformLocationOrThrow:xe,getProgramUniformLocation:be,bindTextureToProgramUniformSampler:we,bindCanvasToFramebuffer:function(g,te){Jt(g,te,function(){return g.bindFramebuffer(g.FRAMEBUFFER,null)}),Jt(g,te,function(){return g.viewport(0,0,g.canvas.width,g.canvas.height)}),Jt(g,te,function(){return g.scissor(0,0,g.canvas.width,g.canvas.height)})},bindColorTextureToFramebuffer:Ce,unbindColorTextureFromFramebuffer:Ee,validateFramebuffer:Re,getFramebufferErrorMessage:Ie,getBatchDim:Ae,getRowsCols:De,getShapeAs3D:Te,getTextureShapeFromLogicalShape:Ne,isReshapeFree:_e,getWebGLMaxTextureSize:Oe,resetMaxTextureSize:function(){tK=null},resetMaxTexturesInShader:function(){tj=null},getMaxTexturesInShader:Me,getWebGLDisjointQueryTimerVersion:Be,hasExtension:Pe,isWebGLVersionEnabled:Le,isCapableOfRenderingToFloatTexture:We,isDownloadFloatTextureEnabled:Ue,isWebGLFenceEnabled:ze}),tY=th;function Xe(g){th.getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(g+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Ze(g,te){return tB.tidy(g,te)}function tn(g){_t(g).forEach(function(g){return g.dispose()})}function en(g){return tB.keep(g)}function dn(){for(var g=[],te=0;te<arguments.length;te++)g[te]=arguments[te];th.getBool("IS_TEST")||console.warn.apply(console,g)}function pn(g,te){var tr=g;if(V(g))return"string"===te?[]:[g.length];if(!Array.isArray(g))return[];for(var to=[];Array.isArray(tr)||V(tr)&&"string"!==te;)to.push(tr.length),tr=tr[0];return Array.isArray(g)&&th.getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&function t(g,te,tr){if(tr=tr||[],!Array.isArray(g)&&!V(g))return void C(0===te.length,function(){return"Element arr["+tr.join("][")+"] is a primitive, but should be an array/TypedArray of "+te[0]+" elements"});C(te.length>0,function(){return"Element arr["+tr.join("][")+"] should be a primitive, but is an array of "+g.length+" elements"}),C(g.length===te[0],function(){return"Element arr["+tr.join("][")+"] should have "+te[0]+" elements, but has "+g.length+" elements"});for(var to=te.slice(1),tu=0;tu<g.length;++tu)t(g[tu],to,tr.concat(tu))}(g,to,[]),to}function vn(g,te,tr,to){if(null!=g&&("numeric"!==g&&g!==te||"numeric"===g&&"string"===te))throw Error("Argument '"+tr+"' passed to '"+to+"' must be "+g+" tensor, but got "+te+" tensor")}function mn(g,te,tr,to){if(void 0===to&&(to="numeric"),g instanceof tb)return vn(to,g.dtype,te,tr),g;var tu=j(g);if("string"!==tu&&["bool","int32","float32"].indexOf(to)>=0&&(tu=to),vn(to,tu,te,tr),null==g||!V(g)&&!Array.isArray(g)&&"number"!=typeof g&&"boolean"!=typeof g&&"string"!=typeof g)throw Error("Argument '"+te+"' passed to '"+tr+"' must be a Tensor or TensorLike, but got '"+(null==g?"null":g.constructor.name)+"'");var tc=pn(g,tu);V(g)||Array.isArray(g)||(g=[g]);var tl="string"!==tu?Q(g,tu,th.getBool("DEBUG")):I(g,[],!0);return tB.makeTensor(tl,tc,tu)}function gn(g,te,tr,to){if(void 0===to&&(to="numeric"),!Array.isArray(g))throw Error("Argument "+te+" passed to "+tr+" must be a `Tensor[]` or `TensorLike[]`");return g.map(function(g,to){return mn(g,te+"["+to+"]",tr)},to)}function yn(g,te){for(var tr=0;tr<g.length;++tr)if(g[g.length-tr-1]!==te-1-tr)return!1;return!0}function xn(g,te,tr){for(var to=g.length+te.length,tu=[],tc=0,tl=0,th=0;th<to;th++)-1===tr.indexOf(th)?tu.push(g[tc++]):tu.push(te[tl++]);return tu}function bn(g,te){for(var tr=[],to=g.length,tu=0;tu<to;tu++)-1===te.indexOf(tu)&&tr.push(g[tu]);return[tr,te.map(function(te){return g[te]})]}function wn(g,te){return xn(g,te.map(function(g){return 1}),te)}function Cn(g,te,tr){C(yn(te,tr),function(){return g+" supports only inner-most axes for now. Got axes "+te+" and rank-"+tr+" input."})}function En(g,te){if(yn(g,te))return null;for(var tr=[],to=0;to<te;++to)-1===g.indexOf(to)&&tr.push(to);return g.forEach(function(g){return tr.push(g)}),tr}function Rn(g){return g.map(function(g,te){return[te,g]}).sort(function(g,te){return g[1]-te[1]}).map(function(g){return g[0]})}function In(g,te){for(var tr=[],to=te-g;to<te;++to)tr.push(to);return tr}function kn(g,te){var tr=g[0].length;g.forEach(function(g,te){C(g.length===tr,function(){return"Error in concat"+tr+"D: rank of tensors["+te+"] must be the same as the rank of the rest ("+tr+")"})}),C(te>=0&&te<tr,function(){return"Error in concat"+tr+"D: axis must be between 0 and "+(tr-1)+"."});var to=g[0];g.forEach(function(g,tu){for(var tc=0;tc<tr;tc++)C(tc===te||g[tc]===to[tc],function(){return"Error in concat"+tr+"D: Shape of tensors["+tu+"] ("+g+") does not match the shape of the rest ("+to+") along the non-concatenated axis "+tu+"."})})}function Sn(g,te){for(var tr=g[0].slice(),to=1;to<g.length;to++)tr[te]+=g[to][te];return tr}function An(g){var te=Object.keys(g);if(1!==te.length)throw Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+te.length+" keys.");var tr=te[0],to=g[tr];tr.endsWith("_")&&(tr=tr.substring(0,tr.length-1));var o=function(){for(var g=[],te=0;te<arguments.length;te++)g[te]=arguments[te];tB.startScope(tr);try{var tu=to.apply(void 0,g);return tu instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),tB.endScope(tu),tu}catch(g){throw tB.endScope(null),g}};return Object.defineProperty(o,"name",{value:tr,configurable:!0}),o}tY.registerFlag("HAS_WEBGL",function(){return tY.getNumber("WEBGL_VERSION")>0}),tY.registerFlag("WEBGL_VERSION",function(){return Le(2)?2:Le(1)?1:0}),tY.registerFlag("WEBGL_BUFFER_SUPPORTED",function(){return 2===tY.get("WEBGL_VERSION")}),tY.registerFlag("WEBGL_CPU_FORWARD",function(){return!0}),tY.registerFlag("WEBGL_FORCE_F16_TEXTURES",function(){return!1}),tY.registerFlag("WEBGL_PACK",function(){return tY.getBool("HAS_WEBGL")}),tY.registerFlag("WEBGL_PACK_NORMALIZATION",function(){return tY.getBool("WEBGL_PACK")}),tY.registerFlag("WEBGL_PACK_CLIP",function(){return tY.getBool("WEBGL_PACK")}),tY.registerFlag("WEBGL_PACK_DEPTHWISECONV",function(){return!1}),tY.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",function(){return tY.getBool("WEBGL_PACK")}),tY.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",function(){return tY.getBool("WEBGL_PACK")}),tY.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",function(){return tY.getBool("WEBGL_PACK")}),tY.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",function(){return tY.getBool("WEBGL_PACK")}),tY.registerFlag("WEBGL_PACK_REDUCE",function(){return tY.getBool("WEBGL_PACK")}),tY.registerFlag("WEBGL_LAZILY_UNPACK",function(){return tY.getBool("WEBGL_PACK")}),tY.registerFlag("WEBGL_CONV_IM2COL",function(){return tY.getBool("WEBGL_PACK")}),tY.registerFlag("WEBGL_MAX_TEXTURE_SIZE",function(){return Oe(tY.getNumber("WEBGL_VERSION"))}),tY.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",function(){return Me(tY.getNumber("WEBGL_VERSION"))}),tY.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",function(){var g=tY.getNumber("WEBGL_VERSION");return 0===g?0:Be(g)}),tY.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",function(){var g;return tY.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&(g=navigator.userAgent||navigator.vendor||window.opera,!(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(g)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(g.substr(0,4))))}),tY.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",function(){return We(tY.getNumber("WEBGL_VERSION"))}),tY.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",function(){return!tY.getBool("WEBGL_FORCE_F16_TEXTURES")&&tY.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")}),tY.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",function(){return Ue(tY.getNumber("WEBGL_VERSION"))}),tY.registerFlag("WEBGL_FENCE_API_ENABLED",function(){return ze(tY.getNumber("WEBGL_VERSION"))}),tY.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",function(){return tY.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0}),tx=Xe;var tJ=An({complex_:function(g,te){var tr=mn(g,"real","complex"),to=mn(te,"imag","complex");return E(tr.shape,to.shape,"real and imag shapes, "+tr.shape+" and "+to.shape+", must match in call to tf.complex()."),tB.runKernelFunc(function(g){return g.complex(tr,to)},{$real:tr,$imag:to})}}),tQ=An({real_:function(g){var te=mn(g,"input","real");return tB.runKernelFunc(function(g){return g.real(te)},{$input:te})}}),tZ=An({imag_:function(g){var te=mn(g,"input","imag");return tB.runKernelFunc(function(g){return g.imag(te)},{$input:te})}});function Fn(g,te,tr){return _n(g,te,pn(g,tr),tr)}function _n(g,te,tr,to){if(null==to&&(to=j(g)),"complex64"===to)throw Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!V(g)&&!Array.isArray(g)&&"number"!=typeof g&&"boolean"!=typeof g&&"string"!=typeof g)throw Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=te){nt(te);var tu=k(te),tc=k(tr);C(tu===tc,function(){return"Based on the provided shape, ["+te+"], the tensor should have "+tu+" values but has "+tc});for(var tl=0;tl<tr.length;++tl){var td=tr[tl],tf=tl!==tr.length-1||td!==k(te.slice(tl));C(tr[tl]===te[tl]||!tf,function(){return"Error creating a new Tensor. Inferred shape ("+tr+") does not match the provided shape ("+te+"). "})}}return V(g)||Array.isArray(g)||(g=[g]),te=te||tr,g="string"!==to?Q(g,to,th.getBool("DEBUG")):I(g,[],!0),tB.makeTensor(g,te,to)}function On(g,te){if((V(g)&&"string"!==te||Array.isArray(g))&&"complex64"!==te)throw Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===te&&V(g)&&!(g instanceof Uint8Array))throw Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return _n(g,[],[],te)}function Mn(g,te){R(g);var tr=pn(g,te);if(1!==tr.length)throw Error("tensor1d() requires values to be a flat/TypedArray");return _n(g,null,tr,te)}function Bn(g,te,tr){if(R(g),null!=te&&2!==te.length)throw Error("tensor2d() requires shape to have two numbers");var to=pn(g,tr);if(2!==to.length&&1!==to.length)throw Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===to.length&&null==te)throw Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return _n(g,te,to,tr)}function Pn(g,te,tr){if(R(g),null!=te&&3!==te.length)throw Error("tensor3d() requires shape to have three numbers");var to=pn(g,tr);if(3!==to.length&&1!==to.length)throw Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===to.length&&null==te)throw Error("tensor3d() requires shape to be provided when `values` are a flat array");return _n(g,te,to,tr)}function Ln(g,te,tr){if(R(g),null!=te&&4!==te.length)throw Error("tensor4d() requires shape to have four numbers");var to=pn(g,tr);if(4!==to.length&&1!==to.length)throw Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===to.length&&null==te)throw Error("tensor4d() requires shape to be provided when `values` are a flat array");return _n(g,te,to,tr)}function Wn(g,te,tr){if(R(g),null!=te&&5!==te.length)throw Error("tensor5d() requires shape to have five numbers");var to=pn(g,tr);if(5!==to.length&&1!==to.length)throw Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===to.length&&null==te)throw Error("tensor5d() requires shape to be provided when `values` are a flat array");return _n(g,te,to,tr)}function Un(g,te,tr){if(R(g),null!=te&&6!==te.length)throw Error("tensor6d() requires shape to have six numbers");var to=pn(g,tr);if(6!==to.length&&1!==to.length)throw Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===to.length&&null==te)throw Error("tensor6d() requires shape to be provided when `values` are a flat array");return _n(g,te=te||to,to,tr)}function Vn(g,te,tr,to){return void 0===te&&(te=!0),tB.makeVariable(g,te,tr,to)}function zn(g,te){if(void 0===te&&(te="float32"),"complex64"===te)return tJ(zn(g,"float32"),Gn(g,"float32"));var tr=Z(k(g),te);return tB.makeTensor(tr,g,te)}function Gn(g,te){if(void 0===te&&(te="float32"),"complex64"===te)return tJ(Gn(g,"float32"),Gn(g,"float32"));var tr=tt(k(g),te);return tB.makeTensor(tr,g,te)}function Hn(g,te,tr){return tB.runKernelFunc(function(to){return to.fill(g,te,tr)},{})}function qn(g,te,tr){if(tr<=0)throw Error("The number of values should be positive.");return tB.runKernelFunc(function(to){return to.linspace(g,te,tr)},{})}function Kn(g,te,tr,to){if(void 0===tr&&(tr=1),void 0===to&&(to="float32"),0===tr)throw Error("Cannot have a step of zero");if(g===te||g<te&&tr<0||te<g&&tr>1)return Gn([0],to);var tu=tt(Math.abs(Math.ceil((te-g)/tr)),to);te<g&&1===tr&&(tr=-1),tu[0]=g;for(var tc=1;tc<tu.length;tc++)tu[tc]=tu[tc-1]+tr;return Mn(tu,to)}var t0=An({onesLike_:function(g){var te=mn(g,"x","onesLike");return"complex64"===te.dtype?tJ(t0(tQ(te)),t1(tZ(te))):tB.runKernelFunc(function(g){return g.onesLike(te)},{$x:te},function(g,te){return{$x:function(){return t1(g)}}})}}),t1=An({zerosLike_:function(g){var te=mn(g,"x","zerosLike");return tB.runKernelFunc(function(g){return g.zerosLike(te)},{$x:te},function(g,te){return{$x:function(){return t1(g)}}})}}),t2=An({concat_:function(g,te){void 0===te&&(te=0),C(g.length>=1,function(){return"Pass at least one tensor to concat"});var tr=gn(g,"tensors","concat");"complex64"===tr[0].dtype&&tr.forEach(function(g){if("complex64"!==g.dtype)throw Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype "+g.dtype+". ")}),te=O(te,tr[0].shape)[0];var to=Sn(tr.map(function(g){return g.shape}),te);if(0===k(to))return Fn([],to);if(1===(tr=tr.filter(function(g){return g.size>0})).length)return tr[0];var tu=tr.map(function(g){return g.shape});kn(tu,te);var tc=tr,tl={axis:te};return tB.runKernelFunc(function(g){return g.concat(tr,te)},tc,function(g){return t8(g,tu.map(function(g){return g[te]}),te).map(function(g){return function(){return g}})},"Concat",tl)}}),t3=An({concat1d_:function(g){return t2(g,0)}}),t4=An({concat2d_:function(g,te){return t2(g,te)}}),t5=An({concat3d_:function(g,te){return t2(g,te)}}),t6=An({concat4d_:function(g,te){return t2(g,te)}}),t8=An({split_:function(g,te,tr){void 0===tr&&(tr=0);var to,tu=mn(g,"x","split");return tr=O(tr,tu.shape)[0],"number"==typeof te?(C(tu.shape[tr]%te==0,function(){return"Number of splits must evenly divide the axis."}),to=Array(te).fill(tu.shape[tr]/te)):(C(tu.shape[tr]===te.reduce(function(g,te){return g+te}),function(){return"The sum of sizes must match the size of the axis dimension."}),to=te),tB.runKernelFunc(function(g){return g.split(tu,to,tr)},{$x:tu},function(g){return{$x:function(){return t2(g,tr)}}})}});function er(g,te){return g(te={exports:{}},te.exports),te.exports}"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:void 0!==tr.g?tr.g:"undefined"!=typeof self&&self;var t7=er(function(g){!function(g,te,tr){function r(g){var te,tr=this,to=(te=4022871197,function(g){g=g.toString();for(var tr=0;tr<g.length;tr++){var to=.02519603282416938*(te+=g.charCodeAt(tr));to-=te=to>>>0,te=(to*=te)>>>0,te+=4294967296*(to-=te)}return 23283064365386963e-26*(te>>>0)});tr.next=function(){var g=2091639*tr.s0+23283064365386963e-26*tr.c;return tr.s0=tr.s1,tr.s1=tr.s2,tr.s2=g-(tr.c=0|g)},tr.c=1,tr.s0=to(" "),tr.s1=to(" "),tr.s2=to(" "),tr.s0-=to(g),tr.s0<0&&(tr.s0+=1),tr.s1-=to(g),tr.s1<0&&(tr.s1+=1),tr.s2-=to(g),tr.s2<0&&(tr.s2+=1),to=null}function o(g,te){return te.c=g.c,te.s0=g.s0,te.s1=g.s1,te.s2=g.s2,te}function a(g,te){var tr=new r(g),to=te&&te.state,tu=tr.next;return tu.int32=function(){return 4294967296*tr.next()|0},tu.double=function(){return tu()+11102230246251565e-32*(2097152*tu()|0)},tu.quick=tu,to&&("object"==typeof to&&o(to,tr),tu.state=function(){return o(tr,{})}),tu}te&&te.exports?te.exports=a:tr&&tr.amd?tr(function(){return a}):this.alea=a}(0,g,!1)}),t9=er(function(g){!function(g,te,tr){function r(g){var te=this,tr="";te.x=0,te.y=0,te.z=0,te.w=0,te.next=function(){var g=te.x^te.x<<11;return te.x=te.y,te.y=te.z,te.z=te.w,te.w^=te.w>>>19^g^g>>>8},g===(0|g)?te.x=g:tr+=g;for(var to=0;to<tr.length+64;to++)te.x^=0|tr.charCodeAt(to),te.next()}function o(g,te){return te.x=g.x,te.y=g.y,te.z=g.z,te.w=g.w,te}function a(g,te){var tr=new r(g),to=te&&te.state,i=function(){return(tr.next()>>>0)/4294967296};return i.double=function(){do var g=((tr.next()>>>11)+(tr.next()>>>0)/4294967296)/2097152;while(0===g);return g},i.int32=tr.next,i.quick=i,to&&("object"==typeof to&&o(to,tr),i.state=function(){return o(tr,{})}),i}te&&te.exports?te.exports=a:tr&&tr.amd?tr(function(){return a}):this.xor128=a}(0,g,!1)}),nn=er(function(g){!function(g,te,tr){function r(g){var te=this,tr="";te.next=function(){var g=te.x^te.x>>>2;return te.x=te.y,te.y=te.z,te.z=te.w,te.w=te.v,(te.d=te.d+362437|0)+(te.v=te.v^te.v<<4^g^g<<1)|0},te.x=0,te.y=0,te.z=0,te.w=0,te.v=0,g===(0|g)?te.x=g:tr+=g;for(var to=0;to<tr.length+64;to++)te.x^=0|tr.charCodeAt(to),to==tr.length&&(te.d=te.x<<10^te.x>>>4),te.next()}function o(g,te){return te.x=g.x,te.y=g.y,te.z=g.z,te.w=g.w,te.v=g.v,te.d=g.d,te}function a(g,te){var tr=new r(g),to=te&&te.state,i=function(){return(tr.next()>>>0)/4294967296};return i.double=function(){do var g=((tr.next()>>>11)+(tr.next()>>>0)/4294967296)/2097152;while(0===g);return g},i.int32=tr.next,i.quick=i,to&&("object"==typeof to&&o(to,tr),i.state=function(){return o(tr,{})}),i}te&&te.exports?te.exports=a:tr&&tr.amd?tr(function(){return a}):this.xorwow=a}(0,g,!1)}),nr=er(function(g){!function(g,te,tr){function r(g){var te=this;te.next=function(){var g,tr,to=te.x,tu=te.i;return g=to[tu],tr=(g^=g>>>7)^g<<24^((g=to[tu+1&7])^g>>>10)^((g=to[tu+3&7])^g>>>3)^((g=to[tu+4&7])^g<<7),g=to[tu+7&7],tr^=(g^=g<<13)^g<<9,to[tu]=tr,te.i=tu+1&7,tr},function(g,te){var tr,to=[];if(te===(0|te))to[0]=te;else for(te=""+te,tr=0;tr<te.length;++tr)to[7&tr]=to[7&tr]<<15^te.charCodeAt(tr)+to[tr+1&7]<<13;for(;to.length<8;)to.push(0);for(tr=0;tr<8&&0===to[tr];++tr);for(8==tr?to[7]=-1:to[tr],g.x=to,g.i=0,tr=256;tr>0;--tr)g.next()}(te,g)}function o(g,te){return te.x=g.x.slice(),te.i=g.i,te}function a(g,te){null==g&&(g=+new Date);var tr=new r(g),to=te&&te.state,i=function(){return(tr.next()>>>0)/4294967296};return i.double=function(){do var g=((tr.next()>>>11)+(tr.next()>>>0)/4294967296)/2097152;while(0===g);return g},i.int32=tr.next,i.quick=i,to&&(to.x&&o(to,tr),i.state=function(){return o(tr,{})}),i}te&&te.exports?te.exports=a:tr&&tr.amd?tr(function(){return a}):this.xorshift7=a}(0,g,!1)}),nu=er(function(g){!function(g,te,tr){function r(g){var te=this;te.next=function(){var g,tr,to=te.w,tu=te.X,tc=te.i;return te.w=to=to+1640531527|0,tr=tu[tc+34&127],g=tu[tc=tc+1&127],tr^=tr<<13,g^=g<<17,tr^=tr>>>15,g^=g>>>12,tr=tu[tc]=tr^g,te.i=tc,tr+(to^to>>>16)|0},function(g,te){var tr,to,tu,tc,tl,th=[],td=128;for(te===(0|te)?(to=te,te=null):(te+="\x00",to=0,td=Math.max(td,te.length)),tu=0,tc=-32;tc<td;++tc)te&&(to^=te.charCodeAt((tc+32)%te.length)),0===tc&&(tl=to),to^=to<<10,to^=to>>>15,to^=to<<4,to^=to>>>13,tc>=0&&(tl=tl+1640531527|0,tu=0==(tr=th[127&tc]^=to+tl)?tu+1:0);for(tu>=128&&(th[127&(te&&te.length||0)]=-1),tu=127,tc=512;tc>0;--tc)to=th[tu+34&127],tr=th[tu=tu+1&127],to^=to<<13,tr^=tr<<17,to^=to>>>15,tr^=tr>>>12,th[tu]=to^tr;g.w=tl,g.X=th,g.i=tu}(te,g)}function o(g,te){return te.i=g.i,te.w=g.w,te.X=g.X.slice(),te}function a(g,te){null==g&&(g=+new Date);var tr=new r(g),to=te&&te.state,i=function(){return(tr.next()>>>0)/4294967296};return i.double=function(){do var g=((tr.next()>>>11)+(tr.next()>>>0)/4294967296)/2097152;while(0===g);return g},i.int32=tr.next,i.quick=i,to&&(to.X&&o(to,tr),i.state=function(){return o(tr,{})}),i}te&&te.exports?te.exports=a:tr&&tr.amd?tr(function(){return a}):this.xor4096=a}(0,g,!1)}),nl=er(function(g){!function(g,te,tr){function r(g){var te=this,tr="";te.next=function(){var g=te.b,tr=te.c,to=te.d,tu=te.a;return g=g<<25^g>>>7^tr,tr=tr-to|0,to=to<<24^to>>>8^tu,tu=tu-g|0,te.b=g=g<<20^g>>>12^tr,te.c=tr=tr-to|0,te.d=to<<16^tr>>>16^tu,te.a=tu-g|0},te.a=0,te.b=0,te.c=-1640531527,te.d=1367130551,g===Math.floor(g)?(te.a=g/4294967296|0,te.b=0|g):tr+=g;for(var to=0;to<tr.length+20;to++)te.b^=0|tr.charCodeAt(to),te.next()}function o(g,te){return te.a=g.a,te.b=g.b,te.c=g.c,te.d=g.d,te}function a(g,te){var tr=new r(g),to=te&&te.state,i=function(){return(tr.next()>>>0)/4294967296};return i.double=function(){do var g=((tr.next()>>>11)+(tr.next()>>>0)/4294967296)/2097152;while(0===g);return g},i.int32=tr.next,i.quick=i,to&&("object"==typeof to&&o(to,tr),i.state=function(){return o(tr,{})}),i}te&&te.exports?te.exports=a:tr&&tr.amd?tr(function(){return a}):this.tychei=a}(0,g,!1)}),nh=er(function(g){!function(te,to){var tu,tc=this,tl="random",th=to.pow(256,6),td=to.pow(2,52),tf=2*td;function f(g,tr,tp){var tv=[],tm=v(function t(g,te){var tr,to=[],tu=typeof g;if(te&&"object"==tu)for(tr in g)try{to.push(t(g[tr],te-1))}catch(g){}return to.length?to:"string"==tu?g:g+"\x00"}((tr=1==tr?{entropy:!0}:tr||{}).entropy?[g,m(te)]:null==g?function(){try{var g;return tu&&(g=tu.randomBytes)?g=g(256):(g=new Uint8Array(256),(tc.crypto||tc.msCrypto).getRandomValues(g)),m(g)}catch(g){var tr=tc.navigator,to=tr&&tr.plugins;return[+new Date,tc,to,tc.screen,m(te)]}}():g,3),tv),tg=new d(tv),b=function(){for(var g=tg.g(6),te=th,tr=0;g<td;)g=(g+tr)*256,te*=256,tr=tg.g(1);for(;g>=tf;)g/=2,te/=2,tr>>>=1;return(g+tr)/te};return b.int32=function(){return 0|tg.g(4)},b.quick=function(){return tg.g(4)/4294967296},b.double=b,v(m(tg.S),te),(tr.pass||tp||function(g,te,tr,tu){return tu&&(tu.S&&p(tu,tg),g.state=function(){return p(tg,{})}),tr?(to[tl]=g,te):g})(b,tm,"global"in tr?tr.global:this==to,tr.state)}function d(g){var te,tr=g.length,to=this,tu=0,tc=to.i=to.j=0,tl=to.S=[];for(tr||(g=[tr++]);tu<256;)tl[tu]=tu++;for(tu=0;tu<256;tu++)tl[tu]=tl[tc=255&tc+g[tu%tr]+(te=tl[tu])],tl[tc]=te;(to.g=function(g){for(var te,tr=0,tu=to.i,tc=to.j,tl=to.S;g--;)te=tl[tu=255&tu+1],tr=256*tr+tl[255&(tl[tu]=tl[tc=255&tc+te])+(tl[tc]=te)];return to.i=tu,to.j=tc,tr})(256)}function p(g,te){return te.i=g.i,te.j=g.j,te.S=g.S.slice(),te}function v(g,te){for(var tr,to=g+"",tu=0;tu<to.length;)te[255&tu]=255&(tr^=19*te[255&tu])+to.charCodeAt(tu++);return m(te)}function m(g){return String.fromCharCode.apply(0,g)}if(to["seed"+tl]=f,v(to.random(),te),g.exports){g.exports=f;try{tu=tr(4902)}catch(g){}}}([],Math)});nh.alea=t7,nh.xor128=t9,nh.xorwow=nn,nh.xorshift7=nr,nh.xor4096=nu,nh.tychei=nl;var nd=nh.alea,nf=function(){function t(g,te,tr,to,tu){this.mean=g,this.stdDev=te,this.dtype=tr,this.nextVal=NaN,this.truncated=to,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);var tc=tu||Math.random();this.random=nd(tc.toString())}return t.prototype.nextValue=function(){if(!isNaN(this.nextVal)){var g=this.nextVal;return this.nextVal=NaN,g}for(var te,tr,to=!1;!to;){var tu=void 0,tc=void 0,tl=void 0;do tl=(tu=2*this.random()-1)*tu+(tc=2*this.random()-1)*tc;while(tl>=1||0===tl);var th=Math.sqrt(-2*Math.log(tl)/tl);te=this.mean+this.stdDev*tu*th,tr=this.mean+this.stdDev*tc*th,this.truncated&&!this.isValidTruncated(te)||(to=!0)}return this.truncated&&!this.isValidTruncated(tr)||(this.nextVal=this.convertValue(tr)),this.convertValue(te)},t.prototype.convertValue=function(g){return null==this.dtype||"float32"===this.dtype?g:Math.round(g)},t.prototype.isValidTruncated=function(g){return g<=this.upper&&g>=this.lower},t}(),np=function(){function t(g,te,tr,to){this.alpha=g,this.beta=1/te,this.dtype=tr;var tu=to||Math.random();this.randu=nd(tu.toString()),this.randn=new nf(0,1,tr,!1,this.randu()),this.d=g<1?g+2/3:g-1/3,this.c=1/Math.sqrt(9*this.d)}return t.prototype.nextValue=function(){for(var g,te,tr,to,tu,tc;;){do to=this.randn.nextValue(),tc=1+this.c*to;while(tc<=0);if(tc*=tc*tc,te=1-.331*(g=to*to)*g,tr=.5*g+this.d*(1-tc+Math.log(tc)),(tu=this.randu())<te||Math.log(tu)<tr)break}return tc=1/this.beta*this.d*tc,this.alpha<1&&(tc*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(tc)},t.prototype.convertValue=function(g){return"float32"===this.dtype?g:Math.round(g)},t}(),nv=function(){function t(g,te,tr,to){var tu=this;if(void 0===g&&(g=0),void 0===te&&(te=1),this.canReturnFloat=function(){return null==tu.dtype||"float32"===tu.dtype},this.min=g,this.range=te-g,this.dtype=tr,null==to&&(to=Math.random()),"number"==typeof to&&(to=to.toString()),!this.canReturnFloat()&&this.range<=1)throw Error("The difference between "+g+" - "+te+" <= 1 and dtype is not float");this.random=nd(to)}return t.prototype.convertValue=function(g){return this.canReturnFloat()?g:Math.round(g)},t.prototype.nextValue=function(){return this.convertValue(this.min+this.range*this.random())},t}();function dr(g,te,tr){return void 0===te&&(te="float32"),te=te||"float32",nt(g),new tm(g,te,tr)}function pr(g,te){void 0===te&&(te=!1),console.log(g.toString(te))}var nm=An({batchToSpaceND_:function(g,te,tr){var to=mn(g,"x","batchToSpaceND"),tu=te.reduce(function(g,te){return g*te});return C(to.rank>=1+te.length,function(){return"input rank is "+to.rank+" but should be > than blockShape.length "+te.length}),C(tr.length===te.length,function(){return"crops.length is "+tr.length+" but should be equal to blockShape.length  "+te.length}),C(to.shape[0]%tu==0,function(){return"input tensor batch is "+to.shape[0]+" but is not divisible by the product of the elements of blockShape "+te.join(" * ")+" === "+tu}),tB.runKernelFunc(function(g){return g.batchToSpaceND(to,te,tr)},{$x:to},function(g){return{$x:function(){return g.spaceToBatchND(te,tr)}}})}}),ng=An({broadcastTo_:function(g,te){var tr=mn(g,"broadcastTo","x"),to=tr.shape;if(te.some(function(g){return!(g>0)||g%1!=0}))throw Error("broadcastTo(): Invalid broadcast shape ["+te+"].");if(te.length<tr.rank)throw Error("broadcastTo(): shape.length="+te.length+" < input.rank="+tr.rank+".");if(te.length>tr.rank){for(var tu=tr.shape.slice();tu.length<te.length;)tu.unshift(1);tr=tr.reshape(tu)}for(var tc=Array.from(te),tl=te.length-1;tl>=0;tl--)if(tr.shape[tl]===te[tl])tc[tl]=1;else if(1!==tr.shape[tl])throw Error("broadcastTo(): ["+to+"] cannot be broadcast to ["+te+"].");var th=tc.map(function(g,te){return g>1?te:-1}).filter(function(g){return g>=0});return 0===th.length?tr.clone():tB.runKernelFunc(function(g){return g.tile(tr,tc)},{input:tr},function(g){return{input:function(){return g.sum(th,!0)}}})}}),ny=An({cast_:function(g,te){var tr=mn(g,"x","cast");if(!W(te))throw Error("Failed to cast to unknown dtype "+te);if("string"===te&&"string"!==tr.dtype||"string"!==te&&"string"===tr.dtype)throw Error("Only strings can be casted to strings");return tB.runKernelFunc(function(g){return g.cast(tr,te)},{x:tr},function(g){return{x:function(){return g.clone()}}},"Cast",{dtype:te})}}),nx=An({clone_:function(g){var te=mn(g,"x","clone",null);return tB.runKernelFunc(function(){return tB.makeTensorFromDataId(te.dataId,te.shape,te.dtype)},{$x:te},function(g){return{$x:function(){return g.toFloat()}}})}}),nb=An({cumsum_:function(g,te,tr,to){void 0===te&&(te=0),void 0===tr&&(tr=!1),void 0===to&&(to=!1);var tu=mn(g,"x","cumsum"),tc=En([te|=0],tu.rank),tl=tu;null!=tc&&(tl=tu.transpose(tc));var th=In(1,tu.rank)[0],td=tB.runKernelFunc(function(g){return g.cumsum(tl,th,tr,to)},{permutedX:tl},function(g){return{permutedX:function(){return g.cumsum(te,tr,!to)}}});return null!=tc&&(td=td.transpose(tc)),td}}),nC=An({depthToSpace_:function(g,te,tr){void 0===tr&&(tr="NHWC");var to=mn(g,"x","depthToSpace"),tu="NHWC"===tr?to.shape[1]:to.shape[2],tc="NHWC"===tr?to.shape[2]:to.shape[3],tl="NHWC"===tr?to.shape[3]:to.shape[1];return C(tu*te>=0,function(){return"Negative dimension size caused by overflow when multiplying\n      "+tu+" and "+te+"  for depthToSpace with input shape\n      "+to.shape}),C(tc*te>=0,function(){return"Negative dimension size caused by overflow when multiplying\n      "+tc+" and "+te+" for depthToSpace with input shape\n          "+to.shape}),C(tl%(te*te)==0,function(){return"Dimension size must be evenly divisible by "+te*te+" but is "+tl+" for depthToSpace with input shape "+to.shape}),tB.runKernelFunc(function(g){return g.depthToSpace(to,te,tr)},{$x:to})}}),nw=An({expandDims_:function(g,te){void 0===te&&(te=0);var tr=mn(g,"x","expandDims",null);C(te<=tr.rank,function(){return"Axis must be <= rank of the tensor"});var to=tr.shape.slice();return te<0&&(C(-(tr.rank+1)<=te,function(){return"Axis must be in the interval ["+-(tr.rank+1)+", "+tr.rank+"]"}),te=tr.rank+te+1),to.splice(te,0,1),nM(tr,to)}}),nE=An({eye_:function(g,te,tr,to){void 0===to&&(to="float32"),null==te&&(te=g);for(var tu=dr([g,te],to),tc=g<=te?g:te,tl=0;tl<tc;++tl)tu.set(1,tl,tl);var th=tu.toTensor().as2D(g,te);if(null==tr)return th;if(1===tr.length)return nW(nw(th,0),[tr[0],1,1]);if(2===tr.length)return nW(nw(nw(th,0),0),[tr[0],tr[1],1,1]);if(3===tr.length)return nW(nw(nw(nw(th,0),0),0),[tr[0],tr[1],tr[2],1,1]);throw Error("eye() currently supports only 1D and 2D batchShapes, but received "+tr.length+"D.")}}),nR=An({multinomial_:function(g,te,tr,to){void 0===to&&(to=!1);var tu=mn(g,"logits","multinomial"),tc=tu.size,tl=tu.rank;if(tc<2)throw Error("Error in multinomial: you need at least 2 outcomes, but got "+tc+".");if(tl>2)throw Error("Rank of probabilities must be 1 or 2, but is "+tl);tr=tr||Math.random();var th=1===tl?tu.as2D(1,-1):tu,td=tB.runKernelFunc(function(g){return g.multinomial(th,to,te,tr)},{logits2D:th});return 1===tl?td.as1D():td}}),nI=An({oneHot_:function(g,te,tr,to){if(void 0===tr&&(tr=1),void 0===to&&(to=0),te<2)throw Error("Error in oneHot: depth must be >=2, but it is "+te);var tu=mn(g,"indices","oneHot","int32"),tc=tu.shape.concat([te]);return tu=tu.flatten(),tB.runKernelFunc(function(g){return g.oneHot(tu,te,tr,to)},{$indices:tu},function(g){return{$indices:function(){return Gn(tu.shape,"float32")}}}).reshape(tc)}}),nk=An({pad_:function(g,te,tr){void 0===tr&&(tr=0);var to=mn(g,"x","pad");if(0===to.rank)throw Error("pad(scalar) is not defined. Pass non-scalar to pad");var tu={paddings:te,constantValue:tr};return tB.runKernelFunc(function(g){return g.pad(to,te,tr)},{x:to},function(g){var tr=te.map(function(g){return g[0]});return{x:function(){return g.slice(tr,to.shape)}}},"PadV2",tu)}}),nA=An({pad1d_:function(g,te,tr){return void 0===tr&&(tr=0),C(2===te.length,function(){return"Invalid number of paddings. Must be length of 2."}),nk(g,[te],tr)}}),nS=An({pad2d_:function(g,te,tr){return void 0===tr&&(tr=0),C(2===te.length&&2===te[0].length&&2===te[1].length,function(){return"Invalid number of paddings. Must be length of 2 each."}),nk(g,te,tr)}}),nD=An({pad3d_:function(g,te,tr){return void 0===tr&&(tr=0),C(3===te.length&&2===te[0].length&&2===te[1].length&&2===te[2].length,function(){return"Invalid number of paddings. Must be length of 2 each."}),nk(g,te,tr)}}),nN=An({pad4d_:function(g,te,tr){return void 0===tr&&(tr=0),C(4===te.length&&2===te[0].length&&2===te[1].length&&2===te[2].length&&2===te[3].length,function(){return"Invalid number of paddings. Must be length of 2 each."}),nk(g,te,tr)}}),nT=An({rand_:function(g,te,tr){var to=k(g),tu=null;if(null==tr||"float32"===tr)tu=new Float32Array(to);else if("int32"===tr)tu=new Int32Array(to);else{if("bool"!==tr)throw Error("Unknown data type "+tr);tu=new Uint8Array(to)}for(var tc=0;tc<to;tc++)tu[tc]=te();return tB.makeTensor(tu,g,tr)}}),nF=An({randomNormal_:function(g,te,tr,to,tu){if(void 0===te&&(te=0),void 0===tr&&(tr=1),null!=to&&"bool"===to)throw Error("Unsupported data type "+to);for(var tc=new nf(te,tr,to,!1,tu),tl=dr(g,to),th=0;th<tl.values.length;th++)tl.values[th]=tc.nextValue();return tl.toTensor()}}),nO=An({randomGamma_:function(g,te,tr,to,tu){if(void 0===tr&&(tr=1),void 0===to&&(to="float32"),null==tr&&(tr=1),null==to&&(to="float32"),"float32"!==to&&"int32"!==to)throw Error("Unsupported data type "+to);for(var tc=new np(te,tr,to,tu),tl=dr(g,to),th=0;th<tl.values.length;th++)tl.values[th]=tc.nextValue();return tl.toTensor()}}),n_=An({randomUniform_:function(g,te,tr,to,tu){void 0===te&&(te=0),void 0===tr&&(tr=1),void 0===to&&(to="float32");for(var tc=dr(g,to),tl=new nv(te,tr,null,tu),th=0;th<tc.values.length;th++)tc.values[th]=tl.nextValue();return tc.toTensor()}}),nM=An({reshape_:function(g,te){var tr=mn(g,"x","reshape",null);te=_(te,tr.size),C(tr.size===k(te),function(){return"new shape and old shape must have the same number of elements."});var to={shape:te};return tB.runKernelFunc(function(g){return g.reshape(tr,te)},{x:tr},function(g){return{x:function(){return g.reshape(tr.shape)}}},"Reshape",to)}}),nB=An({spaceToBatchND_:function(g,te,tr){var to=mn(g,"x","spaceToBatchND");return C(to.rank>=1+te.length,function(){return"input rank "+to.rank+" should be > than [blockShape] "+te.length}),C(tr.length===te.length,function(){return"paddings.shape[0] "+tr.length+" must be equal to [blockShape] "+te.length}),C(to.shape.reduce(function(g,to,tu){return tu>0&&tu<=te.length?g&&(to+tr[tu-1][0]+tr[tu-1][1])%te[tu-1]==0:g},!0),function(){return"input spatial dimensions "+to.shape.slice(1)+" with paddings "+tr.toString()+" must be divisible by blockShapes "+te.toString()}),tB.runKernelFunc(function(g){return g.spaceToBatchND(to,te,tr)},{$x:to},function(g){return{$x:function(){return g.batchToSpaceND(te,tr)}}})}}),nP=An({squeeze_:function(g,te){var tr=mn(g,"x","squeeze");return nM(tr,M(tr.shape,te).newShape)}}),nL=An({stack_:function(g,te){void 0===te&&(te=0);var tr=gn(g,"tensors","stack");if(C(tr.length>=1,function(){return"Pass at least one tensor to tf.stack"}),1===tr.length)return tr[0].expandDims(te);var to=tr[0].rank,tu=tr[0].shape,tc=tr[0].dtype;return C(te<=to,function(){return"Axis must be <= rank of the tensor"}),tr.forEach(function(g){E(tu,g.shape,"All tensors passed to stack must have matching shapes")}),tr.forEach(function(g){C(tc===g.dtype,function(){return"All tensors passed to stack must have matching dtypes"})}),t2(tr.map(function(g){return g.expandDims(te)}),te)}}),nW=An({tile_:function(g,te){var tr=mn(g,"x","tile",null);C(tr.rank===te.length,function(){return"Error in transpose: rank of input "+tr.rank+" must match length of reps "+te+"."});var to=[tr];return tB.runKernelFunc(function(g,to){var tu=g.tile(tr,te);return to([tr]),tu},{x:tr},function(g,tr){var to=tr[0];return{x:function(){var tr=t1(to);if(1===to.rank)for(var tu=0;tu<te[0];++tu)tr=tr.add(g.slice([tu*to.shape[0]],[to.shape[0]]));else if(2===to.rank)for(tu=0;tu<te[0];++tu)for(var tc=0;tc<te[1];++tc)tr=tr.add(g.slice([tu*to.shape[0],tc*to.shape[1]],[to.shape[0],to.shape[1]]));else if(3===to.rank)for(tu=0;tu<te[0];++tu)for(tc=0;tc<te[1];++tc)for(var tl=0;tl<te[2];++tl)tr=tr.add(g.slice([tu*to.shape[0],tc*to.shape[1],tl*to.shape[2]],[to.shape[0],to.shape[1],to.shape[2]]));else{if(4!==to.rank)throw Error("Gradient for tile operation is not implemented for rank-"+to.rank+" tensors yet.");for(tu=0;tu<te[0];++tu)for(tc=0;tc<te[1];++tc)for(tl=0;tl<te[2];++tl)for(var th=0;th<te[3];++th)tr=tr.add(g.slice([tu*to.shape[0],tc*to.shape[1],tl*to.shape[2],th*to.shape[3]],[to.shape[0],to.shape[1],to.shape[2],to.shape[3]]))}return tr}}},"Tile",{reps:te},to)}}),nV=An({truncatedNormal_:function(g,te,tr,to,tu){if(void 0===te&&(te=0),void 0===tr&&(tr=1),null!=to&&"bool"===to)throw Error("Unsupported data type "+to);for(var tc=new nf(te,tr,to,!0,tu),tl=dr(g,to),th=0;th<tl.values.length;th++)tl.values[th]=tc.nextValue();return tl.toTensor()}}),nU=An({unstack_:function(g,te){void 0===te&&(te=0),te=te||0;var tr=mn(g,"x","unstack");C(te>=-tr.shape.length&&te<tr.shape.length,function(){return"Axis = "+te+" is not in [-"+tr.shape.length+", "+tr.shape.length+")"}),te<0&&(te+=tr.shape.length);var to={axis:te};return tB.runKernelFunc(function(g){return g.unstack(tr,te)},{x:tr},function(g){return{x:function(){return nL(g,te)}}},"Unpack",to)}});function zr(g,te,tr,to){void 0===to&&(to=!0);var tu=[];if(to)(tu=tu.concat(te.slice(0))).push(g[0]/tr),tu=tu.concat(g.slice(1));else{tu=tu.concat(g[0]);for(var tc=te.length,tl=0;tl<tc;++tl)tu=tu.concat([g[tl+1]/te[tl],te[tl]]);tu=tu.concat(g.slice(tc+1))}return tu}function Gr(g,te,tr){void 0===tr&&(tr=!0);var to=[];if(tr){to.push(te);for(var tu=te+1;tu<g;++tu)tu<=2*te?(to.push(tu),to.push(tu-(te+1))):to.push(tu)}else{var tc=[],tl=[];for(tu=1;tu<g;++tu)tu>=2*te+1||tu%2==1?tl.push(tu):tc.push(tu);to.push.apply(to,tc),to.push(0),to.push.apply(to,tl)}return to}function Hr(g,te,tr,to){void 0===to&&(to=!0);var tu=[];to?tu.push(g[0]/tr):tu.push(g[0]*tr);for(var tc=1;tc<g.length;++tc)tc<=te.length?to?tu.push(te[tc-1]*g[tc]):tu.push(g[tc]/te[tc-1]):tu.push(g[tc]);return tu}function qr(g,te){for(var tr=[0],to=0;to<te;++to)tr.push(g[to][0]);return tr}function Kr(g,te,tr){for(var to=g.slice(0,1),tu=0;tu<tr;++tu)to.push(g[tu+1]-te[tu][0]-te[tu][1]);return to}function jr(g,te){if(g.rank<1)throw Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was "+g.rank+".");if(te.rank<1)throw Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was "+te.rank+".");if("int32"!==te.dtype)throw Error("tf.gatherND() expects the indices to be int32 type, but the dtype was "+te.dtype+".");if(te.shape[te.rank-1]>g.rank)throw Error("index innermost dimension length must be <= tensor rank; saw: "+te.shape[te.rank-1]+" vs. "+g.rank);if(0===g.size)throw Error("Requested more than 0 entries, but input is empty. Input shape: "+g.shape+".");for(var tr=te.shape,to=tr[tr.length-1],tu=1,tc=0;tc<tr.length-1;++tc)tu*=tr[tc];var tl=g.shape,th=tr.slice();th.pop();var td=1;for(tc=to;tc<g.rank;++tc)td*=tl[tc],th.push(tl[tc]);var tf=$(g.shape).map(function(g){return g/td}).concat([1]).slice(0,to);return[th,tu,td,tf]}function $r(g){return g<=30?g:Y(g,Math.floor(Math.sqrt(g)))}function Qr(g,te,tr){var to=te.rank>1?te.shape[te.rank-1]:1,tu=te.rank>1?te.rank-1:1,tc="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+tr.shape+", indices.shape: "+te.shape+", shape: "+g+", sliceDim: "+to+", and batchDim: "+tu+".";if(tr.rank<tu)throw Error(tc+" update.rank < "+tu+". ");if(g.length<to+(tr.rank-tu))throw Error(tc+" Output shape length < "+(to+(tr.rank-tu)));if(tr.rank!==tu+g.length-to)throw Error(tc+" update.rank != "+(tu+g.length-to));for(var tl=0;tl<tu;++tl)if(tr.shape[tl]!==te.shape[tl])throw Error(tc+" updates.shape["+tl+"] ("+tr.shape[tl]+") != indices.shape["+tl+"] ("+te.shape[tl]+").");for(tl=0;tl<tr.rank-tu;++tl)if(tr.shape[tl+tu]!==g[tl+to])throw Error(tc+" updates.shape["+(tl+tu)+"] ("+tr.shape[tl+tu]+") != shape["+(tl+tu)+"] ("+g[tl+tu]+")")}function Jr(g,te,tr){if(te.rank<1)throw Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was "+te.rank+".");if(g.rank<1)throw Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was "+g.rank+".");if("int32"!==te.dtype)throw Error("The dtype of 'indices' should be int32, but got dtype: "+te.dtype);if(tr.length<1)throw Error("Output rank must be greater or equal to 1, but got shape: "+tr);if(0===tr.length){if(0===te.size)throw Error("Indices specified for empty output. indices shape: "+te.shape);if(0===g.size)throw Error("Updates specified for empty output. updates shape: "+g.shape)}Qr(tr,te,g)}function Zr(g,te,tr){for(var to=te.shape.length,tu=to>1?te.shape[to-1]:1,tc=tr.length,tl=1,th=tu;th<tc;++th)tl*=tr[th];var td=tu<1?1:tu;return{sliceRank:tu,numUpdates:k(te.shape)/td,sliceSize:tl,strides:$(tr.slice(0,tu)).concat([1]),outputSize:k(tr)}}function eo(g,te,tr){C(g.rank===te.length,function(){return"Error in slice"+g.rank+"D: Length of begin "+te+" must match the rank of the array ("+g.rank+")."}),C(g.rank===tr.length,function(){return"Error in slice"+g.rank+"D: Length of size "+tr+" must match the rank of the array ("+g.rank+")."});for(var r=function(to){C(te[to]+tr[to]<=g.shape[to],function(){return"Error in slice"+g.rank+"D: begin["+to+"] + size["+to+"] ("+(te[to]+tr[to])+") would overflow input.shape["+to+"] ("+g.shape[to]+")"})},to=0;to<g.rank;++to)r(to)}function no(g){for(var te=[],tr=0;g>0;)1&g&&te.push(tr),g/=2,tr++;return te}function ro(g,te,tr){for(var to=[],tu=0;tu<g.length;tu++)to[tu]=Math.ceil((te[tu]-g[tu])/tr[tu]);return to}function oo(g,te,tr,to,tu){var tc=te[tu],tl=tr[tu]||1;(g&1<<tu||null==tc)&&(tc=tl>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);var th=to[tu];return tc<0&&(tc+=th),tc=x(0,tc,th-1)}function ao(g,te,tr,to,tu){var tc=te[tu],tl=tr[tu]||1;(g&1<<tu||null==tc)&&(tc=tl>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);var th=to[tu];return tc<0&&(tc+=th),tc=tl>0?x(0,tc,th):x(-1,tc,th-1)}function io(g,te,tr){for(var to=tr.length,tu=0;tu<tr.length;tu++)if(tr[tu]>1){to=tu;break}for(tu=to+1;tu<tr.length;tu++)if(te[tu]>0||tr[tu]!==g[tu])return!1;return!0}function so(g,te){for(var tr=g.length>0?g[g.length-1]:1,to=0;to<g.length-1;to++)tr+=g[to]*te[to];return tr}function po(g,te){C(X(g),function(){return"The f passed in variableGrads(f) must be a function"}),C(null==te||Array.isArray(te)&&te.every(function(g){return g instanceof tk}),function(){return"The varList passed in variableGrads(f, varList) must be an array of variables"});var tr=null!=te;if(!tr)for(var to in te=[],tB.registeredVariables)te.push(tB.registeredVariables[to]);var tu=tr?te.filter(function(g){return!g.trainable}):null,tc=te.length;C((te=te.filter(function(g){return g.trainable})).length>0,function(){return"variableGrads() expects at least one of the input variables to be trainable, but none of the "+tc+" variables is trainable."});var tl=tB.gradients(g,te,null,!0),th=tl.value,td=tl.grads;C(td.some(function(g){return null!=g}),function(){return"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."}),C(0===th.rank,function(){return"The f passed in variableGrads(f) must return a scalar, but it returned a rank-"+th.rank+" tensor"});var tf={};return te.forEach(function(g,te){null!=td[te]&&(tf[g.name]=td[te])}),null!=tu&&tu.forEach(function(g){return tf[g.name]=null}),{value:th,grads:tf}}function vo(g){return tB.customGrad(g)}Object.freeze({prepareAndValidate:jr}),Object.freeze({validateUpdateShape:Qr,validateInput:Jr,calculateShapes:Zr}),Object.freeze({assertParamsValid:eo,maskToAxes:no,computeOutShape:ro,startForAxis:oo,stopForAxis:ao,isSliceContinous:io,computeFlatOffset:so});var nz=An({softmax_:function(g,te){void 0===te&&(te=-1);var tr=mn(g,"logits","softmax","float32");if(-1===te&&(te=tr.rank-1),te!==tr.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank "+tr.rank+" and dim was "+te);return tB.runKernelFunc(function(g,to){var tu=g.softmax(tr,te);return to([tu]),tu},{logits:tr},function(g,tr){var to=tr[0],tu=g.mul(to);return{logits:function(){return tu.sub(tu.sum([te],!0).mul(to))}}},"Softmax",{dim:te},[],[!0])}}),nH=An({logSoftmax_:function(g,te){void 0===te&&(te=-1);var tr=mn(g,"logits","logSoftmax");if(-1===te&&(te=tr.rank-1),te!==tr.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank "+tr.rank+" and axis was "+te);return vo(function(g,tr){var to=g.max(te,!0),tu=g.sub(to),tc=tu.toFloat().sub(tu.exp().sum(te,!0).log());return tr([tc]),{value:tc,gradFunc:function(g,tr){var to=tr[0].exp();return g.sub(g.sum(te,!0).mul(to))}}})(tr)}}),nG=function(){function t(g,te){this.backend=g,this.dataMover=te,this.data=new WeakMap,this.dataIdsCount=0}return t.prototype.get=function(g){return this.data.has(g)||this.dataMover.moveData(this.backend,g),this.data.get(g)},t.prototype.set=function(g,te){this.dataIdsCount++,this.data.set(g,te)},t.prototype.has=function(g){return this.data.has(g)},t.prototype.delete=function(g){return this.dataIdsCount--,this.data.delete(g)},t.prototype.numDataIds=function(){return this.dataIdsCount},t}(),nq=function(){function t(){}return t.prototype.time=function(g){return wo("time")},t.prototype.read=function(g){return wo("read")},t.prototype.readSync=function(g){return wo("readSync")},t.prototype.numDataIds=function(){return wo("numDataIds")},t.prototype.disposeData=function(g){return wo("disposeData")},t.prototype.write=function(g,te,tr){return wo("write")},t.prototype.move=function(g,te,tr,to){return wo("move")},t.prototype.memory=function(){return wo("memory")},t.prototype.floatPrecision=function(){return wo("floatPrecision")},t.prototype.epsilon=function(){return 32===this.floatPrecision()?1e-7:1e-4},t.prototype.batchMatMul=function(g,te,tr,to){return wo("batchMatMul")},t.prototype.fusedBatchMatMul=function(g){return g.a,g.b,g.transposeA,g.transposeB,g.bias,g.activation,g.preluActivationWeights,wo("fusedBatchMatMul")},t.prototype.slice=function(g,te,tr){return wo("slice")},t.prototype.stridedSlice=function(g,te,tr,to){return wo("stridedSlice")},t.prototype.unstack=function(g,te){return wo("unstack")},t.prototype.reverse=function(g,te){return wo("reverse")},t.prototype.concat=function(g,te){return wo("concat")},t.prototype.neg=function(g){return wo("neg")},t.prototype.add=function(g,te){return wo("add")},t.prototype.addN=function(g){return wo("addN")},t.prototype.subtract=function(g,te){return wo("subtract")},t.prototype.multiply=function(g,te){return wo("multiply")},t.prototype.realDivide=function(g,te){return wo("realDivide")},t.prototype.floorDiv=function(g,te){return wo("floorDiv")},t.prototype.sum=function(g,te){return wo("sum")},t.prototype.prod=function(g,te){return wo("prod")},t.prototype.unsortedSegmentSum=function(g,te,tr){return wo("unsortedSegmentSum")},t.prototype.argMin=function(g,te){return wo("argMin")},t.prototype.argMax=function(g,te){return wo("argMax")},t.prototype.equal=function(g,te){return wo("equal")},t.prototype.notEqual=function(g,te){return wo("notEqual")},t.prototype.less=function(g,te){return wo("less")},t.prototype.lessEqual=function(g,te){return wo("lessEqual")},t.prototype.greater=function(g,te){return wo("greater")},t.prototype.greaterEqual=function(g,te){return wo("greaterEqual")},t.prototype.logicalNot=function(g){return wo("logicalNot")},t.prototype.logicalAnd=function(g,te){return wo("logicalAnd")},t.prototype.logicalOr=function(g,te){return wo("logicalOr")},t.prototype.where=function(g){return wo("where")},t.prototype.select=function(g,te,tr){return wo("select")},t.prototype.topk=function(g,te,tr){return wo("topk")},t.prototype.min=function(g,te){return wo("min")},t.prototype.minimum=function(g,te){return wo("minimum")},t.prototype.mod=function(g,te){return wo("mod")},t.prototype.max=function(g,te){return wo("max")},t.prototype.maximum=function(g,te){return wo("maximum")},t.prototype.all=function(g,te){return wo("all")},t.prototype.any=function(g,te){return wo("any")},t.prototype.squaredDifference=function(g,te){return wo("squaredDifference")},t.prototype.ceil=function(g){return wo("ceil")},t.prototype.floor=function(g){return wo("floor")},t.prototype.round=function(g){return wo("round")},t.prototype.sign=function(g){return wo("sign")},t.prototype.isNaN=function(g){return wo("isNaN")},t.prototype.isInf=function(g){return wo("isInf")},t.prototype.isFinite=function(g){return wo("isFinite")},t.prototype.pow=function(g,te){return wo("pow")},t.prototype.exp=function(g){return wo("exp")},t.prototype.expm1=function(g){return wo("expm1")},t.prototype.softmax=function(g,te){return wo("softmax")},t.prototype.log=function(g){return wo("log")},t.prototype.log1p=function(g){return wo("log1p")},t.prototype.sqrt=function(g){return wo("sqrt")},t.prototype.rsqrt=function(g){return wo("rsqrt")},t.prototype.square=function(g){return wo("square")},t.prototype.reciprocal=function(g){return wo("reciprocal")},t.prototype.relu=function(g){return wo("relu")},t.prototype.relu6=function(g){return wo("relu6")},t.prototype.prelu=function(g,te){return wo("prelu")},t.prototype.elu=function(g){return wo("elu")},t.prototype.eluDer=function(g,te){return wo("eluDer")},t.prototype.selu=function(g){return wo("selu")},t.prototype.int=function(g){return wo("int")},t.prototype.clip=function(g,te,tr){return wo("clip")},t.prototype.abs=function(g){return wo("abs")},t.prototype.complexAbs=function(g){return wo("complexAbs")},t.prototype.sigmoid=function(g){return wo("sigmoid")},t.prototype.softplus=function(g){return wo("softplus")},t.prototype.sin=function(g){return wo("sin")},t.prototype.cos=function(g){return wo("cos")},t.prototype.tan=function(g){return wo("tan")},t.prototype.asin=function(g){return wo("asin")},t.prototype.acos=function(g){return wo("acos")},t.prototype.atan=function(g){return wo("atan")},t.prototype.atan2=function(g,te){return wo("atan2")},t.prototype.sinh=function(g){return wo("sinh")},t.prototype.cosh=function(g){return wo("cosh")},t.prototype.tanh=function(g){return wo("tanh")},t.prototype.asinh=function(g){return wo("asinh")},t.prototype.acosh=function(g){return wo("acosh")},t.prototype.atanh=function(g){return wo("atanh")},t.prototype.erf=function(g){return wo("erf")},t.prototype.step=function(g,te){return wo("step")},t.prototype.fusedConv2d=function(g){return g.input,g.filter,g.convInfo,g.bias,g.activation,g.preluActivationWeights,wo("fusedConv2d")},t.prototype.conv2d=function(g,te,tr){return wo("conv2d")},t.prototype.conv2dDerInput=function(g,te,tr){return wo("conv2dDerInput")},t.prototype.conv2dDerFilter=function(g,te,tr){return wo("conv2dDerFilter")},t.prototype.fusedDepthwiseConv2D=function(g){return g.input,g.filter,g.convInfo,g.bias,g.activation,g.preluActivationWeights,wo("fusedDepthwiseConv2D")},t.prototype.depthwiseConv2D=function(g,te,tr){return wo("depthwiseConv2D")},t.prototype.depthwiseConv2DDerInput=function(g,te,tr){return wo("depthwiseConv2DDerInput")},t.prototype.depthwiseConv2DDerFilter=function(g,te,tr){return wo("depthwiseConv2DDerFilter")},t.prototype.conv3d=function(g,te,tr){return wo("conv3d")},t.prototype.conv3dDerInput=function(g,te,tr){return wo("conv3dDerInput")},t.prototype.conv3dDerFilter=function(g,te,tr){return wo("conv3dDerFilter")},t.prototype.maxPool=function(g,te){return wo("maxPool")},t.prototype.maxPoolBackprop=function(g,te,tr,to){return wo("maxPoolBackprop")},t.prototype.avgPool=function(g,te){return wo("avgPool")},t.prototype.avgPoolBackprop=function(g,te,tr){return wo("avgPoolBackprop")},t.prototype.avgPool3d=function(g,te){return wo("avgPool3d")},t.prototype.avgPool3dBackprop=function(g,te,tr){return wo("avgPool3dBackprop")},t.prototype.maxPool3d=function(g,te){return wo("maxPool3d")},t.prototype.maxPool3dBackprop=function(g,te,tr,to){return wo("maxPool3dBackprop")},t.prototype.reshape=function(g,te){return wo("reshape")},t.prototype.cast=function(g,te){return wo("cast")},t.prototype.tile=function(g,te){return wo("tile")},t.prototype.pad=function(g,te,tr){return wo("pad")},t.prototype.transpose=function(g,te){return wo("transpose")},t.prototype.gather=function(g,te,tr){return wo("gather")},t.prototype.gatherND=function(g,te){return wo("gatherND")},t.prototype.scatterND=function(g,te,tr){return wo("scatterND")},t.prototype.batchToSpaceND=function(g,te,tr){return wo("batchToSpaceND")},t.prototype.spaceToBatchND=function(g,te,tr){return wo("spaceToBatchND")},t.prototype.resizeBilinear=function(g,te,tr,to){return wo("resizeBilinear")},t.prototype.resizeBilinearBackprop=function(g,te,tr){return wo("resizeBilinearBackprop")},t.prototype.resizeNearestNeighbor=function(g,te,tr,to){return wo("resizeNearestNeighbor")},t.prototype.resizeNearestNeighborBackprop=function(g,te,tr){return wo("resizeNearestNeighborBackprop")},t.prototype.batchNormalization=function(g,te,tr,to,tu,tc){return wo("batchNormalization")},t.prototype.localResponseNormalization4D=function(g,te,tr,to,tu){return wo("localResponseNormalization4D")},t.prototype.LRNGrad=function(g,te,tr,to,tu,tc,tl){return wo("LRNGrad")},t.prototype.multinomial=function(g,te,tr,to){return wo("multinomial")},t.prototype.oneHot=function(g,te,tr,to){return wo("oneHot")},t.prototype.cumsum=function(g,te,tr,to){return wo("cumsum")},t.prototype.nonMaxSuppression=function(g,te,tr,to,tu){return wo("nonMaxSuppression")},t.prototype.fft=function(g){return wo("fft")},t.prototype.ifft=function(g){return wo("ifft")},t.prototype.complex=function(g,te){return wo("complex")},t.prototype.real=function(g){return wo("real")},t.prototype.imag=function(g){return wo("imag")},t.prototype.cropAndResize=function(g,te,tr,to,tu,tc){return wo("cropAndResize")},t.prototype.depthToSpace=function(g,te,tr){return wo("depthToSpace")},t.prototype.split=function(g,te,tr){return wo("split")},t.prototype.sparseToDense=function(g,te,tr,to){return wo("sparseToDense")},t.prototype.diag=function(g){return wo("diag")},t.prototype.fill=function(g,te,tr){return wo("fill")},t.prototype.onesLike=function(g){return wo("onesLike")},t.prototype.zerosLike=function(g){return wo("zerosLike")},t.prototype.linspace=function(g,te,tr){return wo("linspace")},t.prototype.dispose=function(){return wo("dispose")},t}();function wo(g){throw Error("'"+g+"' not yet implemented or not found in the registry. Did you forget to import the kernel?")}function Co(g,te){for(var tr=g.length,to=[],tu=0;tu<tr;tu++){var tc=tr-1-tu,tl=g[tc]||1;(te[te.length-1-tu]||1)>1&&1===tl&&to.unshift(tc)}return to}function Eo(g,te){for(var tr=[],to=0;to<te.length;to++){var tu=g[g.length-to-1],tc=te.length-to-1,tl=te[tc];(null==tu||1===tu&&tl>1)&&tr.unshift(tc)}return tr}function Ro(g,te){for(var tr=[],to=Math.max(g.length,te.length),tu=0;tu<to;tu++){var tc=g[g.length-tu-1];null==tc&&(tc=1);var tl=te[te.length-tu-1];if(null==tl&&(tl=1),1===tc)tr.unshift(tl);else if(1===tl)tr.unshift(tc);else{if(tc!==tl)throw Error("Operands could not be broadcast together with shapes "+g+" and "+te+".");tr.unshift(tc)}}return tr}function Io(g,te,tr,to,tu,tc,tl){void 0===tl&&(tl="channelsLast");var th,td=To(te),tf=td[0],tp=td[1];if("channelsLast"===tl)th=[tf,tp,g[3],g[3]];else{if("channelsFirst"!==tl)throw Error("Unknown dataFormat "+tl);th=[tf,tp,g[1],g[1]]}return So(g,th,tr,to,tu,tc,!1,tl)}function ko(g,te,tr,to,tu,tc,tl){void 0===tl&&(tl="NDHWC");var th,td,tf=No(te),tp=tf[0],tv=tf[1],tm=tf[2];if("NDHWC"===tl)td="channelsLast",th=[tp,tv,tm,g[4],g[4]];else{if("NCDHW"!==tl)throw Error("Unknown dataFormat "+tl);td="channelsFirst",th=[tp,tv,tm,g[1],g[1]]}return Ao(g,th,tr,to,tu,!1,td,tc)}function So(g,te,tr,to,tu,tc,tl,th){void 0===tl&&(tl=!1),void 0===th&&(th="channelsLast");var td=-1,tf=-1,tp=-1,tv=-1;if("channelsLast"===th)td=g[0],tf=g[1],tp=g[2],tv=g[3];else{if("channelsFirst"!==th)throw Error("Unknown dataFormat "+th);td=g[0],tv=g[1],tf=g[2],tp=g[3]}var tm,tg=te[0],ty=te[1],tx=te[3],tb=To(tr),tC=tb[0],tw=tb[1],tE=To(to),tR=tE[0],tI=tE[1],tk=Fo(tg,tR),tA=Fo(ty,tI),tS=function(g,te,tr,to,tu,tc,tl,th){var td,tf,tp;if("number"==typeof g){td={top:g,bottom:g,left:g,right:g,type:0===g?"VALID":"NUMBER"};var tv,tm,tg,ty,tx,tb,tC=(tv=[te,tr],null==(tm=g)&&(tm=Do(tv,tc,to)),tg=tv[0],ty=tv[1],C(A(tx=_o((tg-tc+2*tm)/to+1,th)),function(){return"The output # of rows ("+tx+") must be an integer. Change the stride and/or zero pad parameters"}),C(A(tb=_o((ty-tc+2*tm)/to+1,th)),function(){return"The output # of columns ("+tb+") must be an integer. Change the stride and/or zero pad parameters"}),[tx,tb]);tf=tC[0],tp=tC[1]}else if("same"===g){tf=Math.ceil(te/to),tp=Math.ceil(tr/tu);var tw=Math.max(0,(tf-1)*to+tc-te),tE=Math.max(0,(tp-1)*tu+tl-tr),tR=Math.floor(tw/2),tI=Math.floor(tE/2);td={top:tR,bottom:tw-tR,left:tI,right:tE-tI,type:"SAME"}}else{if("valid"!==g)throw Error("Unknown padding parameter: "+g);td={top:0,bottom:0,left:0,right:0,type:"VALID"},tf=Math.ceil((te-tc+1)/to),tp=Math.ceil((tr-tl+1)/tu)}return{padInfo:td,outHeight:tf,outWidth:tp}}(tu,tf,tp,tC,tw,tk,tA,tc),tD=tS.padInfo,tN=tS.outHeight,tT=tS.outWidth,tF=tl?tx*tv:tx;return"channelsFirst"===th?tm=[td,tF,tN,tT]:"channelsLast"===th&&(tm=[td,tN,tT,tF]),{batchSize:td,dataFormat:th,inHeight:tf,inWidth:tp,inChannels:tv,outHeight:tN,outWidth:tT,outChannels:tF,padInfo:tD,strideHeight:tC,strideWidth:tw,filterHeight:tg,filterWidth:ty,effectiveFilterHeight:tk,effectiveFilterWidth:tA,dilationHeight:tR,dilationWidth:tI,inShape:g,outShape:tm,filterShape:te}}function Ao(g,te,tr,to,tu,tc,tl,th){void 0===tc&&(tc=!1),void 0===tl&&(tl="channelsLast");var td=-1,tf=-1,tp=-1,tv=-1,tm=-1;if("channelsLast"===tl)td=g[0],tf=g[1],tp=g[2],tv=g[3],tm=g[4];else{if("channelsFirst"!==tl)throw Error("Unknown dataFormat "+tl);td=g[0],tm=g[1],tf=g[2],tp=g[3],tv=g[4]}var tg,ty=te[0],tx=te[1],tb=te[2],tC=te[4],tw=No(tr),tE=tw[0],tR=tw[1],tI=tw[2],tk=No(to),tA=tk[0],tS=tk[1],tD=tk[2],tN=Fo(ty,tA),tT=Fo(tx,tS),tF=Fo(tb,tD),tO=function(g,te,tr,to,tu,tc,tl,th,td,tf,tp){var tv,tm,tg,ty;if("number"==typeof g){tv={top:g,bottom:g,left:g,right:g,front:g,back:g,type:0===g?"VALID":"NUMBER"};var tx,tb,tC,tw,tE,tR,tI,tk,tA=(tx=[te,tr,to,1],null==(tb=g)&&(tb=Do(tx,th,tu)),tC=tx[0],tw=tx[1],tE=tx[2],C(A(tR=_o((tC-th+2*tb)/tu+1,tp)),function(){return"The output # of depths ("+tR+") must be an integer. Change the stride and/or zero pad parameters"}),C(A(tI=_o((tw-th+2*tb)/tu+1,tp)),function(){return"The output # of rows ("+tI+") must be an integer. Change the stride and/or zero pad parameters"}),C(A(tk=_o((tE-th+2*tb)/tu+1,tp)),function(){return"The output # of columns ("+tk+") must be an integer. Change the stride and/or zero pad parameters"}),[tR,tI,tk,1]);tm=tA[0],tg=tA[1],ty=tA[2]}else if("same"===g){tm=Math.ceil(te/tu),tg=Math.ceil(tr/tc),ty=Math.ceil(to/tl);var tS=(tm-1)*tu+th-te,tD=(tg-1)*tc+td-tr,tN=(ty-1)*tl+tf-to,tT=Math.floor(tS/2),tF=Math.floor(tD/2),tO=Math.floor(tN/2);tv={top:tF,bottom:tD-tF,left:tO,right:tN-tO,front:tT,back:tS-tT,type:"SAME"}}else{if("valid"!==g)throw Error("Unknown padding parameter: "+g);tv={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},tm=Math.ceil((te-th+1)/tu),tg=Math.ceil((tr-td+1)/tc),ty=Math.ceil((to-tf+1)/tl)}return{padInfo:tv,outDepth:tm,outHeight:tg,outWidth:ty}}(tu,tf,tp,tv,tE,tR,tI,tN,tT,tF,th),t_=tO.padInfo,tM=tO.outDepth,tB=tO.outHeight,tP=tO.outWidth,tL=tc?tC*tm:tC;return"channelsFirst"===tl?tg=[td,tL,tM,tB,tP]:"channelsLast"===tl&&(tg=[td,tM,tB,tP,tL]),{batchSize:td,dataFormat:tl,inDepth:tf,inHeight:tp,inWidth:tv,inChannels:tm,outDepth:tM,outHeight:tB,outWidth:tP,outChannels:tL,padInfo:t_,strideDepth:tE,strideHeight:tR,strideWidth:tI,filterDepth:ty,filterHeight:tx,filterWidth:tb,effectiveFilterDepth:tN,effectiveFilterHeight:tT,effectiveFilterWidth:tF,dilationDepth:tA,dilationHeight:tS,dilationWidth:tD,inShape:g,outShape:tg,filterShape:te}}function Do(g,te,tr,to){void 0===to&&(to=1);var tu=Fo(te,to);return Math.floor((g[0]*(tr-1)-tr+tu)/2)}function To(g){return"number"==typeof g?[g,g,g]:2===g.length?[g[0],g[1],1]:g}function No(g){return"number"==typeof g?[g,g,g]:g}function Fo(g,te){return te<=1?g:g+(g-1)*(te-1)}function _o(g,te){if(!te)return g;switch(te){case"round":return Math.round(g);case"ceil":return Math.ceil(g);case"floor":return Math.floor(g);default:throw Error("Unknown roundingMode "+te)}}function Oo(g){var te=To(g),tr=te[0],to=te[1],tu=te[2];return 1===tr&&1===to&&1===tu}function Mo(g,te){return Oo(g)||Oo(te)}function Bo(g){if("NHWC"===g)return"channelsLast";if("NCHW"===g)return"channelsFirst";throw Error("Unknown dataFormat "+g)}function Po(g,te,tr){if("complex64"===te){if("complex64"===g.dtype)return g.clone();var to=Gn(g.shape),tu=g.toFloat(),tc=tr.complex(tu,to);return to.dispose(),tu.dispose(),tc}if(!U(g.dtype,te))return tB.makeTensorFromDataId(g.dataId,g.shape,te);if("complex64"===g.dtype){var tl=tr.real(g);return tc=tl.cast(te),tl.dispose(),tc}if("int32"===te)return tr.int(g);if("bool"===te){var th=On(0,g.dtype);return tc=tr.notEqual(g,th),th.dispose(),tc}throw Error("Error in Cast: failed to cast "+g.dtype+" to "+te)}function Lo(g,te){return tB.makeTensorFromDataId(g.dataId,te,g.dtype)}function Wo(g,te,tr){var to=(te-g)/(tr-1),tu=tt(tr,"float32");tu[0]=g;for(var tc=1;tc<tu.length;tc++)tu[tc]=tu[tc-1]+to;return Mn(tu,"float32")}function Vo(g,te){if(g.length!==te.length)throw Error("Cannot merge real and imag arrays of different lengths. real:"+g.length+", imag: "+te.length+".");for(var tr=new Float32Array(2*g.length),to=0;to<tr.length;to+=2)tr[to]=g[to/2],tr[to+1]=te[to/2];return tr}function zo(g,te){return{real:g[2*te],imag:g[2*te+1]}}function Go(g,te,tr,to){g[2*to]=te,g[2*to+1]=tr}function Ho(g,te,tr){var to=(tr?2:-2)*Math.PI*(g/te);return{real:Math.cos(to),imag:Math.sin(to)}}function qo(g,te,tr){var to=function(g,te,tr){for(var to=0,tu=g.length,tc=0,tl=!1;to<tu;){var th=tr(te,g[tc=to+(tu-to>>>1)]);th>0?to=tc+1:(tu=tc,tl=!th)}return tl?to:-to-1}(g,te,tr||Ko),tu=to<0?-(to+1):to;g.splice(tu,0,te)}function Ko(g,te){return g>te?1:g<te?-1:0}function jo(g,te,tr,to,tu){return Yo(g,te,tr,to,tu,0).selectedIndices}function Xo(g,te,tr,to,tu,tc){var tl=Yo(g,te,tr,to,tu,tc,!0);return tl.numValidOutputs.dispose(),{selectedIndices:tl.selectedIndices,selectedScores:tl.selectedScores}}function Yo(g,te,tr,to,tu,tc,tl,th){void 0===tl&&(tl=!1),void 0===th&&(th=!1);for(var td=Array.from(te).map(function(g,te){return{score:g,boxIndex:te,suppressBeginIndex:0}}).filter(function(g){return g.score>tu}).sort(Jo),tf=tc>0?-.5/tc:0,tp=[],tv=[];tp.length<tr&&td.length>0;){var tm=td.pop(),tg=tm.score,ty=tm.boxIndex,tx=tm.suppressBeginIndex;if(tg<tu)break;for(var tb=!1,tC=tp.length-1;tC>=tx;--tC){var tw=$o(g,ty,tp[tC]);if(tw>=to){tb=!0;break}if(tm.score=tm.score*Qo(to,tf,tw),tm.score<=tu)break}tm.suppressBeginIndex=tp.length,tb||(tm.score===tg?(tp.push(ty),tv.push(tm.score)):tm.score>tu&&qo(td,tm,Jo))}var tE=tp.length;return th&&(tp.fill(0,tE),tv.fill(0,tE)),{selectedIndices:Mn(tp,"int32"),selectedScores:Mn(tv,"float32"),numValidOutputs:On(tE,"int32")}}function $o(g,te,tr){var to=g.subarray(4*te,4*te+4),tu=g.subarray(4*tr,4*tr+4),tc=Math.min(to[0],to[2]),tl=Math.min(to[1],to[3]),th=Math.max(to[0],to[2]),td=Math.max(to[1],to[3]),tf=Math.min(tu[0],tu[2]),tp=Math.min(tu[1],tu[3]),tv=Math.max(tu[0],tu[2]),tm=Math.max(tu[1],tu[3]),tg=(th-tc)*(td-tl),ty=(tv-tf)*(tm-tp);if(tg<=0||ty<=0)return 0;var tx=Math.max(Math.min(th,tv)-Math.max(tc,tf),0)*Math.max(Math.min(td,tm)-Math.max(tl,tp),0);return tx/(tg+ty-tx)}function Qo(g,te,tr){var to=Math.exp(te*tr*tr);return tr<=g?to:0}function Jo(g,te){return g.score-te.score||g.score===te.score&&te.boxIndex-g.boxIndex}function Zo(g,te,tr){var to=Array(g.rank).fill(0),tu=g.shape.slice();return te.map(function(te){tu[tr]=te;var tc=g.slice(to,tu);return to[tr]+=te,tc})}function ta(g,te){for(var tr=Array(g.rank),to=0;to<tr.length;to++)tr[to]=g.shape[to]*te[to];var tu=dr(tr,g.dtype);for(to=0;to<tu.values.length;++to){for(var tc=tu.indexToLoc(to),tl=Array(g.rank),th=0;th<tl.length;th++)tl[th]=tc[th]%g.shape[th];var td=g.locToIndex(tl);tu.values[to]=g.values[td]}return tu.toTensor()}function ea(g,te,tr,to,tu){for(var tc=te[te.length-1],tl=[g.length/tc,tc],th=tl[0],td=tl[1],tf=B(tr,th*to),tp=B("int32",th*to),tv=0;tv<th;tv++){for(var tm=tv*td,tg=g.subarray(tm,tm+td),ty=[],tx=0;tx<tg.length;tx++)ty.push({value:tg[tx],index:tx});ty.sort(function(g,te){return te.value-g.value});var tb=tv*to,tC=tf.subarray(tb,tb+to),tw=tp.subarray(tb,tb+to);for(tx=0;tx<to;tx++)tC[tx]=ty[tx].value,tw[tx]=ty[tx].index}var tE=te.slice();return tE[tE.length-1]=to,[Fn(tf,tE,tr),Fn(tp,tE,"int32")]}function na(g,te){for(var tr=[],to=0;to<te.length;to++)te[to]&&tr.push(to);var tu=dr(g,"int32"),tc=dr([tr.length,g.length],"int32");for(to=0;to<tr.length;to++){var tl=tu.indexToLoc(tr[to]),th=to*g.length;tc.values.set(tl,th)}return tc.toTensor()}Object.freeze({castTensor:Po,reshapeTensor:Lo,linspaceImpl:Wo,upcastType:Dt,axesAreInnerMostDims:yn,combineLocations:xn,computeOutAndReduceShapes:bn,expandShapeToKeepDim:wn,assertAxesAreInnerMostDims:Cn,getAxesPermutation:En,getUndoAxesPermutation:Rn,getInnerMostAxes:In,getBroadcastDims:Co,getReductionAxes:Eo,assertAndGetBroadcastShape:Ro,assertParamsConsistent:kn,computeOutShape:Sn,computePool2DInfo:Io,computePool3DInfo:ko,computeConv2DInfo:So,computeConv3DInfo:Ao,computeDefaultPad:Do,tupleValuesAreOne:Oo,eitherStridesOrDilationsAreOne:Mo,convertConv2DDataFormat:Bo,PARALLELIZE_THRESHOLD:30,computeOptimalWindowSize:$r});var ra=function(g,te){this.outputShape=[],this.outputShape=g,this.variableNames=te.map(function(g,te){return"T"+te});var tr=[];this.variableNames.forEach(function(g){tr.push("float v"+g+" = get"+g+"AtOutCoords();")});var to=this.variableNames.map(function(g){return"v"+g}).join(" + ");this.userCode="\n      void main() {\n        "+tr.join("\n        ")+"\n\n        float result = "+to+";\n        setOutput(result);\n      }\n    "},oa=function(g,te){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=g,this.variableNames=te.map(function(g,te){return"T"+te});var tr=[];this.variableNames.forEach(function(g){tr.push("vec4 v"+g+" = get"+g+"AtOutCoords();")});var to=this.variableNames.map(function(g){return"v"+g}).join(" + ");this.userCode="\n      void main() {\n        "+tr.join("\n        ")+"\n\n        vec4 result = "+to+";\n        setOutput(result);\n      }\n    "},aa=function(g,te,tr){this.variableNames=["A"];var to=g.windowSize,tu=g.batchSize,tc=Math.ceil(g.inSize/to);tr||this.variableNames.push("bestIndicesA"),this.outputShape=[tu,tc],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+to+";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < "+to+"; i++) {\n          int inIdx = "+(tr?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));")+";\n          float candidate = getA(batch, inIdx);\n          if (candidate "+("max"===te?">":"<")+" bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    "};function ia(g,te){return["x","y","z","w","u","v"].slice(0,te).map(function(te){return g+"."+te})}function sa(g,te){return 1===te?[g]:ia(g,te)}function ua(){var g,te,tr,to,tu,tc,tl,td,tf,tp;return 2===th.getNumber("WEBGL_VERSION")?(g="#version 300 es",te="in",tr="out",to="in",tu="texture",tc="outputColor",tl="out vec4 outputColor;",td="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",tf="",tp="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(g="",te="attribute",tr="varying",to="varying",tu="texture2D",tc="gl_FragColor",tl="",td="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",tf="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",tp="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:g,attribute:te,varyingVs:tr,varyingFs:to,texture2D:tu,output:tc,defineOutput:tl,defineSpecialNaN:td,defineSpecialInf:tf,defineRound:tp}}function ca(g,te,tr){void 0===tr&&(tr="index");var to=$(te);return to.map(function(te,tu){return"int "+g[tu]+" = "+tr+" / "+te+"; "+(tu===to.length-1?"int "+g[tu+1]+" = "+tr+" - "+g[tu]+" * "+te:"index -= "+g[tu]+" * "+te)+";"}).join("")}function la(g){var te=$(g).map(function(g){return g.toString()});return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * "+te[0]+" + coords.y * "+te[1]+" + coords.z;\n  }\n"}var nK="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";function fa(g,te,tr,to){var tu=[];g.forEach(function(g){var te=k(g.shapeInfo.logicalShape);g.shapeInfo.isUniform?tu.push("uniform float "+g.name+(te>1?"["+te+"]":"")+";"):(tu.push("uniform sampler2D "+g.name+";"),tu.push("uniform int offset"+g.name+";"))});var tc,tl,th=tu.join("\n"),td=g.map(function(g){var tr,tu,tc,tl;return void 0===(tr=to)&&(tr=!1),tu=""+(tr?pa(g):da(g)),tc=g.shapeInfo.logicalShape,tl=te.logicalShape,tc.length<=tl.length&&(tu+=tr?function(g,te){var tr,to=g.name,tu=to.charAt(0).toUpperCase()+to.slice(1),tc=g.shapeInfo.logicalShape.length,tl=te.logicalShape.length,th=Co(g.shapeInfo.logicalShape,te.logicalShape),td=wa(tl),tf=tl-tc,tp=["x","y","z","w","u","v"];tr=0===tc?"":tl<2&&th.length>=1?"coords = 0;":th.map(function(g){return"coords."+tp[g+tf]+" = 0;"}).join("\n");var tv="";tv=tl<2&&tc>0?"coords":g.shapeInfo.logicalShape.map(function(g,te){return"coords."+tp[te+tf]}).join(", ");var tm="return outputValue;",tg=1===k(g.shapeInfo.logicalShape),ty=1===k(te.logicalShape);if(1!==tc||tg||ty){if(tg&&!ty)tm=1===tl?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(th.length){var tx=tc-2,tb=tc-1;th.indexOf(tx)>-1&&th.indexOf(tb)>-1?tm="return vec4(outputValue.x);":th.indexOf(tx)>-1?tm="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":th.indexOf(tb)>-1&&(tm="return vec4(outputValue.xx, outputValue.zz);")}}else tm="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 get"+tu+"AtOutCoords() {\n      "+td+" coords = getOutputCoords();\n      "+tr+"\n      vec4 outputValue = get"+tu+"("+tv+");\n      "+tm+"\n    }\n  "}(g,te):function(g,te){var tr=g.name,to=tr.charAt(0).toUpperCase()+tr.slice(1),tu="get"+to+"AtOutCoords",tc=te.texShape,tl=g.shapeInfo.texShape,th=g.shapeInfo.logicalShape.length,td=te.logicalShape.length;if(!g.shapeInfo.isUniform&&th===td&&null==g.shapeInfo.flatOffset&&S(tl,tc))return"\n      float "+tu+"() {\n        return sampleTexture("+tr+", resultUV);\n      }\n    ";var tf,tp=wa(td),tv=Co(g.shapeInfo.logicalShape,te.logicalShape),tm=td-th,tg=["x","y","z","w","u","v"];return tf=0===th?"":td<2&&tv.length>=1?"coords = 0;":tv.map(function(g){return"coords."+tg[g+tm]+" = 0;"}).join("\n"),"\n    float "+tu+"() {\n      "+tp+" coords = getOutputCoords();\n      "+tf+"\n      return get"+to+"("+(td<2&&th>0?"coords":g.shapeInfo.logicalShape.map(function(g,te){return"coords."+tg[te+tm]}).join(", "))+");\n    }\n  "}(g,te)),tu}).join("\n"),tf=te.texShape,tp=ua(),tv="\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return "+tp.texture2D+"(textureSampler, uv).r;\n    }\n  ",tm=tp.version+"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    "+tp.varyingFs+" vec2 resultUV;\n    "+tp.defineOutput+"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    "+tp.defineSpecialNaN+"\n    "+tp.defineSpecialInf+"\n    "+tp.defineRound+"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    "+nj+"\n    "+nX+"\n    "+n$+"\n  ";return te.isPacked?(tc=function(g,te){var tr,to,tu,tc;switch(g.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return 1===(tc=[Math.ceil(te[0]/2),Math.ceil(te[1]/2)])[0]?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * "+tc[1]+".0);\n      }\n    ":1===tc[1]?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * "+tc[0]+".0);\n      }\n    ":"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+tc[0]+", "+tc[1]+"));\n      return 2 * (resTexRC.x * "+tc[1]+" + resTexRC.y);\n    }\n  ";case 2:return function(g,te){var tr=[Math.ceil(te[0]/2),Math.ceil(te[1]/2)];if(S(g,te))return"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2("+tr[0]+", "+tr[1]+"));\n      }\n    ";var to=Math.ceil(g[1]/2);return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+tr[0]+", "+tr[1]+"));\n\n      int index = resTexRC.x * "+tr[1]+" + resTexRC.y;\n      int r = 2 * (index / "+to+");\n      int c = imod(index, "+to+") * 2;\n\n      return ivec2(r, c);\n    }\n  "}(g,te);case 3:return tr=[Math.ceil(te[0]/2),Math.ceil(te[1]/2)],tu=(to=Math.ceil(g[2]/2))*Math.ceil(g[1]/2),"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+tr[0]+", "+tr[1]+"));\n      int index = resTexRC.x * "+tr[1]+" + resTexRC.y;\n\n      int b = index / "+tu+";\n      index -= b * "+tu+";\n\n      int r = 2 * (index / "+to+");\n      int c = imod(index, "+to+") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";default:return function(g,te){for(var tr=[Math.ceil(te[0]/2),Math.ceil(te[1]/2)],to=Math.ceil(g[g.length-1]/2),tu=to*Math.ceil(g[g.length-2]/2),tc=tu,tl="",th="b, r, c",td=2;td<g.length-1;td++)tc*=g[g.length-td-1],tl="\n      int b"+td+" = index / "+tc+";\n      index -= b"+td+" * "+tc+";\n    "+tl,th="b"+td+", "+th;return"\n    ivec"+g.length+" getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+tr[0]+", "+tr[1]+"));\n      int index = resTexRC.x * "+tr[1]+" + resTexRC.y;\n\n      "+tl+"\n\n      int b = index / "+tu+";\n      index -= b * "+tu+";\n\n      int r = 2 * (index / "+to+");\n      int c = imod(index, "+to+") * 2;\n\n      return ivec"+g.length+"("+th+");\n    }\n  "}(g,te)}}(te.logicalShape,tf),tl="\n    void setOutput(vec4 val) {\n      "+tp.output+" = val;\n    }\n  "):(tc=function(g,te){var tr,to,tu,tc;switch(g.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return 1===te[0]?"\n      int getOutputCoords() {\n        return int(resultUV.x * "+te[1]+".0);\n      }\n    ":1===te[1]?"\n      int getOutputCoords() {\n        return int(resultUV.y * "+te[0]+".0);\n      }\n    ":"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+te[0]+", "+te[1]+"));\n      return resTexRC.x * "+te[1]+" + resTexRC.y;\n    }\n  ";case 2:return S(g,te)?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2("+te[0]+", "+te[1]+"));\n      }\n    ":1===g[1]?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+te[0]+", "+te[1]+"));\n        int index = resTexRC.x * "+te[1]+" + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":1===g[0]?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+te[0]+", "+te[1]+"));\n        int index = resTexRC.x * "+te[1]+" + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+te[0]+", "+te[1]+"));\n      int index = resTexRC.x * "+te[1]+" + resTexRC.y;\n      int r = index / "+g[1]+";\n      int c = index - r * "+g[1]+";\n      return ivec2(r, c);\n    }\n  ";case 3:return tr=ca(["r","c","d"],g),"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+te[0]+", "+te[1]+"));\n      int index = resTexRC.x * "+te[1]+" + resTexRC.y;\n      "+tr+"\n      return ivec3(r, c, d);\n    }\n  ";case 4:return to=ca(["r","c","d","d2"],g),"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+te[0]+", "+te[1]+"));\n      int index = resTexRC.x * "+te[1]+" + resTexRC.y;\n      "+to+"\n      return ivec4(r, c, d, d2);\n    }\n  ";case 5:return tu=ca(["r","c","d","d2","d3"],g),"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2("+te[0]+",\n                             "+te[1]+"));\n\n      int index = resTexRC.x * "+te[1]+" + resTexRC.y;\n\n      "+tu+"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ";case 6:return tc=ca(["r","c","d","d2","d3","d4"],g),"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+te[0]+", "+te[1]+"));\n      int index = resTexRC.x * "+te[1]+" + resTexRC.y;\n\n      "+tc+"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ";default:throw Error(g.length+"-D output sampling is not yet supported")}}(te.logicalShape,tf),tl="\n    void setOutput(float val) {\n      "+tp.output+" = vec4(val, 0, 0, 0);\n    }\n  "),to&&(tm+=nY),[tm,tv,tl,th,tc,td,tr].join("\n")}function da(g){var te=g.shapeInfo.logicalShape;switch(te.length){case 0:return function(g){var te=g.name,tr="get"+te.charAt(0).toUpperCase()+te.slice(1);if(g.shapeInfo.isUniform)return"float "+tr+"() {return "+te+";}";var to=g.shapeInfo.texShape,tu=to[0],tc=to[1];if(1===tu&&1===tc)return"\n      float "+tr+"() {\n        return sampleTexture("+te+", halfCR);\n      }\n    ";var tl=g.shapeInfo.texShape;return"\n    float "+tr+"() {\n      vec2 uv = uvFromFlat("+tl[0]+", "+tl[1]+", "+xa(te)+");\n      return sampleTexture("+te+", uv);\n    }\n  "}(g);case 1:return function(g){var te=g.name,tr="get"+te.charAt(0).toUpperCase()+te.slice(1);if(g.shapeInfo.isUniform)return"\n      float "+tr+"(int index) {\n        "+ba(g)+"\n      }\n    ";var to=g.shapeInfo.texShape,tu=to[0],tc=to[1];if(1===tc&&1===tu)return"\n      float "+tr+"(int index) {\n        return sampleTexture("+te+", halfCR);\n      }\n    ";var tl=xa(te);return 1===tc?"\n      float "+tr+"(int index) {\n        vec2 uv = vec2(0.5, (float(index + "+tl+") + 0.5) / "+tu+".0);\n        return sampleTexture("+te+", uv);\n      }\n    ":1===tu?"\n      float "+tr+"(int index) {\n        vec2 uv = vec2((float(index + "+tl+") + 0.5) / "+tc+".0, 0.5);\n        return sampleTexture("+te+", uv);\n      }\n    ":"\n    float "+tr+"(int index) {\n      vec2 uv = uvFromFlat("+tu+", "+tc+", index + "+tl+");\n      return sampleTexture("+te+", uv);\n    }\n  "}(g);case 2:return function(g){var te=g.shapeInfo.logicalShape,tr=g.name,to="get"+tr.charAt(0).toUpperCase()+tr.slice(1),tu=g.shapeInfo.texShape;if(null!=tu&&S(te,tu)){var tc=tu[0];return"\n    float "+to+"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2("+tu[1]+".0, "+tc+".0);\n      return sampleTexture("+tr+", uv);\n    }\n  "}var tl=M(te),th=tl.newShape,td=tl.keptDims;if(th.length<te.length)return"\n      "+da(Ca(g,th))+"\n      float "+to+"(int row, int col) {\n        return "+to+"("+Ea(["row","col"],td)+");\n      }\n    ";if(g.shapeInfo.isUniform)return"\n      float "+to+"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2("+te[1]+", 1)));\n        "+ba(g)+"\n      }\n    ";var tf=tu[0],tp=tu[1],tv=xa(tr);return 1===tp?"\n    float "+to+"(int row, int col) {\n      float index = dot(vec3(row, col, "+tv+"), vec3("+te[1]+", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / "+tf+".0);\n      return sampleTexture("+tr+", uv);\n    }\n  ":1===tf?"\n    float "+to+"(int row, int col) {\n      float index = dot(vec3(row, col, "+tv+"), vec3("+te[1]+", 1, 1));\n      vec2 uv = vec2((index + 0.5) / "+tp+".0, 0.5);\n      return sampleTexture("+tr+", uv);\n    }\n  ":"\n  float "+to+"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * "+te[1]+" + col + "+tv+";\n    vec2 uv = uvFromFlat("+tf+", "+tp+", index);\n    return sampleTexture("+tr+", uv);\n  }\n"}(g);case 3:return function(g){var te=g.shapeInfo.logicalShape,tr=g.name,to="get"+tr.charAt(0).toUpperCase()+tr.slice(1),tu=te[1]*te[2],tc=te[2],tl=M(te),th=tl.newShape,td=tl.keptDims;if(th.length<te.length)return"\n        "+da(Ca(g,th))+"\n        float "+to+"(int row, int col, int depth) {\n          return "+to+"("+Ea(["row","col","depth"],td)+");\n        }\n      ";if(g.shapeInfo.isUniform)return"\n      float "+to+"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3("+tu+", "+tc+", 1)));\n        "+ba(g)+"\n      }\n    ";var tf=g.shapeInfo.texShape,tp=tf[0],tv=tf[1],tm=g.shapeInfo.flatOffset;return tv===tu&&null==tm?"\n        float "+to+"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2("+tc+", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2("+tv+".0, "+tp+".0);\n          return sampleTexture("+tr+", uv);\n        }\n      ":tv===tc&&null==tm?"\n    float "+to+"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2("+te[1]+", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+tv+".0, "+tp+".0);\n      return sampleTexture("+tr+", uv);\n    }\n  ":"\n      float "+to+"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * "+tu+" + col * "+tc+" + depth + "+xa(tr)+";\n        vec2 uv = uvFromFlat("+tp+", "+tv+", index);\n        return sampleTexture("+tr+", uv);\n      }\n  "}(g);case 4:return function(g){var te=g.shapeInfo.logicalShape,tr=g.name,to="get"+tr.charAt(0).toUpperCase()+tr.slice(1),tu=te[3],tc=te[2]*tu,tl=te[1]*tc,th=M(te),td=th.newShape,tf=th.keptDims;if(td.length<te.length)return"\n      "+da(Ca(g,td))+"\n      float "+to+"(int row, int col, int depth, int depth2) {\n        return "+to+"("+Ea(["row","col","depth","depth2"],tf)+");\n      }\n    ";if(g.shapeInfo.isUniform)return"\n      float "+to+"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4("+tl+", "+tc+", "+tu+", 1)));\n        "+ba(g)+"\n      }\n    ";var tp=g.shapeInfo.flatOffset,tv=g.shapeInfo.texShape,tm=tv[0],tg=tv[1];return tg===tl&&null==tp?"\n      float "+to+"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3("+tc+", "+tu+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+tg+".0, "+tm+".0);\n        return sampleTexture("+tr+", uv);\n      }\n    ":tg===tu&&null==tp?"\n      float "+to+"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3("+te[1]*te[2]+", "+te[2]+", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+tg+".0, "+tm+".0);\n        return sampleTexture("+tr+", uv);\n      }\n    ":"\n    float "+to+"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+tl+" + col * "+tc+" +\n          depth * "+tu+" + depth2;\n      vec2 uv = uvFromFlat("+tm+", "+tg+", index + "+xa(tr)+");\n      return sampleTexture("+tr+", uv);\n    }\n  "}(g);case 5:return function(g){var te=g.shapeInfo.logicalShape,tr=g.name,to="get"+tr.charAt(0).toUpperCase()+tr.slice(1),tu=te[4],tc=te[3]*tu,tl=te[2]*tc,th=te[1]*tl,td=M(te),tf=td.newShape,tp=td.keptDims;if(tf.length<te.length)return"\n      "+da(Ca(g,tf))+"\n      float "+to+"(int row, int col, int depth, int depth2, int depth3) {\n        return "+to+"("+Ea(["row","col","depth","depth2","depth3"],tp)+");\n      }\n    ";if(g.shapeInfo.isUniform)return"\n      float "+to+"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+th+", "+tl+", "+tc+", "+tu+")) +\n          depth3;\n        "+ba(g)+"\n      }\n    ";var tv=g.shapeInfo.flatOffset,tm=g.shapeInfo.texShape,tg=tm[0],ty=tm[1];return ty===th&&null==tv?"\n      float "+to+"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4("+tl+", "+tc+", "+tu+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+ty+".0, "+tg+".0);\n        return sampleTexture("+tr+", uv);\n      }\n    ":ty===tu&&null==tv?"\n      float "+to+"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+te[1]*te[2]*te[3]+",\n               "+te[2]*te[3]+", "+te[3]+", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+ty+".0, "+tg+".0);\n        return sampleTexture("+tr+", uv);\n      }\n    ":"\n    float "+to+"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+th+" + col * "+tl+" + depth * "+tc+" +\n          depth2 * "+tu+" + depth3 + "+xa(tr)+";\n      vec2 uv = uvFromFlat("+tg+", "+ty+", index);\n      return sampleTexture("+tr+", uv);\n    }\n  "}(g);case 6:return function(g){var te=g.shapeInfo.logicalShape,tr=g.name,to="get"+tr.charAt(0).toUpperCase()+tr.slice(1),tu=M(te),tc=tu.newShape,tl=tu.keptDims;if(tc.length<te.length)return"\n      "+da(Ca(g,tc))+"\n      float "+to+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return "+to+"("+Ea(["row","col","depth","depth2","depth3","depth4"],tl)+");\n      }\n    ";var th=te[5],td=te[4]*th,tf=te[3]*td,tp=te[2]*tf,tv=te[1]*tp;if(g.shapeInfo.isUniform)return"\n      float "+to+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4("+tv+", "+tp+", "+tf+", "+td+")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2("+th+", 1)));\n        "+ba(g)+"\n      }\n    ";var tm=g.shapeInfo.flatOffset,tg=g.shapeInfo.texShape,ty=tg[0],tx=tg[1];return tx===tv&&null==tm?"\n      float "+to+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4("+tp+", "+tf+", "+td+", "+th+")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+tx+".0, "+ty+".0);\n        return sampleTexture("+tr+", uv);\n      }\n    ":tx===th&&null==tm?"\n      float "+to+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4("+te[1]*te[2]*te[3]*te[4]+",\n               "+te[2]*te[3]*te[4]+",\n               "+te[3]*te[4]+",\n               "+te[4]+")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+tx+".0, "+ty+".0);\n        return sampleTexture("+tr+", uv);\n      }\n    ":"\n    float "+to+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+tv+" + col * "+tp+" + depth * "+tf+" +\n          depth2 * "+td+" + depth3 * "+th+" + depth4 + "+xa(tr)+";\n      vec2 uv = uvFromFlat("+ty+", "+tx+", index);\n      return sampleTexture("+tr+", uv);\n    }\n  "}(g);default:throw Error(te.length+"-D input sampling is not yet supported")}}function pa(g){var te,tr,to,tu;switch(g.shapeInfo.logicalShape.length){case 0:return"\n    vec4 get"+(te=g.name).charAt(0).toUpperCase()+te.slice(1)+"() {\n      return "+ua().texture2D+"("+te+", halfCR);\n    }\n  ";case 1:return"\n    vec4 get"+(tr=g.name).charAt(0).toUpperCase()+tr.slice(1)+"(int index) {\n      vec2 uv = packedUVfrom1D(\n        "+(tu=[Math.ceil((to=g.shapeInfo.texShape)[0]/2),Math.ceil(to[1]/2)])[0]+", "+tu[1]+", index);\n      return "+ua().texture2D+"("+tr+", uv);\n    }\n  ";case 2:return function(g){var te=g.shapeInfo.logicalShape,tr=g.name,to="get"+tr.charAt(0).toUpperCase()+tr.slice(1),tu=g.shapeInfo.texShape,tc=tu[0],tl=tu[1],th=ua();if(null!=tu&&S(te,tu))return"\n      vec4 "+to+"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2("+tl+".0, "+tc+".0);\n\n        return "+th.texture2D+"("+tr+", uv);\n      }\n    ";var td=[Math.ceil(tu[0]/2),Math.ceil(tu[1]/2)];return"\n    vec4 "+to+"(int row, int col) {\n      vec2 uv = packedUVfrom2D("+Math.ceil(te[1]/2)+", "+td[0]+", "+td[1]+", row, col);\n      return "+th.texture2D+"("+tr+", uv);\n    }\n  "}(g);case 3:return function(g){var te=g.shapeInfo.logicalShape,tr=g.name,to="get"+tr.charAt(0).toUpperCase()+tr.slice(1),tu=g.shapeInfo.texShape,tc=[Math.ceil(tu[0]/2),Math.ceil(tu[1]/2)];if(1===te[0])return"\n        "+pa(Ca(g,te.slice(1)))+"\n        vec4 "+to+"(int b, int row, int col) {\n          return "+to+"("+Ea(["b","row","col"],[1,2])+");\n        }\n      ";var tl=tc[0],th=tc[1],td=Math.ceil(te[2]/2);return"\n    vec4 "+to+"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        "+tl+", "+th+", "+td*Math.ceil(te[1]/2)+", "+td+", b, row, col);\n      return "+ua().texture2D+"("+tr+", uv);\n    }\n  "}(g);default:return function(g){for(var te=g.shapeInfo.logicalShape,tr=te.length,to=g.name,tu="get"+to.charAt(0).toUpperCase()+to.slice(1),tc=g.shapeInfo.texShape,tl=[Math.ceil(tc[0]/2),Math.ceil(tc[1]/2)],th=tl[0],td=tl[1],tf=Math.ceil(te[tr-1]/2),tp=tf*Math.ceil(te[tr-2]/2),tv="int b, int row, int col",tm="b * "+tp+" + (row / 2) * "+tf+" + (col / 2)",tg=2;tg<tr-1;tg++)tv="int b"+tg+", "+tv,tp*=te[tr-tg-1],tm="b"+tg+" * "+tp+" + "+tm;return"\n    vec4 "+tu+"("+tv+") {\n      int index = "+tm+";\n      int texR = index / "+td+";\n      int texC = index - texR * "+td+";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+td+", "+th+");\n      return "+ua().texture2D+"("+to+", uv);\n    }\n  "}(g)}}var nj="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",nX="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",n$="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",nY="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function xa(g){return"offset"+g}function ba(g){var te=g.name,tr=k(g.shapeInfo.logicalShape);return tr<2?"return "+te+";":"\n    for (int i = 0; i < "+tr+"; i++) {\n      if (i == index) {\n        return "+te+"[i];\n      }\n    }\n  "}function wa(g){if(g<=1)return"int";if(2===g)return"ivec2";if(3===g)return"ivec3";if(4===g)return"ivec4";if(5===g)return"ivec5";if(6===g)return"ivec6";throw Error("GPU for rank "+g+" is not yet supported")}function Ca(g,te){var tr=JSON.parse(JSON.stringify(g));return tr.shapeInfo.logicalShape=te,tr}function Ea(g,te){return te.map(function(te){return g[te]}).join(", ")}var Ra=function(g,te,tr,to){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,C(g.length>2,function(){return"Packed arg"+(tr.charAt(0).toUpperCase()+tr.slice(1))+" supports only inputs with rank above 2."});var tu=Math.ceil(g[g.length-1]/te);this.outputShape=g.slice(0,-1),tu>1&&this.outputShape.push(tu),to||this.variableNames.push("bestIndicesA");var tc,tl,th=this.outputShape,td=th.length,tf=wa(td),tp=sa("coords",td);if(1===tu){var tv=wa(tl=td+1);tc="\n        "+tv+" sourceLocR = "+tv+"("+tp.join()+", 0);\n        ++"+tp[td-1]+";\n        "+tv+" sourceLocG = "+tv+"("+tp.join()+", 0);\n        ++"+tp[td-2]+";\n        "+tv+" sourceLocA = "+tv+"("+tp.join()+", 0);\n        --"+tp[td-1]+";\n        "+tv+" sourceLocB = "+tv+"("+tp.join()+", 0);\n        --"+tp[td-2]+";"}else tl=td,tc="\n        "+tf+" sourceLocR = coords;\n        ++"+tp[td-1]+";\n        "+tf+" sourceLocG = coords;\n        ++"+tp[td-2]+";\n        "+tf+" sourceLocA = coords;\n        --"+tp[td-1]+";\n        "+tf+" sourceLocB = coords;\n        --"+tp[td-2]+";";var tm=["x","y","z","w","u","v"].slice(0,tl),tg="."+tm[tl-1],ty=tm.map(function(g){return"int "+g}),tx=sa("sourceLocR",tl-1).concat("inIdx.r"),tb=sa("sourceLocG",tl-1).concat("inIdx.g"),tC=sa("sourceLocB",tl-1).concat("inIdx.b"),tw=sa("sourceLocA",tl-1).concat("inIdx.a"),tE=to?"":"\n          inIdx = round(vec4(getBestIndicesAChannel("+tx.join()+"),\n                             getBestIndicesAChannel("+tb.join()+"),\n                             getBestIndicesAChannel("+tC.join()+"),\n                             getBestIndicesAChannel("+tw.join()+")));",tR="vec4(\n            getAChannel("+tx.join()+"),\n            hasNextCol ? getAChannel("+tb.join()+") : 0.,\n            hasNextRow ? getAChannel("+tC.join()+") : 0.,\n            hasNextRow && hasNextCol ? getAChannel("+tw.join()+") : 0.)",tI=to?"":"\n      float getBestIndicesAChannel("+ty.join()+") {\n        return getChannel(getBestIndicesA("+tm.join()+"),\n                                          vec2("+tm.slice(-2).join()+"));\n      }";this.userCode="\n      float getAChannel("+ty.join()+") {\n        return getChannel(getA("+tm.join()+"),\n                               vec2("+tm.slice(-2).join()+"));\n      }\n      "+tI+"\n      void main() {\n        "+tf+" coords = getOutputCoords();\n        bool hasNextCol = "+tp[td-1]+" < "+(th[td-1]-1)+";\n        bool hasNextRow = "+tp[td-2]+" < "+(th[td-2]-1)+";\n        "+tc+"\n        ivec4 srcIdx = ivec4(sourceLocR"+tg+", sourceLocG"+tg+",\n          sourceLocB"+tg+", sourceLocA"+tg+") * "+te+";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = "+tR+";\n\n        for (int i = 0; i < "+te+"; i++) {\n          inIdx = srcIdx;\n          "+tE+"\n          vec4 candidate = "+tR+";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4("+("max"===tr?"greaterThan":"lessThan")+"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    "},Ia=function(g){this.variableNames=["dy"],this.outputShape=g.inShape;var te=g.filterHeight,tr=g.filterWidth,to=g.strideHeight,tu=g.strideWidth,tc=g.dilationHeight,tl=g.dilationWidth,th=g.effectiveFilterHeight,td=g.effectiveFilterWidth,tf=th-1-g.padInfo.top,tp=td-1-g.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2("+tf+", "+tp+");\n      const float avgMultiplier = float("+1/(te*tr)+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+th+";\n            wR += "+tc+") {\n          float dyR = float(dyRCorner + wR) / "+to+".0;\n\n          if (dyR < 0.0 || dyR >= "+g.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+td+";\n            wC+= "+tl+") {\n            float dyC = float(dyCCorner + wC) / "+tu+".0;\n\n            if (dyC < 0.0 || dyC >= "+g.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},ka=function(g){this.variableNames=["dy"],this.outputShape=g.inShape;var te=g.filterDepth,tr=g.filterHeight,to=g.filterWidth,tu=g.strideDepth,tc=g.strideHeight,tl=g.strideWidth,th=g.dilationDepth,td=g.dilationHeight,tf=g.dilationWidth,tp=g.effectiveFilterDepth,tv=g.effectiveFilterHeight,tm=g.effectiveFilterWidth,tg=tp-1-g.padInfo.front,ty=tv-1-g.padInfo.top,tx=tm-1-g.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3("+tg+", "+ty+", "+tx+");\n      const float avgMultiplier = float("+1/(te*tr*to)+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < "+tp+";\n            wD += "+th+") {\n          float dyD = float(dyDCorner + wD) / "+tu+".0;\n\n          if (dyD < 0.0 || dyD >= "+g.outDepth+".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < "+tv+";\n              wR += "+td+") {\n            float dyR = float(dyRCorner + wR) / "+tc+".0;\n\n            if (dyR < 0.0 || dyR >= "+g.outHeight+".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < "+tm+";\n                wC += "+tf+") {\n              float dyC = float(dyCCorner + wC) / "+tl+".0;\n\n              if (dyC < 0.0 || dyC >= "+g.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Sa=function(g,te,tr,to,tu,tc){this.outputShape=[],this.variableNames=["x","mean","variance"],Ro(g,te),Ro(g,tr);var tl="0.0";null!=to&&(Ro(g,to),this.variableNames.push("offset"),tl="getOffsetAtOutCoords()");var th="1.0";null!=tu&&(Ro(g,tu),this.variableNames.push("scale"),th="getScaleAtOutCoords()"),this.outputShape=g,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = "+tl+";\n        float scale = "+th+";\n        float inv = scale * inversesqrt(variance + float("+tc+"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    "},Aa=function(g,te,tr,to,tu,tc){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ro(g,te),Ro(g,tr);var tl="vec4(0.0)";null!=to&&(Ro(g,to),this.variableNames.push("offset"),tl="getOffsetAtOutCoords()");var th="vec4(1.0)";null!=tu&&(Ro(g,tu),this.variableNames.push("scale"),th="getScaleAtOutCoords()"),this.outputShape=g,this.userCode="\n      void main() {\n        vec4 offset = "+tl+";\n        vec4 scale = "+th+";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4("+tc+"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    "},Na=function(g,te,tr){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ro(te,tr),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        "+g+"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    "},nJ="return a + b;",nQ="return a - b;",nZ="return a * b;",n0="return (a < 0.) ? b * a : a;",Ba=function(g,te,tr){this.variableNames=["A","B"],this.outputShape=Ro(te,tr),this.userCode="\n      float binaryOperation(float a, float b) {\n        "+g+"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    "},n1="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",La=function(g,te,tr,to){void 0===to&&(to=!1),this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ro(te,tr);var tu=this.outputShape.length,tc="";if(to){if(0===tu||1===k(this.outputShape))tc="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(tc="\n          "+wa(tu)+" coords = getOutputCoords();\n        ",1===tu)tc+="\n            result.y = (coords + 1) >= "+this.outputShape[0]+" ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";else{var tl=sa("coords",tu);tc+="\n            bool nextRowOutOfBounds =\n              ("+tl[tu-2]+" + 1) >= "+this.outputShape[tu-2]+";\n            bool nextColOutOfBounds =\n              ("+tl[tu-1]+" + 1) >= "+this.outputShape[tu-1]+";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "}}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        "+g+"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        "+tc+"\n\n        setOutput(result);\n      }\n    "},n2=function(){function t(g){this.variableNames=["A"],this.outputShape=g,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(g,te){var tr=this;return function(to,tu){null==tr.minLoc&&(tr.minLoc=to.getUniformLocationNoThrow(tu,"minVal"),tr.maxLoc=to.getUniformLocationNoThrow(tu,"maxVal")),to.gl.uniform1f(tr.minLoc,g),to.gl.uniform1f(tr.maxLoc,te)}},t}(),n3=function(){function t(g){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=g,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(g,te){var tr=this;return function(to,tu){null==tr.minLoc&&(tr.minLoc=to.getUniformLocationNoThrow(tu,"minVal"),tr.maxLoc=to.getUniformLocationNoThrow(tu,"maxVal")),to.gl.uniform1f(tr.minLoc,g),to.gl.uniform1f(tr.maxLoc,te)}},t}(),Va=function(g){this.variableNames=["real","imag"],this.outputShape=g,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "},za=function(g){this.outputShape=[],this.outputShape=Sn(g,1),this.variableNames=g.map(function(g,te){return"T"+te});var te=Array(g.length-1);te[0]=g[0][1];for(var tr=1;tr<te.length;tr++)te[tr]=te[tr-1]+g[tr][1];var to=["if (yC < "+te[0]+") setOutput(getT0(yR, yC));"];for(tr=1;tr<te.length;tr++){var tu=te[tr-1];to.push("else if (yC < "+te[tr]+") setOutput(getT"+tr+"(yR, yC-"+tu+"));")}var tc=te.length,tl=te[te.length-1];to.push("else setOutput(getT"+tc+"(yR, yC-"+tl+"));"),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        "+to.join("\n        ")+"\n      }\n    "},Ga=function(g,te){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Sn(g,te);var tr=this.outputShape,to=tr.length,tu=wa(to),tc=sa("coords",to),tl=["x","y","z","w","u","v"].slice(0,to);this.variableNames=g.map(function(g,te){return"T"+te});var th=Array(g.length-1);th[0]=g[0][te];for(var td=1;td<th.length;td++)th[td]=th[td-1]+g[td][te];var tf=tl[te],tp=tl.slice(-2),tv=tl.join(),tm="if ("+tf+" < "+th[0]+") {\n        return getChannel(\n            getT0("+tv+"), vec2("+tp.join()+"));\n        }";for(td=1;td<th.length;td++){var tg=th[td-1];tm+="\n        if ("+tf+" < "+th[td]+"  && "+tf+" >= "+th[td-1]+") {\n          return getChannel(\n            getT"+td+"("+Ha(tl,tf,tg)+"),\n            vec2("+Ha(tp,tf,tg)+"));\n        }"}var ty=th.length,tx=th[th.length-1];tm+="\n        return getChannel(\n          getT"+ty+"("+Ha(tl,tf,tx)+"),\n          vec2("+Ha(tp,tf,tx)+"));",this.userCode="\n      float getValue("+tl.map(function(g){return"int "+g})+") {\n        "+tm+"\n      }\n\n      void main() {\n        "+tu+" coords = getOutputCoords();\n        vec4 result = vec4(getValue("+tc+"), 0., 0., 0.);\n\n        "+tc[to-1]+" = "+tc[to-1]+" + 1;\n        if ("+tc[to-1]+" < "+tr[to-1]+") {\n          result.g = getValue("+tc+");\n        }\n\n        "+tc[to-2]+" = "+tc[to-2]+" + 1;\n        if ("+tc[to-2]+" < "+tr[to-2]+") {\n          result.a = getValue("+tc+");\n        }\n\n        "+tc[to-1]+" = "+tc[to-1]+" - 1;\n        if ("+tc[to-2]+" < "+tr[to-2]+" &&\n            "+tc[to-1]+" < "+tr[to-1]+") {\n          result.b = getValue("+tc+");\n        }\n        setOutput(result);\n      }\n    "};function Ha(g,te,tr){var to=g.indexOf(te);return g.map(function(g,te){return te===to?g+" - "+tr:g}).join()}var qa=function(g){this.variableNames=["x","dy"],this.outputShape=g.filterShape;var te=g.strideHeight,tr=g.strideWidth,to=g.padInfo.top,tu=g.padInfo.left,tc="channelsLast"===g.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+g.batchSize+"; b++) {\n          for (int yR = 0; yR < "+g.outHeight+"; yR++) {\n            int xR = wR + yR * "+te+" - "+to+";\n\n            if (xR < 0 || xR >= "+g.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+g.outWidth+"; yC++) {\n              int xC = wC + yC * "+tr+" - "+tu+";\n\n              if (xC < 0 || xC >= "+g.inWidth+") {\n                continue;\n              }\n\n              if ("+tc+") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Ka=function(g){this.variableNames=["dy","W"],this.outputShape=g.inShape;var te=g.filterHeight,tr=g.filterWidth,to=g.strideHeight,tu=g.strideWidth,tc="channelsLast"===g.dataFormat,tl=te-1-g.padInfo.top,th=tr-1-g.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2("+tl+", "+th+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords["+(tc?3:1)+"];\n\n        ivec2 dyCorner = ivec2(coords["+(tc?1:2)+"], coords["+(tc?2:3)+"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+te+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+to+".0;\n\n          if (dyR < 0.0 || dyR >= "+g.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+te+" - 1 - wR;\n\n          for (int wC = 0; wC < "+tr+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+tu+".0;\n\n            if (dyC < 0.0 || dyC >= "+g.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+tr+" - 1 - wC;\n\n            for (int d2 = 0; d2 < "+g.outChannels+"; d2++) {\n\n              if ("+tc+") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},ja=function(g){this.variableNames=["x","dy"],this.outputShape=g.filterShape;var te=g.strideDepth,tr=g.strideHeight,to=g.strideWidth,tu=g.padInfo.front,tc=g.padInfo.top,tl=g.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+g.batchSize+"; b++) {\n          for (int yF = 0; yF < "+g.outDepth+"; yF++) {\n            int xF = wF + yF * "+te+" - "+tu+";\n\n            if (xF < 0 || xF >= "+g.inDepth+") {\n              continue;\n            }\n\n            for (int yR = 0; yR < "+g.outHeight+"; yR++) {\n              int xR = wR + yR * "+tr+" - "+tc+";\n\n              if (xR < 0 || xR >= "+g.inHeight+") {\n                continue;\n              }\n\n              for (int yC = 0; yC < "+g.outWidth+"; yC++) {\n                int xC = wC + yC * "+to+" - "+tl+";\n\n                if (xC < 0 || xC >= "+g.inWidth+") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Xa=function(g){this.variableNames=["dy","W"],this.outputShape=g.inShape;var te=g.filterDepth,tr=g.filterHeight,to=g.filterWidth,tu=g.strideDepth,tc=g.strideHeight,tl=g.strideWidth,th=te-1-g.padInfo.front,td=tr-1-g.padInfo.top,tf=to-1-g.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3("+th+", "+td+", "+tf+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < "+te+"; wF++) {\n          float dyF = float(dyFCorner + wF) / "+tu+".0;\n\n          if (dyF < 0.0 || dyF >= "+g.outDepth+".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = "+te+" - 1 - wF;\n\n          for (int wR = 0; wR < "+tr+"; wR++) {\n            float dyR = float(dyRCorner + wR) / "+tc+".0;\n\n            if (dyR < 0.0 || dyR >= "+g.outHeight+".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = "+tr+" - 1 - wR;\n\n            for (int wC = 0; wC < "+to+"; wC++) {\n              float dyC = float(dyCCorner + wC) / "+tl+".0;\n\n              if (dyC < 0.0 || dyC >= "+g.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = "+to+" - 1 - wC;\n\n              for (int d2 = 0; d2 < "+g.outChannels+"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Ya=function(g){this.variableNames=["x","dy"],this.outputShape=g.filterShape;var te=g.strideHeight,tr=g.strideWidth,to=g.padInfo.top,tu=g.padInfo.left,tc=g.outChannels/g.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * "+tc+" + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < "+g.batchSize+"; b++) {\n          for (int yR = 0; yR < "+g.outHeight+"; yR++) {\n            int xR = wR + yR * "+te+" - "+to+";\n\n            if (xR < 0 || xR >= "+g.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+g.outWidth+"; yC++) {\n              int xC = wC + yC * "+tr+" - "+tu+";\n\n              if (xC < 0 || xC >= "+g.inWidth+") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},$a=function(g){this.variableNames=["dy","W"],this.outputShape=g.inShape;var te=g.filterHeight,tr=g.filterWidth,to=g.strideHeight,tu=g.strideWidth,tc=te-1-g.padInfo.top,tl=tr-1-g.padInfo.left,th=g.outChannels/g.inChannels;this.userCode="\n      const ivec2 pads = ivec2("+tc+", "+tl+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < "+te+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+to+".0;\n\n          if (dyR < 0.0 || dyR >= "+g.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+te+" - 1 - wR;\n\n          for (int wC = 0; wC < "+tr+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+tu+".0;\n\n            if (dyC < 0.0 || dyC >= "+g.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+tr+" - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < "+th+"; dm++) {\n              int d2 = d1 * "+th+" + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Qa=function(g,te,tr,to){void 0===te&&(te=!1),void 0===tr&&(tr=null),void 0===to&&(to=!1),this.variableNames=["x","W"],this.outputShape=g.outShape;var tu=g.padInfo.top,tc=g.padInfo.left,tl=g.strideHeight,th=g.strideWidth,td=g.dilationHeight,tf=g.dilationWidth,tp=g.filterHeight,tv=g.filterWidth,tm=4*Math.floor(g.inChannels/4),tg=g.inChannels%4,ty="channelsLast"===g.dataFormat,tx="",tb="";tr&&(tx=to?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          "+tr+"\n        }":"\n          float activation(float x) {\n            "+tr+"\n          }\n        ",tb="result = activation(result);");var tC=te?"result += getBiasAtOutCoords();":"";te&&this.variableNames.push("bias"),to&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+tx+"\n\n      const ivec2 strides = ivec2("+tl+", "+th+");\n      const ivec2 pads = ivec2("+tu+", "+tc+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords["+(ty?3:1)+"];\n\n        ivec2 xRCCorner =\n            ivec2(coords["+(ty?1:2)+"], coords["+(ty?2:3)+"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+tp+"; wR++) {\n          int xR = xRCorner + wR * "+td+";\n\n          if (xR < 0 || xR >= "+g.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+tv+"; wC++) {\n            int xC = xCCorner + wC * "+tf+";\n\n            if (xC < 0 || xC >= "+g.inWidth+") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < "+tm+"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if ("+ty+") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if ("+(1===tg)+") {\n\n              if ("+ty+") {\n                dotProd +=\n                    getX(batch, xR, xC, "+tm+") *\n                    getW(wR, wC, "+tm+", d2);\n              } else {\n                dotProd +=\n                    getX(batch, "+tm+", xR, xC) *\n                    getW(wR, wC, "+tm+", d2);\n              }\n\n            } else if ("+(2===tg)+") {\n              vec2 wValues = vec2(\n                getW(wR, wC, "+tm+", d2),\n                getW(wR, wC, "+tm+" + 1, d2)\n              );\n\n              if ("+ty+") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, "+tm+"),\n                  getX(batch, xR, xC, "+tm+" + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, "+tm+", xR, xC),\n                  getX(batch, "+tm+" + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if ("+(3===tg)+") {\n              vec3 wValues = vec3(\n                getW(wR, wC, "+tm+", d2),\n                getW(wR, wC, "+tm+" + 1, d2),\n                getW(wR, wC, "+tm+" + 2, d2)\n              );\n\n              if ("+ty+") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, "+tm+"),\n                  getX(batch, xR, xC, "+tm+" + 1),\n                  getX(batch, xR, xC, "+tm+" + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, "+tm+", xR, xC),\n                  getX(batch, "+tm+" + 1, xR, xC),\n                  getX(batch, "+tm+" + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        "+tC+"\n        "+tb+"\n        setOutput(result);\n      }\n    "},Ja=function(g){this.variableNames=["x","W"],this.outputShape=g.outShape;var te=g.padInfo.front,tr=g.padInfo.top,to=g.padInfo.left,tu=g.strideDepth,tc=g.strideHeight,tl=g.strideWidth,th=g.dilationDepth,td=g.dilationHeight,tf=g.dilationWidth,tp=g.filterDepth,tv=g.filterHeight,tm=g.filterWidth,tg=4*Math.floor(g.inChannels/4),ty=g.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3("+tu+", "+tc+", "+tl+");\n      const ivec3 pads = ivec3("+te+", "+tr+", "+to+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < "+tp+"; wF++) {\n          int xF = xFCorner + wF * "+th+";\n\n          if (xF < 0 || xF >= "+g.inDepth+") {\n            continue;\n          }\n\n          for (int wR = 0; wR < "+tv+"; wR++) {\n            int xR = xRCorner + wR * "+td+";\n\n            if (xR < 0 || xR >= "+g.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+tm+"; wC++) {\n              int xC = xCCorner + wC * "+tf+";\n\n              if (xC < 0 || xC >= "+g.inWidth+") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < "+tg+"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if ("+(1===ty)+") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, "+tg+") *\n                  getW(wF, wR, wC, "+tg+", d2);\n              } else if ("+(2===ty)+") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, "+tg+"),\n                  getX(batch, xF, xR, xC, "+tg+" + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, "+tg+", d2),\n                  getW(wF, wR, wC, "+tg+" + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if ("+(3===ty)+") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, "+tg+"),\n                  getX(batch, xF, xR, xC, "+tg+" + 1),\n                  getX(batch, xF, xR, xC, "+tg+" + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, "+tg+", d2),\n                  getW(wF, wR, wC, "+tg+" + 1, d2),\n                  getW(wF, wR, wC, "+tg+" + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Za=function(g,te,tr,to){void 0===te&&(te=!1),void 0===tr&&(tr=null),void 0===to&&(to=!1),this.variableNames=["x","W"],this.outputShape=g.outShape;var tu=g.inHeight,tc=g.inWidth,tl=g.padInfo.top,th=g.padInfo.left,td=g.strideHeight,tf=g.strideWidth,tp=g.dilationHeight,tv=g.dilationWidth,tm=g.filterHeight,tg=g.filterWidth,ty=g.outChannels/g.inChannels,tx="",tb="";tr&&(tx=to?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          "+tr+"\n        }":"\n          float activation(float x) {\n            "+tr+"\n          }\n        ",tb="result = activation(result);");var tC=te?"result += getBiasAtOutCoords();":"";te&&this.variableNames.push("bias"),to&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+tx+"\n\n      const ivec2 strides = ivec2("+td+", "+tf+");\n      const ivec2 pads = ivec2("+tl+", "+th+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / "+ty+";\n        int q = d2 - d1 * "+ty+";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < "+tm+"; wR++) {\n          int xR = xRCorner + wR * "+tp+";\n\n          if (xR < 0 || xR >= "+tu+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+tg+"; wC++) {\n            int xC = xCCorner + wC * "+tv+";\n\n            if (xC < 0 || xC >= "+tc+") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        "+tC+"\n        "+tb+"\n        setOutput(result);\n      }\n    "},ti=function(g,te,tr,to){void 0===te&&(te=!1),void 0===tr&&(tr=null),void 0===to&&(to=!1),this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=g.outShape;for(var tu=g.inHeight,tc=g.inWidth,tl=g.padInfo.top,th=g.padInfo.left,td=g.strideHeight,tf=g.strideWidth,tp=g.dilationHeight,tv=g.dilationWidth,tm=g.filterHeight,tg=g.filterWidth,ty="int xR; int xC; int xCOffset;",tx=0;tx<tm;tx++)for(var tb=0;tb<tg;tb++)ty+="\n          vec4 xTexelR"+tx+"C"+2*tb+" = vec4(0.);\n          vec4 wR"+tx+"C"+tb+" = vec4(0.);\n          vec4 xR"+tx+"C"+tb+" = vec4(0.);";for(tx=0;tx<tm;tx++)for(var tC=0;tC<tg;tC++){if(ty+="\n          xR = xRCorner + "+tx*tp+";\n          xC = xCCorner + "+(tb=2*tC)*tv+";\n        ",1===tf){if(tb<tg&&(ty+=th%2==1?"\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < "+tu+" && xCOffset >= 0 && xCOffset < "+tc+") {\n                  xTexelR"+tx+"C"+tb+" = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= "+tc+") {\n                    xTexelR"+tx+"C"+tb+".zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR"+tx+"C"+tb+" = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < "+tu+" && xCOffset >= 0 && xCOffset < "+tc+") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= "+tc+") {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR"+tx+"C"+tb+" = vec4(previous.zw, xTexelR"+tx+"C"+tb+".xy);\n                } else {\n                  xR"+tx+"C"+tb+" = vec4(0, 0, xTexelR"+tx+"C"+tb+".xy);\n                }\n              ":"\n                if(xR >= 0 && xR < "+tu+" && xC >= 0 && xC < "+tc+") {\n                  xTexelR"+tx+"C"+tb+" = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR"+tx+"C"+tb+" = vec4(0.);\n                }\n\n                xR"+tx+"C"+tb+" = xTexelR"+tx+"C"+tb+";\n              ",tb+1<tg)){var tw=th%2==0?b(tv):tv;tv%2==0&&th%2==1||tv%2!=0&&th%2!=1?(ty+="\n                  xCOffset = xC + "+th%2+" + "+tw+";\n\n                  if(xR >= 0 && xR < "+tu+" &&\n                    xCOffset >= 0 && xCOffset < "+tc+") {\n                    xTexelR"+tx+"C"+(tb+2)+" = getX(batch, xR, xCOffset, d1);\n                  }\n                ",tv>1&&(ty+="\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < "+tu+" &&\n                      xCOffset >= 0 && xCOffset < "+tc+") {\n                      xTexelR"+tx+"C"+tb+" = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR"+tx+"C"+tb+" = vec4(0.);\n                    }\n                  "),ty+="\n                  xR"+tx+"C"+(tb+1)+" = vec4(\n                    xTexelR"+tx+"C"+tb+".zw, xTexelR"+tx+"C"+(tb+2)+".xy);\n                "):ty+="\n                  xCOffset = xC + "+tw+";\n\n                  if(xR >= 0 && xR < "+tu+" &&\n                    xCOffset >= 0 && xCOffset < "+tc+") {\n                    xTexelR"+tx+"C"+(tb+2)+" = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR"+tx+"C"+(tb+1)+" = xTexelR"+tx+"C"+(tb+2)+";\n                "}}else tb<tg&&(ty+="\n              if(xR >= 0 && xR < "+tu+") {\n            ",th%2==1?(ty+="\n                xCOffset = xC + 1 - "+tf+";\n                if(xCOffset >= 0 && xCOffset < "+tc+") {\n                  xTexelR"+tx+"C"+tb+" = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+tx+"C"+tb+" = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < "+tc+") {\n                  xTexelR"+tx+"C"+(tb+2)+" = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR"+tx+"C"+(tb+2)+" = vec4(0.);\n                }\n\n                xR"+tx+"C"+tb+" = vec4(\n                  xTexelR"+tx+"C"+tb+".zw, xTexelR"+tx+"C"+(tb+2)+".zw);\n              ",tb+1<tg&&(ty+="\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + "+tf+";\n                  if(xCOffset >= 0 && xCOffset < "+tc+") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR"+tx+"C"+(tb+1)+" = vec4(xTexelR"+tx+"C"+(tb+2)+".xy, final.xy);\n                ")):(ty+="\n                if(xC >= 0 && xC < "+tc+") {\n                  xTexelR"+tx+"C"+tb+" = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR"+tx+"C"+tb+" = vec4(0.);\n                }\n\n                xCOffset = xC + "+tf+";\n                if(xCOffset >= 0 && xCOffset < "+tc+") {\n                  xTexelR"+tx+"C"+(tb+2)+" = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+tx+"C"+(tb+2)+" = vec4(0.);\n                }\n\n                xR"+tx+"C"+tb+" = vec4(\n                  xTexelR"+tx+"C"+tb+".xy, xTexelR"+tx+"C"+(tb+2)+".xy);\n              ",tb+1<tg&&(ty+="\n                  xR"+tx+"C"+(tb+1)+" = vec4(\n                    xTexelR"+tx+"C"+tb+".zw, xTexelR"+tx+"C"+(tb+2)+".zw);\n                ")),ty+="}");tb<tg&&(ty+="\n            vec4 wTexelR"+tx+"C"+tb+" = getW("+tx+", "+tb+", d1, q);\n            wR"+tx+"C"+tb+" = vec4(wTexelR"+tx+"C"+tb+".xz, wTexelR"+tx+"C"+tb+".xz);\n          ",tb+1<tg&&(ty+="\n              vec4 wTexelR"+tx+"C"+(tb+1)+" = getW("+tx+", "+(tb+1)+", d1, q);\n              wR"+tx+"C"+(tb+1)+" =\n                vec4(wTexelR"+tx+"C"+(tb+1)+".xz, wTexelR"+tx+"C"+(tb+1)+".xz);"))}for(tx=0;tx<tm;tx++)for(tb=0;tb<tg;tb++)ty+="dotProd += xR"+tx+"C"+tb+" * wR"+tx+"C"+tb+";";var tE="",tR="";tr&&(tE=to?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          "+tr+"\n        }":"vec4 activation(vec4 x) {\n          "+tr+"\n        }",tR="result = activation(result);");var tI=te?"result += getBiasAtOutCoords();":"";te&&this.variableNames.push("bias"),to&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+tE+"\n\n      const ivec2 strides = ivec2("+td+", "+tf+");\n      const ivec2 pads = ivec2("+tl+", "+th+");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        "+ty+"\n\n        vec4 result = dotProd;\n        "+tI+"\n        "+tR+"\n        setOutput(result);\n      }\n    "},ei=function(g,te,tr,to,tu){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];var tc=g[0],tl=g[1],th=g[2],td=g[3],tf=te[0],tp=tr[0],tv=tr[1];this.outputShape=[tf,tp,tv,td];var tm=[tl-1+".0",th-1+".0"],tg=tm[0],ty=tm[1],tx=tp>1?[""+(tl-1)/(tp-1),"(y2-y1) * height_ratio","y1*"+tg+" + float(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+tg],tb=tx[0],tC=tx[1],tw=tx[2],tE=tv>1?[""+(th-1)/(tv-1),"(x2-x1) * width_ratio","x1*"+ty+" + float(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+ty],tR=tE[0],tI=tE[1],tk=tE[2];this.userCode="\n      const float height_ratio = float("+tb+");\n      const float width_ratio = float("+tR+");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= "+tc+") {\n          return;\n        }\n\n        float height_scale = "+tC+";\n        float width_scale = "+tI+";\n\n        float in_y = "+tw+";\n        if( in_y < 0.0 || in_y > "+tg+" ) {\n          setOutput(float("+tu+"));\n          return;\n        }\n        float in_x = "+tk+";\n        if( in_x < 0.0 || in_x > "+ty+" ) {\n          setOutput(float("+tu+"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if("+("bilinear"===to?1:0)+" == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    "},ni=function(g,te,tr){this.variableNames=["x"],this.outputShape=g;var to=g.length,tu=g[g.length-1];this.userCode="\n      int getIndex(int i) {\n        "+(tr?"return "+tu+" -i - 1;":"return i;")+"\n      }\n\n      void main() {\n        "+wa(to)+" coords = getOutputCoords();\n        int end = "+ri(to,"coords")+";\n        float val = 0.0;\n        for (int i = "+tu+" - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx "+(tr?"<":">")+" end) {\n            continue;\n          }\n          if (idx == end && "+te+") {\n            continue;\n          }\n          "+ri(to,"coords")+" = idx;\n          val += getX("+function(g,te){if(1===g)return""+te;if(2===g)return te+".x, "+te+".y";if(3===g)return te+".x, "+te+".y, "+te+".z";if(4===g)return te+".x, "+te+".y, "+te+".z, "+te+".w";throw Error("Cumulative sum for rank "+g+" is not yet supported")}(to,"coords")+");\n        }\n        setOutput(val);\n      }\n    "};function ri(g,te){if(1===g)return""+te;if(2===g)return te+".y";if(3===g)return te+".z";if(4===g)return te+".w";throw Error("Cumulative sum for rank "+g+" is not yet supported")}var oi=function(g){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=tL.DENSE;var te=Yt(g),tr=ua();this.outputShape=g,this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        "+ca(["r","c","d"],g)+"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2("+te[0]+", "+te[1]+"));\n        int index = 4 * (resTexRC.x * "+te[1]+" + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        "+tr.output+" = result;\n      }\n    "},ai=function(g){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=tL.DENSE;var te=Yt(g),tr=ua();this.outputShape=g,this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        "+ca(["r","c","d"],g)+"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2("+te[0]+", "+te[1]+"));\n        int index = 4 * (resTexRC.x * "+te[1]+" + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        "+tr.output+" = result;\n      }\n    "},n4=function(){function t(g,te,tr){this.variableNames=["x"],this.outputShape=[],this.outputShape=g,this.blockSize=te,this.dataFormat=tr,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = "+this.getHeightCoordString()+";\n      int w = "+this.getWidthCoordString()+";\n      int d = "+this.getDepthCoordString()+";\n\n      int in_h = h / "+te+";\n      int offset_h = imod(h, "+te+");\n      int in_w = w / "+te+";\n      int offset_w = imod(w, "+te+");\n      int offset_d = (offset_h * "+te+" + offset_w) *\n        "+this.getOutputDepthSize()+";\n      int in_d = d + offset_d;\n\n      float result = "+this.getInputSamplingString()+";\n      setOutput(result);\n    }\n  "}return t.prototype.getHeightCoordString=function(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"},t.prototype.getWidthCoordString=function(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"},t.prototype.getDepthCoordString=function(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"},t.prototype.getOutputDepthSize=function(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]},t.prototype.getInputSamplingString=function(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"},t}(),si=function(g){this.variableNames=["X"],this.outputShape=[g,g],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "},ui=function(g){this.variableNames=["A"],this.outTexUsage=tW.DOWNLOAD;var te=ua();this.outputShape=g,this.userCode="\n      "+nK+"\n\n      void main() {\n        float x = getAAtOutCoords();\n        "+te.output+" = encode_float(x);\n      }\n    "},ci=function(g){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=tW.DOWNLOAD;var te=ua();this.outputShape=g,this.userCode="\n      "+nK+"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        "+te.output+" = encode_float(x);\n      }\n    "},li=function(g,te,tr){void 0===tr&&(tr=!1),this.variableNames=["A"];var to=ua(),tu=te[0],tc=te[1];this.outputShape=g;var tl="result";tr&&(tl="floor(result * 255. + 0.5)"),this.userCode="\n      "+la(g)+"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / "+tc+";\n        int c = imod(flatIndex, "+tc+");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2("+tc+".0, "+tu+".0);\n        vec4 values = "+to.texture2D+"(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        "+to.output+" = vec4("+tl+", 0., 0., 0.);\n      }\n    "},hi=function(g,te,tr){void 0===tr&&(tr=!1),this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;var to=ua(),tu=te[0],tc=te[1];this.outputShape=g;var tl="",th="result";tr&&(th="floor(result * 255. + 0.5)");for(var td=0;td<=1;td++)for(var tf=0;tf<=1;tf++){var tp=2*td+tf;tl+="\n          localCoords = coords;\n          if(localCoords[2] + "+tf+" < "+g[2]+") {\n            localCoords[2] += "+tf+";\n            if(localCoords[1] + "+td+" < "+g[1]+") {\n              localCoords[1] += "+td+";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / "+tc+";\n              c = imod(flatIndex, "+tc+");\n              uv = (vec2(c, r) + halfCR) / vec2("+tc+".0, "+tu+".0);\n              values = "+to.texture2D+"(A, uv);\n\n              if(offset == 0) {\n                result["+tp+"] = values[0];\n              } else if(offset == 1) {\n                result["+tp+"] = values[1];\n              } else if(offset == 2) {\n                result["+tp+"] = values[2];\n              } else {\n                result["+tp+"] = values[3];\n              }\n            }\n          }\n        "}this.userCode="\n      "+la(g)+"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        "+tl+"\n\n        "+to.output+" = "+th+";\n      }\n    "},pi=function(g,te,tr){this.variableNames=["real","imag"];var to=te[1];this.outputShape=te;var tu=tr?"2.0 * "+Math.PI:"-2.0 * "+Math.PI;this.userCode="\n      const float exponentMultiplier = "+tu+";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        "+g+"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float("+to+");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < "+to+"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / "+(tr?to+".0":"1.0")+";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    "},n5=function(){function t(g,te){this.outputShape=[],this.variableNames=["x"],this.outputShape=g,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}return t.prototype.getCustomSetupFunc=function(g){var te=this;return function(tr,to){null==te.valueLoc&&(te.valueLoc=tr.getUniformLocationNoThrow(to,"value")),tr.gl.uniform1f(te.valueLoc,g)}},t}(),mi=function(g,te,tr){this.variableNames=["A","indices"];var to=g.slice();to[tr]=te,this.outputShape=to,this.rank=to.length;var tu=wa(this.rank),tc=function(g,te){var tr=g.length;if(tr>4)throw Error("Gather for rank "+tr+" is not yet supported");if(1===tr)return"int(getIndices(resRC))";for(var to=["resRC.x","resRC.y","resRC.z","resRC.w"],tu=[],tc=0;tc<g.length;tc++)tc===te?tu.push("int(getIndices("+to[tc]+"))"):tu.push(""+to[tc]);return tu.join()}(g,tr);this.userCode="\n      void main() {\n        "+tu+" resRC = getOutputCoords();\n        setOutput(getA("+tc+"));\n      }\n    "},gi=function(g,te,tr){this.sliceDim=g,this.strides=te,this.variableNames=["x","indices"],this.outputShape=tr;var to=wa(te.length),tu=wa(tr.length),tc=this.sliceDim>1?"strides[j]":"strides";this.userCode="\n        "+to+" strides = "+to+"("+this.strides+");\n         void main() {\n          "+tu+" coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < "+this.sliceDim+"; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * "+tc+";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      "};function yi(g,te){var tr=ua();return oe(g,te,tr.version+"\n    precision highp float;\n    "+tr.attribute+" vec3 clipSpacePos;\n    "+tr.attribute+" vec2 uv;\n    "+tr.varyingVs+" vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }")}function xi(g,te){return fe(g,te,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function bi(g,te){return de(g,te,new Uint16Array([0,1,2,2,1,3]))}function wi(g,te,tr,to,tu,tc,tl){ve(tr,to);var th=pe(g,te),td=g.TEXTURE_2D;return Jt(g,te,function(){return g.bindTexture(td,th)}),Jt(g,te,function(){return g.texParameteri(td,g.TEXTURE_WRAP_S,g.CLAMP_TO_EDGE)}),Jt(g,te,function(){return g.texParameteri(td,g.TEXTURE_WRAP_T,g.CLAMP_TO_EDGE)}),Jt(g,te,function(){return g.texParameteri(td,g.TEXTURE_MIN_FILTER,g.NEAREST)}),Jt(g,te,function(){return g.texParameteri(td,g.TEXTURE_MAG_FILTER,g.NEAREST)}),Jt(g,te,function(){return g.texImage2D(td,0,tu,tr,to,0,tc,tl,null)}),Jt(g,te,function(){return g.bindTexture(g.TEXTURE_2D,null)}),th}function Ci(g,te,tr,to,tu){var tc=[to,tr];return wi(g,te,tc[0],tc[1],tu.internalFormatFloat,tu.textureFormatFloat,g.FLOAT)}function Ei(g,te,tr,to,tu){var tc=[to,tr];return wi(g,te,tc[0],tc[1],tu.internalFormatHalfFloat,tu.textureFormatFloat,tu.textureTypeHalfFloat)}function Ri(g,te,tr,to,tu){var tc=[to,tr];return wi(g,te,tc[0],tc[1],g.RGBA,g.RGBA,g.UNSIGNED_BYTE)}function Ii(g,te,tr,to,tu){var tc=$t(tr,to);return wi(g,te,tc[0],tc[1],tu.internalFormatPackedFloat,g.RGBA,g.FLOAT)}function ki(g,te,tr,to,tu){var tc=$t(tr,to);return wi(g,te,tc[0],tc[1],tu.internalFormatPackedHalfFloat,g.RGBA,tu.textureTypeHalfFloat)}function Si(g,te,tr,to){return Jt(g,te,function(){return g.bindBuffer(g.ARRAY_BUFFER,to)}),ge(g,te,tr,"clipSpacePos",to,3,20,0)&&ge(g,te,tr,"uv",to,2,20,12)}function Ai(g,te,tr,to,tu,tc,tl){var th,td,tf;Jt(g,te,function(){return g.bindTexture(g.TEXTURE_2D,tr)}),tc instanceof Uint8Array?(th=new Uint8Array(to*tu*4),td=g.UNSIGNED_BYTE,tf=g.RGBA):(th=new Float32Array(to*tu*4),td=g.FLOAT,tf=tl.internalFormatPackedFloat),th.set(tc),Jt(g,te,function(){return g.texImage2D(g.TEXTURE_2D,0,tf,to,tu,0,g.RGBA,td,th)}),Jt(g,te,function(){return g.bindTexture(g.TEXTURE_2D,null)})}function Di(g,te,tr,to){Jt(g,te,function(){return g.bindTexture(g.TEXTURE_2D,tr)}),to.data instanceof Uint8Array?Jt(g,te,function(){return g.texImage2D(g.TEXTURE_2D,0,g.RGBA,to.width,to.height,0,g.RGBA,g.UNSIGNED_BYTE,to.data)}):Jt(g,te,function(){return g.texImage2D(g.TEXTURE_2D,0,g.RGBA,g.RGBA,g.UNSIGNED_BYTE,to)}),Jt(g,te,function(){return g.bindTexture(g.TEXTURE_2D,null)})}function Ti(g,te,tr,to,tu){var tc=g.createBuffer();Jt(g,te,function(){return g.bindBuffer(g.PIXEL_PACK_BUFFER,tc)});var tl=16*tr*to;return Jt(g,te,function(){return g.bufferData(g.PIXEL_PACK_BUFFER,tl,g.STREAM_READ)}),Jt(g,te,function(){return g.readPixels(0,0,to,tr,g.RGBA,g.FLOAT,0)}),Jt(g,te,function(){return g.bindBuffer(g.PIXEL_PACK_BUFFER,null)}),tc}function Ni(g,te,tr){var to=new Float32Array(tr);return g.bindBuffer(g.PIXEL_PACK_BUFFER,te),g.getBufferSubData(g.PIXEL_PACK_BUFFER,0,to),g.bindBuffer(g.PIXEL_PACK_BUFFER,null),to}function Fi(g,te,tr,to,tu){var tc=[to,tr],tl=tc[0],th=tc[1],td=new Uint8Array(tr*to*4);return Jt(g,te,function(){return g.readPixels(0,0,tl,th,tu.downloadTextureFormat,g.UNSIGNED_BYTE,td)}),new Float32Array(td.buffer)}function _i(g,te,tr,to,tu,tc,tl,th){var td,tf=new Float32Array((td=$t(tc,tl))[0]*td[1]*4);return g.bindBuffer(g.PIXEL_PACK_BUFFER,te),g.getBufferSubData(g.PIXEL_PACK_BUFFER,0,tf),g.bindBuffer(g.PIXEL_PACK_BUFFER,null),tf}function Oi(g,te,tr,to){var tu=new Float32Array(tr*to*4);return Jt(g,te,function(){return g.readPixels(0,0,to,tr,g.RGBA,g.FLOAT,tu)}),tu}var n6=Object.freeze({createVertexShader:yi,createVertexBuffer:xi,createIndexBuffer:bi,createFloat32MatrixTexture:Ci,createFloat16MatrixTexture:Ei,createUnsignedBytesMatrixTexture:Ri,createPackedMatrixTexture:Ii,createFloat16PackedMatrixTexture:ki,bindVertexProgramAttributeStreams:Si,uploadDenseMatrixToTexture:Ai,uploadPixelDataToTexture:Di,createBufferFromOutputTexture:Ti,downloadFloat32MatrixFromBuffer:Ni,downloadByteEncodedFloatMatrixFromOutputTexture:Fi,downloadPackedMatrixFromBuffer:_i,downloadMatrixFromPackedOutputTexture:Oi}),n8=function(){function t(g){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];var te=th.getNumber("WEBGL_VERSION");null!=g?(this.gl=g,Kt(te,g)):this.gl=jt(te);var tr="WEBGL_color_buffer_float";if(1===th.getNumber("WEBGL_VERSION")){if(this.textureFloatExtension=re(this.gl,this.debug,"OES_texture_float"),Pe(this.gl,"OES_texture_half_float"))this.textureHalfFloatExtension=re(this.gl,this.debug,"OES_texture_half_float");else if(th.get("WEBGL_FORCE_F16_TEXTURES"))throw Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(tr),Pe(this.gl,"EXT_color_buffer_half_float"))this.colorBufferHalfFloatExtension=re(this.gl,this.debug,"EXT_color_buffer_half_float");else if(th.get("WEBGL_FORCE_F16_TEXTURES"))throw Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(tr="EXT_color_buffer_float",Pe(this.gl,tr))this.colorBufferFloatExtension=this.gl.getExtension(tr);else{if(!Pe(this.gl,"EXT_color_buffer_half_float"))throw Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float")}this.vertexBuffer=xi(this.gl,this.debug),this.indexBuffer=bi(this.gl,this.debug),this.framebuffer=me(this.gl,this.debug),this.textureConfig=Qt(this.gl,this.textureHalfFloatExtension)}return Object.defineProperty(t.prototype,"debug",{get:function(){return th.getBool("DEBUG")},enumerable:!0,configurable:!0}),t.prototype.dispose=function(){var g=this;if(!this.disposed){null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");var te=this.gl;Jt(te,this.debug,function(){return te.finish()}),Jt(te,this.debug,function(){return te.bindFramebuffer(te.FRAMEBUFFER,null)}),Jt(te,this.debug,function(){return te.deleteFramebuffer(g.framebuffer)}),Jt(te,this.debug,function(){return te.bindBuffer(te.ARRAY_BUFFER,null)}),Jt(te,this.debug,function(){return te.bindBuffer(te.ELEMENT_ARRAY_BUFFER,null)}),Jt(te,this.debug,function(){return te.deleteBuffer(g.indexBuffer)}),this.disposed=!0}},t.prototype.createFloat32MatrixTexture=function(g,te){return this.throwIfDisposed(),Ci(this.gl,this.debug,g,te,this.textureConfig)},t.prototype.createFloat16MatrixTexture=function(g,te){return this.throwIfDisposed(),Ei(this.gl,this.debug,g,te,this.textureConfig)},t.prototype.createUnsignedBytesMatrixTexture=function(g,te){return this.throwIfDisposed(),Ri(this.gl,this.debug,g,te,this.textureConfig)},t.prototype.uploadPixelDataToTexture=function(g,te){this.throwIfDisposed(),Di(this.gl,this.debug,g,te)},t.prototype.uploadDenseMatrixToTexture=function(g,te,tr,to){this.throwIfDisposed(),Ai(this.gl,this.debug,g,te,tr,to,this.textureConfig)},t.prototype.createFloat16PackedMatrixTexture=function(g,te){return this.throwIfDisposed(),ki(this.gl,this.debug,g,te,this.textureConfig)},t.prototype.createPackedMatrixTexture=function(g,te){return this.throwIfDisposed(),Ii(this.gl,this.debug,g,te,this.textureConfig)},t.prototype.deleteMatrixTexture=function(g){var te=this;this.throwIfDisposed(),this.outputTexture===g&&(Ee(this.gl,this.debug,this.framebuffer),this.outputTexture=null),Jt(this.gl,this.debug,function(){return te.gl.deleteTexture(g)})},t.prototype.downloadByteEncodedFloatMatrixFromOutputTexture=function(g,te,tr){var to=this;return this.downloadMatrixDriver(g,function(){return Fi(to.gl,to.debug,te,tr,to.textureConfig)})},t.prototype.downloadPackedMatrixFromBuffer=function(g,te,tr,to,tu,tc){return _i(this.gl,g,0,0,0,tu,tc,this.textureConfig)},t.prototype.downloadFloat32MatrixFromBuffer=function(g,te){return Ni(this.gl,g,te)},t.prototype.createBufferFromTexture=function(g,te,tr){this.bindTextureToFrameBuffer(g);var to=Ti(this.gl,this.debug,te,tr,this.textureConfig);return this.unbindTextureToFrameBuffer(),to},t.prototype.createAndWaitForFence=function(){var g=this.createFence(this.gl);return this.pollFence(g)},t.prototype.createFence=function(g){var te,tr,to=this;if(th.getBool("WEBGL_FENCE_API_ENABLED")){var tu=g.fenceSync(g.SYNC_GPU_COMMANDS_COMPLETE,0);g.flush(),tr=function(){var te=g.clientWaitSync(tu,0,0);return te===g.ALREADY_SIGNALED||te===g.CONDITION_SATISFIED},te=tu}else th.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(te=this.beginQuery(),this.endQuery(),tr=function(){return to.isQueryAvailable(te,th.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}):tr=function(){return!0};return{query:te,isFencePassed:tr}},t.prototype.downloadMatrixFromPackedTexture=function(g,te,tr){var to=this;return this.downloadMatrixDriver(g,function(){return Oi(to.gl,to.debug,te,tr)})},t.prototype.createProgram=function(g){this.throwIfDisposed();var te=this.gl,tr=ae(te,this.debug,g),to=yi(te,this.debug),tu=ce(te,this.debug);return Jt(te,this.debug,function(){return te.attachShader(tu,to)}),Jt(te,this.debug,function(){return te.attachShader(tu,tr)}),le(te,this.debug,tu),this.debug&&he(te,this.debug,tu),this.vertexAttrsAreBound||(this.setProgram(tu),this.vertexAttrsAreBound=Si(te,this.debug,this.program,this.vertexBuffer)),tu},t.prototype.deleteProgram=function(g){var te=this;this.throwIfDisposed(),g===this.program&&(this.program=null),null!=g&&Jt(this.gl,this.debug,function(){return te.gl.deleteProgram(g)})},t.prototype.setProgram=function(g){var te=this;this.throwIfDisposed(),this.program=g,null!=this.program&&this.debug&&he(this.gl,this.debug,this.program),Jt(this.gl,this.debug,function(){return te.gl.useProgram(g)})},t.prototype.getUniformLocation=function(g,te,tr){return void 0===tr&&(tr=!0),this.throwIfDisposed(),tr?xe(this.gl,this.debug,g,te):be(this.gl,g,te)},t.prototype.getAttributeLocation=function(g,te){var tr=this;return this.throwIfDisposed(),Jt(this.gl,this.debug,function(){return tr.gl.getAttribLocation(g,te)})},t.prototype.getUniformLocationNoThrow=function(g,te){return this.throwIfDisposed(),this.gl.getUniformLocation(g,te)},t.prototype.setInputMatrixTexture=function(g,te,tr){this.throwIfDisposed(),this.throwIfNoProgram(),we(this.gl,this.debug,this.program,g,te,tr)},t.prototype.setOutputMatrixTexture=function(g,te,tr){this.setOutputMatrixTextureDriver(g,tr,te)},t.prototype.setOutputPackedMatrixTexture=function(g,te,tr){this.throwIfDisposed();var to=$t(te,tr),tu=to[0],tc=to[1];this.setOutputMatrixTextureDriver(g,tu,tc)},t.prototype.setOutputMatrixWriteRegion=function(g,te,tr,to){this.setOutputMatrixWriteRegionDriver(tr,g,to,te)},t.prototype.setOutputPackedMatrixWriteRegion=function(g,te,tr,to){throw Error("setOutputPackedMatrixWriteRegion not implemented.")},t.prototype.debugValidate=function(){null!=this.program&&he(this.gl,this.debug,this.program),Re(this.gl)},t.prototype.executeProgram=function(){this.throwIfDisposed(),this.throwIfNoProgram();var g=this.gl;this.debug&&this.debugValidate(),Jt(g,this.debug,function(){return g.drawElements(g.TRIANGLES,6,g.UNSIGNED_SHORT,0)})},t.prototype.blockUntilAllProgramsCompleted=function(){var g=this;this.throwIfDisposed(),Jt(this.gl,this.debug,function(){return g.gl.finish()})},t.prototype.getQueryTimerExtension=function(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=re(this.gl,this.debug,2===th.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension},t.prototype.getQueryTimerExtensionWebGL2=function(){return this.getQueryTimerExtension()},t.prototype.getQueryTimerExtensionWebGL1=function(){return this.getQueryTimerExtension()},t.prototype.beginQuery=function(){if(2===th.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var g=this.gl,te=this.getQueryTimerExtensionWebGL2(),tr=g.createQuery();return g.beginQuery(te.TIME_ELAPSED_EXT,tr),tr}var to=this.getQueryTimerExtensionWebGL1(),tu=to.createQueryEXT();return to.beginQueryEXT(to.TIME_ELAPSED_EXT,tu),tu},t.prototype.endQuery=function(){if(2!==th.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var g=this.getQueryTimerExtensionWebGL1();g.endQueryEXT(g.TIME_ELAPSED_EXT)}else{var te=this.gl,tr=this.getQueryTimerExtensionWebGL2();te.endQuery(tr.TIME_ELAPSED_EXT)}},t.prototype.waitForQueryAndGetTime=function(g){return n(this,void 0,void 0,function(){var te=this;return r(this,function(tr){switch(tr.label){case 0:return[4,F(function(){return te.disposed||te.isQueryAvailable(g,th.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})];case 1:return tr.sent(),[2,this.getQueryTime(g,th.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))]}})})},t.prototype.getQueryTime=function(g,te){if(0===te)return null;if(2===te){var tr=this.gl;return tr.getQueryParameter(g,tr.QUERY_RESULT)/1e6}var to=this.getQueryTimerExtensionWebGL1();return to.getQueryObjectEXT(g,to.QUERY_RESULT_EXT)/1e6},t.prototype.isQueryAvailable=function(g,te){if(0===te)return!0;if(2===te){var tr=this.gl,to=this.getQueryTimerExtensionWebGL2(),tu=tr.getQueryParameter(g,tr.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(to.GPU_DISJOINT_EXT)),tu&&!this.disjoint}return tu=(to=this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(g,to.QUERY_RESULT_AVAILABLE_EXT),null==this.disjoint&&(this.disjoint=this.gl.getParameter(to.GPU_DISJOINT_EXT)),tu&&!this.disjoint},t.prototype.pollFence=function(g){var te=this;return new Promise(function(tr){te.addItemToPoll(function(){return g.isFencePassed()},function(){return tr()})})},t.prototype.pollItems=function(){for(var g=function(g){for(var te=0;te<g.length&&g[te]();++te);return te-1}(this.itemsToPoll.map(function(g){return g.isDoneFn})),te=0;te<=g;++te)(0,this.itemsToPoll[te].resolveFn)();this.itemsToPoll=this.itemsToPoll.slice(g+1)},t.prototype.addItemToPoll=function(g,te){var tr=this;this.itemsToPoll.push({isDoneFn:g,resolveFn:te}),this.itemsToPoll.length>1||F(function(){return tr.pollItems(),0===tr.itemsToPoll.length})},t.prototype.bindTextureToFrameBuffer=function(g){this.throwIfDisposed(),Ce(this.gl,this.debug,g,this.framebuffer),this.debug&&Re(this.gl)},t.prototype.unbindTextureToFrameBuffer=function(){null!=this.outputTexture?(Ce(this.gl,this.debug,this.outputTexture,this.framebuffer),this.debug&&Re(this.gl)):Ee(this.gl,this.debug,this.framebuffer)},t.prototype.downloadMatrixDriver=function(g,te){this.bindTextureToFrameBuffer(g);var tr=te();return this.unbindTextureToFrameBuffer(),tr},t.prototype.setOutputMatrixTextureDriver=function(g,te,tr){this.throwIfDisposed();var to=this.gl;Ce(to,this.debug,g,this.framebuffer),this.debug&&Re(to),this.outputTexture=g,Jt(to,this.debug,function(){return to.viewport(0,0,te,tr)}),Jt(to,this.debug,function(){return to.scissor(0,0,te,tr)})},t.prototype.setOutputMatrixWriteRegionDriver=function(g,te,tr,to){var tu=this;this.throwIfDisposed(),Jt(this.gl,this.debug,function(){return tu.gl.scissor(g,te,tr,to)})},t.prototype.throwIfDisposed=function(){if(this.disposed)throw Error("Attempted to use disposed GPGPUContext.")},t.prototype.throwIfNoProgram=function(){if(null==this.program)throw Error("No GPU program is currently set.")},t}();function Pi(g,te){if(g.length!==te.length)throw Error("Binary was compiled with "+g.length+" inputs, but was executed with "+te.length+" inputs");g.forEach(function(g,tr){var to=g.logicalShape,tu=te[tr],tc=tu.shape;if(!S(to,tc))throw Error("Binary was compiled with different shapes than the current args. Shapes "+to+" and "+tc+" must match");if(!g.isUniform||!tu.isUniform){var tl=g.texShape,th=tu.isUniform?null:tu.texData.texShape;if(!S(tl,th))throw Error("Binary was compiled with different texture shapes than the current args. Shape "+tl+" and "+th+" must match")}})}var Li=function(g,te,tr){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=g;for(var to=tr.filterWidth,tu=tr.inChannels,tc=tr.strideWidth,tl=tr.strideHeight,th=tr.padInfo,td=tr.outWidth,tf=tr.dilationWidth,tp=tr.dilationHeight,tv=tr.dataFormat,tm=th.left,tg=th.top,ty=tu*to,tx=ua(),tb="channelsLast"===tv,tC=tb?0:1,tw=tb?1:2,tE="",tR=0;tR<=1;tR++)for(var tI=0;tI<=1;tI++)tE+="\n          blockIndex = rc.y + "+tI+";\n          pos = rc.x + "+tR+";\n\n          if(blockIndex < "+g[1]+" && pos < "+g[0]+") {\n            offsetY = int(blockIndex / ("+td+")) * "+tl+" - "+tg+";\n            d0 = offsetY + "+tp+" * (pos / "+ty+");\n\n            if(d0 < "+te[tC]+" && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), "+td+".) * "+tc+". - "+tm+".);\n              d1 = offsetX + "+tf+" * (int(mod(float(pos), "+ty+".) / "+tu+".));\n\n              if(d1 < "+te[tw]+" && d1 >= 0) {\n\n                ch = int(mod(float(pos), "+tu+".));\n\n                if ("+tb+") {\n                  innerDims = vec2(d1, ch);\n                  result["+(2*tR+tI)+"] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result["+(2*tR+tI)+"] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";this.userCode="\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        "+tE+"\n\n        "+tx.output+" = result;\n      }\n    "},Wi=function(g,te,tr,to,tu){this.variableNames=["x"],this.outputShape=[];var tc=g[3]-1;this.outputShape=g;var tl="float("+tr+") + float("+to+") * sum";this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -"+te+"; j <= "+te+"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  "+tc+") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * "+(.5===tu?"inversesqrt("+tl+")":1===tu?"1.0/("+tl+")":"exp(log("+tl+") * float(-"+tu+"));")+";\n        setOutput(val);\n      }\n    "},Ui=function(g,te,tr,to,tu){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=g,this.depth=g[3],this.depthRadius=te,this.bias=tr,this.alpha=to,this.beta=tu,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < "+this.depth+"; ++d) {\n          int depthBegin = int(max(0.0, float(d - "+te+")));\n          int depthEnd = int(min(float("+this.depth+"),\n              float(d + "+te+" + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = "+this.depth+";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float("+to+") * norm + float("+tr+");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float("+to+")\n                * float("+tu+")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * "+tu+");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    "},Vi=function(g,te,tr,to,tu){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;var tc=g[3]-1;this.outputShape=g;var tl="float("+tr+") + float("+to+") * sum";this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < "+this.outputShape[3]+";\n        bool hasNextRow = c < "+this.outputShape[2]+";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - "+te+";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - "+te+"; j <= "+te+"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2("+tc+"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * "+(.5===tu?"inversesqrt("+tl+")":1===tu?"1.0/("+tl+")":"exp(log("+tl+") * float(-"+tu+"));")+";\n        setOutput(result);\n      }\n    "},zi=function(g){this.variableNames=["dy","maxPos"],this.outputShape=g.inShape;var te=g.strideHeight,tr=g.strideWidth,to=g.dilationHeight,tu=g.effectiveFilterHeight,tc=g.effectiveFilterWidth,tl=tu-1-g.padInfo.top,th=tc-1-g.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2("+tl+", "+th+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+tu+";\n          wR += "+to+") {\n          float dyR = float(dyRCorner + wR) / "+te+".0;\n\n          if (dyR < 0.0 || dyR >= "+g.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+tc+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+tr+".0;\n\n            if (dyC < 0.0 || dyC >= "+g.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = "+(tu*tc-1)+" - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * "+tc+" + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Gi=function(g){this.variableNames=["dy","maxPos"],this.outputShape=g.inShape;var te=g.strideDepth,tr=g.strideHeight,to=g.strideWidth,tu=g.dilationDepth,tc=g.dilationHeight,tl=g.dilationWidth,th=g.effectiveFilterDepth,td=g.effectiveFilterHeight,tf=g.effectiveFilterWidth,tp=th-1-g.padInfo.front,tv=td-1-g.padInfo.top,tm=tf-1-g.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3("+tp+", "+tv+", "+tm+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < "+th+";\n           wD += "+tu+") {\n          float dyD = float(dyDCorner + wD) / "+te+".0;\n\n          if (dyD < 0.0 || dyD >= "+g.outDepth+".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < "+td+";\n              wR += "+tc+") {\n            float dyR = float(dyRCorner + wR) / "+tr+".0;\n\n            if (dyR < 0.0 || dyR >= "+g.outHeight+".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < "+tf+";\n                wC += "+tl+") {\n              float dyC = float(dyCCorner + wC) / "+to+".0;\n\n              if (dyC < 0.0 || dyC >= "+g.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = "+(th*td*tf-1)+" -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * "+td+" * "+tf+" +\n                  wR * "+tf+" + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Hi=function(g,te,tr,to,tu,tc,tl){void 0===tr&&(tr=!1),void 0===to&&(to=!1),void 0===tu&&(tu=!1),void 0===tc&&(tc=null),void 0===tl&&(tl=!1),this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=te;var th=Math.ceil((tr?g[1]:g[2])/2),td=tr?"i * 2, rc.y":"rc.y, i * 2",tf=to?"rc.z, i * 2":"i * 2, rc.z",tp=tr?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],tv=to?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],tm="",tg="";tc&&(tm=tl?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          "+tc+"\n        }":"vec4 activation(vec4 x) {\n          "+tc+"\n        }",tg="result = activation(result);");var ty=tu?"result += getBiasAtOutCoords();":"";tu&&this.variableNames.push("bias"),tl&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+tm+"\n\n      const float sharedDimension = "+th+".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < "+th+"; i++) {\n          vec4 a = getMatrixA(rc.x, "+td+");\n          vec4 b = getMatrixB(rc.x, "+tf+");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += ("+tp[0]+" * "+tv[0]+");\n          result += ("+tp[1]+" * "+tv[1]+");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        "+ty+"\n\n        "+tg+"\n\n        setOutput(result);\n      }\n    "},n7=function(){function t(g,te,tr){this.variableNames=["probs"],this.outputShape=[g,tr],this.userCode="\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < "+(te-1)+"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float("+(te-1)+"));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(g){var te=this;return function(tr,to){null==te.seedLoc&&(te.seedLoc=tr.getUniformLocation(to,"seed")),tr.gl.uniform1f(te.seedLoc,g)}},t}(),Ki=function(g,te,tr,to){this.variableNames=["indices"],this.outputShape=[g,te],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float("+to+"), float("+tr+"),\n                      float(index == coords.y)));\n      }\n    "},ji=function(g){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=g;var te=g.length;if(0===te)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{var tr,to,tu=sa("rc",te),tc=wa(te),tl=function(g,te,tr){if(1===g)return"rc > "+te[0];for(var to="",tu=g-2;tu<g;tu++)to+=tr[tu]+" >= "+te[tu],tu<g-1&&(to+="||");return to}(te,g,tu),th=function(g,te,tr,to){if(1===g)return"";var tu=to.slice(-2);return"\n    int r = "+tu[0]+";\n    int c = "+tu[1]+";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= "+te+";\n    bool rEdge = rp1 >= "+tr+";\n  "}(te,g[g.length-1],g[g.length-2],tu),td=(to=function(g,te){for(var tr=[],to=0;to<=1;to++)for(var tu=0;tu<=1;tu++){for(var tc=(0===to?"r":"rp1")+", "+(0===tu?"c":"cp1"),tl=2;tl<g;tl++)tc=te[te.length-1-tl]+","+tc;tr.push(tc)}return tr}(tr=g.length,tu),1===tr?"getA(rc),\n            rc + 1 >= "+g[0]+" ? 0. : getA(rc + 1),\n            0, 0":"getA("+to[0]+"),\n          cEdge ? 0. : getA("+to[1]+"),\n          rEdge ? 0. : getA("+to[2]+"),\n          rEdge || cEdge ? 0. : getA("+to[3]+")");this.userCode="\n        void main() {\n          "+tc+" rc = getOutputCoords();\n\n          if("+tl+") {\n            setOutput(vec4(0));\n          } else {\n            "+th+"\n\n            setOutput(vec4("+td+"));\n          }\n        }\n      "}},Xi=function(g,te,tr){this.variableNames=["x"],this.outputShape=te.map(function(te,tr){return te[0]+g[tr]+te[1]});var to=g.length,tu=wa(to),tc=te.map(function(g){return g[0]}).join(","),tl=te.map(function(te,tr){return te[0]+g[tr]}).join(","),th=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,to);this.userCode=1!==to?"\n      "+tu+" start = "+tu+"("+tc+");\n      "+tu+" end = "+tu+"("+tl+");\n\n      void main() {\n        "+tu+" outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float("+tr+"));\n        } else {\n          "+tu+" coords = outC - start;\n          setOutput(getX("+th+"));\n        }\n      }\n    ":"\n        int start = "+tc+";\n        int end = "+tl+";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float("+tr+"));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      "},Yi=function(g,te,tr){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=te.map(function(te,tr){return te[0]+g[tr]+te[1]});for(var to=g.length,tu=wa(to),tc=te.map(function(g){return g[0]}).join(","),tl=te.map(function(te,tr){return te[0]+g[tr]}).join(","),th=sa("rc",to),td=sa("source",to),tf=th[to-1]+" < "+this.outputShape[to-1],tp=1===to?"source":"vec2("+td.slice(-2).join()+")",tv=[tu+" rc = outputLoc;",th[to-1]+" += 1;\n       if("+tf+") {\n      ",1===to?"":"}\n       rc = outputLoc;\n       "+th[to-2]+" += 1;\n       if("+th[to-2]+" < "+this.outputShape[to-2]+") {",1===to?"":"  "+th[to-1]+" += 1;\n         if("+tf+") {"],tm=1===to?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",tg="",ty=0,tx=1===to?2:4;ty<tx;ty++)tg+="\n        "+tv[ty]+"\n        if ("+tm+") {\n          result["+ty+"] = float("+tr+");\n        } else {\n          "+tu+" source = rc - start;\n          result["+ty+"] = getChannel(getX("+td.join()+"), "+tp+");\n        }\n      ";tg+=1===to?"} ":"}}",this.userCode="\n      const "+tu+" start = "+tu+"("+tc+");\n      const "+tu+" end = "+tu+"("+tl+");\n\n      void main() {\n        "+tu+" outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        "+tg+"\n        setOutput(result);\n      }\n    "},$i=function(g,te,tr){if(this.variableNames=["x"],"avg"===te&&tr)throw Error("Cannot compute positions for average pool.");var to=g.filterWidth,tu=g.strideHeight,tc=g.strideWidth,tl=g.dilationHeight,th=g.dilationWidth,td=g.effectiveFilterHeight,tf=g.effectiveFilterWidth,tp=g.padInfo.top,tv=g.padInfo.left;this.outputShape=g.outShape;var tm="avg"===te,tg="0.0";if(tm||(tg="-1.0 / 1e-20"),tr)this.userCode="\n        const ivec2 strides = ivec2("+tu+", "+tc+");\n        const ivec2 pads = ivec2("+tp+", "+tv+");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < "+td+";\n              wR += "+tl+") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+g.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+tf+";\n                wC += "+th+") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= "+g.inWidth+") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * "+tf+" + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";else{var ty=te+"("+te+"("+te+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===te&&(ty="avgValue / count");var tx=4*Math.floor(to/4),tb=to%4,tC="\n      if ("+tm+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";this.userCode="\n      const ivec2 strides = ivec2("+tu+", "+tc+");\n      const ivec2 pads = ivec2("+tp+", "+tv+");\n      const float initializationValue = "+tg+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= "+g.inWidth+") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+tg+");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < "+td+";\n            wR += "+tl+") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= "+g.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+tx+"; wC += 4) {\n            int xC = xCCorner + wC * "+th+";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+th+", d),\n              getValue(batch, xR, xC + 2 * "+th+", d),\n              getValue(batch, xR, xC + 3 * "+th+", d)\n            );\n\n            "+tC+"\n          }\n\n          int xC = xCCorner + "+tx+";\n          if ("+(1===tb)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            "+tC+"\n          } else if ("+(2===tb)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+th+", d),\n              initializationValue,\n              initializationValue\n            );\n\n            "+tC+"\n          } else if ("+(3===tb)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+th+", d),\n              getValue(batch, xR, xC + 2 * "+th+", d),\n              initializationValue\n            );\n\n            "+tC+"\n          }\n        }\n        setOutput("+ty+");\n      }\n    "}},Qi=function(g,te,tr){if(this.variableNames=["x"],"avg"===te&&tr)throw Error("Cannot compute positions for average pool.");var to=g.filterWidth,tu=g.strideDepth,tc=g.strideHeight,tl=g.strideWidth,th=g.dilationDepth,td=g.dilationHeight,tf=g.dilationWidth,tp=g.effectiveFilterDepth,tv=g.effectiveFilterHeight,tm=g.effectiveFilterWidth,tg=g.padInfo.front,ty=g.padInfo.top,tx=g.padInfo.left;this.outputShape=g.outShape;var tb="avg"===te,tC="0.0";if(tb||(tC="-1.0 / 1e-20"),tr)this.userCode="\n        const ivec3 strides =\n            ivec3("+tu+", "+tc+", "+tl+");\n        const ivec3 pads = ivec3("+tg+", "+ty+", "+tx+");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < "+tp+";\n              wD += "+th+") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= "+g.inDepth+") {\n              continue;\n            }\n\n            for (int wR = 0; wR < "+tv+";\n                wR += "+td+") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= "+g.inHeight+") {\n                continue;\n              }\n\n              for (int wC = 0; wC < "+tm+";\n                  wC += "+tf+") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= "+g.inWidth+") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition =\n                      wD * "+tv+" * "+tm+" +\n                      wR * "+tm+" + wC;;\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";else{var tw=te+"("+te+"("+te+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===te&&(tw="avgValue / count");var tE=4*Math.floor(to/4),tR=to%4,tI="\n      if ("+tb+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";this.userCode="\n      const ivec3 strides =\n        ivec3("+tu+", "+tc+", "+tl+");\n      const ivec3 pads = ivec3("+tg+", "+ty+", "+tx+");\n      const float initializationValue = "+tC+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= "+g.inWidth+") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+tC+");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < "+tp+";\n            wD += "+th+") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= "+g.inDepth+") {\n            continue;\n          }\n\n          for (int wR = 0; wR < "+tv+";\n            wR += "+td+") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+g.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+tE+"; wC += 4) {\n              int xC = xCCorner + wC * "+tf+";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+tf+", ch),\n                getValue(batch, xD, xR, xC + 2 * "+tf+", ch),\n                getValue(batch, xD, xR, xC + 3 * "+tf+", ch)\n              );\n\n              "+tI+"\n            }\n\n            int xC = xCCorner + "+tE+";\n            if ("+(1===tR)+") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              "+tI+"\n            } else if ("+(2===tR)+") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+tf+", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              "+tI+"\n            } else if ("+(3===tR)+") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+tf+", ch),\n                getValue(batch, xD, xR, xC + 2 * "+tf+", ch),\n                initializationValue\n              );\n\n              "+tI+"\n            }\n          }\n          setOutput("+tw+");\n        }\n      }\n    "}},Ji=function(g,te){this.variableNames=["x"];var tr=g.windowSize,to=g.batchSize,tu=g.inSize,tc=Math.ceil(tu/tr);this.outputShape=[to,tc];var tl="0.0",th="";"prod"===te?tl="1.0":"min"===te?(tl="1.0 / 1e-20",th="min"):"max"===te&&(tl="-1.0 / 1e-20",th="max");var td=te+"("+te+"("+te+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===te?td="sumValue":"prod"===te?td="prodValue":"all"===te?td="allValue":"any"===te&&(td="anyValue");var tf=4*Math.floor(tr/4),tp=tr%4,tv="\n      if ("+("sum"===te)+") {\n        sumValue += dot(values, ones);\n      } else if ("+("prod"===te)+") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = "+th+"(values, minMaxValue);\n      }\n    ",tm="vec4";"all"===te?(tl="1.0",tv="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",tm="bvec4"):"any"===te&&(tl="0.0",tv="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",tm="bvec4");var tg="";tu%tr>0&&(tg="\n        if (inIdx < 0 || inIdx >= "+tu+") {\n          return initializationValue;\n        }\n      "),this.userCode="\n      const float initializationValue = "+tl+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        "+tg+"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+tr+";\n\n        vec4 minMaxValue = vec4("+tl+");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < "+tf+"; i += 4) {\n          int inIdx = inOffset + i;\n          "+tm+" values = "+tm+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          "+tv+"\n        }\n\n        int inIdx = inOffset + "+tf+";\n        if ("+(1===tp)+") {\n          "+tm+" values = "+tm+"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          "+tv+"\n        } else if ("+(2===tp)+") {\n          "+tm+" values = "+tm+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          "+tv+"\n        } else if ("+(3===tp)+") {\n          "+tm+" values = "+tm+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          "+tv+"\n        }\n        setOutput("+td+");\n      }\n    "},Zi=function(g,te){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=g;for(var tr="",to=0;to<4;to++){var tu="thisRC = rc;";to%2==1&&(tu+="thisRC.z += 1;"),to>1&&(tu+="thisRC.y += 1;"),tr+="\n        "+tu+"\n        "+(to>0?"if(thisRC.y < rows && thisRC.z < cols){":"")+"\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result["+to+"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        "+(to>0?"}":"")+"\n      "}this.userCode="\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      "+ca(["r","c","d"],te)+"\n      return ivec3(r, c, d);\n    }\n  \n      "+la(g)+"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = "+g[1]+";\n        int cols = "+g[2]+";\n\n        "+tr+"\n\n        setOutput(result);\n      }\n    "},ts=function(g,te,tr){this.variableNames=["dy"],this.outputShape=[],this.outputShape=te.shape;var to=te.shape,tu=to[1],tc=to[2],tl=g.shape,th=tl[1],td=tl[2],tf=[tr&&th>1?tu-1:tu,tr&&td>1?tc-1:tc],tp=[tr&&th>1?th-1:th,tr&&td>1?td-1:td],tv=tf[0]/tp[0],tm=tf[1]/tp[1],tg=1/tv,ty=1/tm,tx=2*Math.ceil(tg)+2,tb=2*Math.ceil(ty)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+tv+");\n        const float widthScale = float("+tm+");\n\n        const float invHeightScale = float("+tg+");\n        const float invWidthScale = float("+ty+");\n\n        const int winHeight = int("+tx+");\n        const int winWidth = int("+tb+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+th+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+td+") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), "+(tu-1)+".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), "+(tc-1)+".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "},es=function(g,te,tr,to){this.variableNames=["A"],this.outputShape=[];var tu=g[0],tc=g[1],tl=g[2],th=g[3];this.outputShape=[tu,te,tr,th];var td=[to&&te>1?tc-1:tc,to&&tr>1?tl-1:tl],tf=[to&&te>1?te-1:te,to&&tr>1?tr-1:tr];this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+td[0]/tf[0]+",\n          "+td[1]/tf[1]+");\n      const vec2 inputShapeRC = vec2("+tc+".0, "+tl+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    "},ns=function(g,te,tr,to){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];var tu=g[0],tc=g[1],tl=g[2],th=g[3];this.outputShape=[tu,te,tr,th];var td=[to&&te>1?tc-1:tc,to&&tr>1?tl-1:tl],tf=[to&&te>1?te-1:te,to&&tr>1?tr-1:tr];this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          "+td[0]/tf[0]+",\n          "+td[1]/tf[1]+",\n          "+td[1]/tf[1]+");\n      const vec3 inputShapeRC = vec3("+tc+".0, "+tl+".0,\n                                     "+tl+".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < "+(th-1)+";\n        bool hasNextRow = coords.z < "+(tr-1)+";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    "},rs=function(g,te,tr){this.variableNames=["dy"],this.outputShape=[],this.outputShape=te.shape;var to=te.shape,tu=to[1],tc=to[2],tl=g.shape,th=tl[1],td=tl[2],tf=[tr&&th>1?tu-1:tu,tr&&td>1?tc-1:tc],tp=[tr&&th>1?th-1:th,tr&&td>1?td-1:td],tv=tf[0]/tp[0],tm=tf[1]/tp[1],tg=1/tv,ty=1/tm,tx=2*Math.ceil(tg)+2,tb=2*Math.ceil(ty)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+tv+");\n        const float widthScale = float("+tm+");\n\n        const float invHeightScale = float("+tg+");\n        const float invWidthScale = float("+ty+");\n\n        const int winHeight = int("+tx+");\n        const int winWidth = int("+tb+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+th+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+td+") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float("+tf[0]+") *\n                (float(dyR) / float("+tp[0]+"));\n\n            float sourceFracCol =\n                float("+tf[1]+") *\n                  (float(dyC) / float("+tp[1]+"));\n\n            int sourceNearestRow = int(min(\n                float(int("+tu+") - 1),\n                "+tr+" ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int("+tc+") - 1),\n                "+tr+" ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "},os=function(g,te,tr,to){this.variableNames=["A"],this.outputShape=[];var tu=g[0],tc=g[1],tl=g[2],th=g[3];this.outputShape=[tu,te,tr,th];var td=[to&&te>1?tc-1:tc,to&&tr>1?tl-1:tl],tf=[to&&te>1?te-1:te,to&&tr>1?tr-1:tr];this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+td[0]/tf[0]+",\n          "+td[1]/tf[1]+");\n      const vec2 inputShapeRC = vec2("+tc+".0, "+tl+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + "+(to?"0.5":"0.0")+")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    "},as=function(g,te){this.variableNames=["x"];var tr=g.length;if(tr>4)throw Error("WebGL backend: Reverse of rank-"+tr+" tensor is not yet supported");if(this.outputShape=g,1!==tr){var to=g.map(function(tr,to){return -1!==te.indexOf(to)&&1!==g[to]?g[to]+" - coords["+to+"] - 1":"coords["+to+"]"}).join(","),tu=wa(tr);this.userCode="\n      void main() {\n        "+tu+" coords = getOutputCoords();\n        setOutput(getX("+to+"));\n      }\n    "}else this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX("+g[0]+" - coord - 1));\n        }\n      "},is=function(g,te){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;var tr,to,tu,tc=g.length;if(tc>4)throw Error("WebGL backend: Reverse of rank-"+tc+" tensor is not yet supported");this.outputShape=g;var tl=sa("rc",tc),th=tl[tc-1]+" + 1 < "+this.outputShape[tc-1],td=tl[tc-2]+" + 1 < "+this.outputShape[tc-2],tf=wa(tc);function s(tr){var to=g.map(function(to,tu){return -1!==te.indexOf(tu)&&1!==g[tu]?g[tu]+" - "+tr[tu]+" - 1":""+tr[tu]});return"getChannel(getX("+to.join(",")+"), vec2("+to.slice(-2).join(",")+"))"}this.userCode=1===tc?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX("+g[0]+" - rc - 1),\n            "+g[0]+" - rc - 1);\n          if("+th+"){\n              result.g = getChannel(getX("+g[0]+" - (rc  + 1) - 1),\n                "+g[0]+" - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      ":"\n        void main() {\n          "+tf+" rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = "+s(tl.slice())+";\n          if("+th+"){\n            result.g = "+((tr=tl.slice())[tc-1]="("+tr[tc-1]+" + 1)",s(tr))+";\n          }\n          if("+td+") {\n            result.b = "+((to=tl.slice())[tc-2]="("+to[tc-2]+" + 1)",s(to))+";\n            if("+th+") {\n              result.a = "+((tu=tl.slice())[tc-1]="("+tu[tc-1]+" + 1)",tu[tc-2]="("+tu[tc-2]+" + 1)",s(tu))+";\n            }\n          }\n          setOutput(result);\n        }\n    "},ss=function(g,te,tr,to,tu,tc,tl){void 0===tl&&(tl=!0),this.variableNames=["updates","indices","defaultValue"],this.outputShape=tc;var th=wa(tu.length),td=wa(tc.length),tf="";1===tr?tf="i":2===tr&&(tf="i, j");var tp="getIndices("+tf+")",tv="";1===to?tv="i":2===to&&(tv="i, coords[1]");var tm="getUpdates("+tv+")";this.userCode="\n        "+th+" strides = "+th+"("+tu+");\n\n        void main() {\n          "+td+" coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < "+g+"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < "+te+"; j++) {\n              int index = round("+tp+");\n              flattenedIndex += index * "+(te>1?"strides[j]":"strides")+";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += "+tm+";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      "},us=function(g,te){this.variableNames=["x","segmentIds"];var tr=g.windowSize,to=g.batchSize,tu=g.inSize,tc=g.numSegments,tl=tc*Math.ceil(tu/tr);this.outputShape=[to,tl];var th=4*Math.floor(tr/4),td=tr%4,tf="\n        sumValue += dot(values, segFilter);\n    ",tp="";tu%tr>0&&(tp="\n        if (inIdx < 0 || inIdx >= "+tu+") {\n          return initializationValue;\n        }\n      ");var tv="";tu%tr>0&&(tv="\n        if (inIdx < 0 || inIdx >= "+tu+") {\n          return -1.0;\n        }\n      "),this.userCode="\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        "+tp+"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        "+tv+"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          "+tc+")) * float("+tr+"));\n        int currentSeg = int(mod(float(outIdx), float("+tc+")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < "+th+"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          "+tf+"\n        }\n\n        int inIdx = inOffset + "+th+";\n        if ("+(1===td)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          "+tf+"\n        } else if ("+(2===td)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          "+tf+"\n        } else if ("+(3===td)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          "+tf+"\n        }\n        setOutput(sumValue);\n      }\n    "},cs=function(g,te,tr){if(this.variableNames=["c","a","b"],this.outputShape=te,tr>4)throw Error("Where for rank "+tr+" is not yet supported");if(1===tr)tu="resRC",to="resRC";else{for(var to,tu,tc=["resRC.x","resRC.y","resRC.z","resRC.w"],tl=[],th=[],td=0;td<te.length;td++)th.push(""+tc[td]),td<g&&tl.push(""+tc[td]);to=tl.join(),tu=th.join()}var tf=wa(tr);this.userCode="\n      void main() {\n        "+tf+" resRC = getOutputCoords();\n        float cVal = getC("+to+");\n        if (cVal >= 1.0) {\n          setOutput(getA("+tu+"));\n        } else {\n          setOutput(getB("+tu+"));\n        }\n      }\n    "},n9=function(){function t(g){this.variableNames=["source"],this.outputShape=g,this.rank=g.length;var te,tr=wa(this.rank),to="uniform int start["+this.rank+"];",tu=function(g){if(1===g)return"sourceLoc";if(g<=6)return eu.slice(0,g).map(function(g){return"sourceLoc."+g}).join(",");throw Error("Slicing for rank "+g+" is not yet supported")}(this.rank);te="\n        "+tr+" sourceLoc;\n        "+tr+" coords = getOutputCoords();\n        "+g.map(function(g,te){return"sourceLoc."+eu[te]+" = start["+te+"] + coords."+eu[te]+";"}).join("\n")+"\n      ",this.userCode="\n      "+to+"\n      void main() {\n        "+te+"\n        setOutput(getSource("+tu+"));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(g){var te=this;if(g.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+g.length+")");return function(tr,to){null==te.startLoc&&(te.startLoc=tr.getUniformLocationNoThrow(to,"start"),null==te.startLoc)||tr.gl.uniform1iv(te.startLoc,g)}},t}(),eu=["x","y","z","w","u","v"],ec=function(){function t(g){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=g,this.rank=g.length;var te=wa(this.rank),tr=sa("coords",this.rank),to=sa("sourceLoc",this.rank),tu=1===this.rank?"sourceLoc":"vec2("+to.slice(-2).join()+")",tc="getChannel(getSource("+to.join()+"), "+tu+")",tl="\n      result.x = "+tc+";\n      if (++"+tr[this.rank-1]+" < "+g[this.rank-1]+") {\n        ++"+to[this.rank-1]+";\n        result.y = "+tc+";\n        --"+to[this.rank-1]+";\n      }\n    ",th=1===this.rank?"":"\n      --"+tr[this.rank-1]+";\n      if (++"+tr[this.rank-2]+" < "+g[this.rank-2]+") {\n        ++"+to[this.rank-2]+";\n        result.z = "+tc+";\n        if (++"+tr[this.rank-1]+" < "+g[this.rank-1]+") {\n          ++"+to[this.rank-1]+";\n          result.w = "+tc+";\n        }\n      }\n    ",td=this.rank<=4?"sourceLoc = coords +\n            "+te+"("+g.map(function(g,te){return"start["+te+"]"}).join()+");":g.map(function(g,te){return to[te]+" = "+tr[te]+" + start["+te+"];"}).join("\n");this.userCode="\n      uniform int start["+this.rank+"];\n      void main() {\n        "+te+" coords = getOutputCoords();\n        "+te+" sourceLoc;\n        "+td+"\n        vec4 result = vec4(0.);\n        "+tl+"\n        "+th+"\n        setOutput(result);\n      }\n    "}return t.prototype.getCustomSetupFunc=function(g){var te=this;if(g.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+g.length+")");return function(tr,to){null==te.startLoc&&(te.startLoc=tr.getUniformLocationNoThrow(to,"start"),null==te.startLoc)||tr.gl.uniform1iv(te.startLoc,g)}},t}(),ds=function(g,te,tr){this.variableNames=["x"],this.outputShape=tr;var to=tr.length,tu=wa(tr.length),tc=wa(tr.length),tl="";if(1===to)tl="coords * strides + begin";else{var th=0;tl=tr.map(function(g,te){return th++,1===tr.length?"coords * strides["+te+"] + begin["+te+"]":"coords["+(th-1)+"] * strides["+te+"] + begin["+te+"]"}).join(",")}this.userCode="\n      "+tu+" begin = "+tu+"("+g+");\n      "+tu+" strides = "+tu+"("+te+");\n\n      void main() {\n        "+tc+" coords = getOutputCoords();\n        setOutput(getX("+tl+"));\n      }\n    "},el=function(){function t(g){this.gpgpu=g,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}return t.prototype.acquireTexture=function(g,te,tr){var to,tu=vs(te,tr),tc=ms(g,tu,tr);if(tc in this.freeTextures||(this.freeTextures[tc]=[]),tc in this.usedTextures||(this.usedTextures[tc]=[]),this.freeTextures[tc].length>0){this.numFreeTextures--,this.numUsedTextures++,this.log();var tl=this.freeTextures[tc].shift();return this.usedTextures[tc].push(tl),tl}return this.numUsedTextures++,this.log(),tu===tV.PACKED_2X2_FLOAT32?to=this.gpgpu.createPackedMatrixTexture(g[0],g[1]):tu===tV.PACKED_2X2_FLOAT16?to=this.gpgpu.createFloat16PackedMatrixTexture(g[0],g[1]):tu===tV.UNPACKED_FLOAT32?to=this.gpgpu.createFloat32MatrixTexture(g[0],g[1]):tu===tV.UNPACKED_FLOAT16?to=this.gpgpu.createFloat16MatrixTexture(g[0],g[1]):tu===tV.PACKED_4X1_UNSIGNED_BYTE&&(to=this.gpgpu.createUnsignedBytesMatrixTexture(g[0],g[1])),this.usedTextures[tc].push(to),to},t.prototype.releaseTexture=function(g,te,tr,to){if(null!=this.freeTextures){var tu=ms(te,vs(tr,to),to);tu in this.freeTextures||(this.freeTextures[tu]=[]),this.freeTextures[tu].push(g),this.numFreeTextures++,this.numUsedTextures--;var tc=this.usedTextures[tu],tl=tc.indexOf(g);if(tl<0)throw Error("Cannot release a texture that was never provided by this texture manager");tc.splice(tl,1),this.log()}},t.prototype.log=function(){if(this.logEnabled){var g=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",this.numFreeTextures+" / "+this.numUsedTextures,"("+g+")")}},t.prototype.getNumUsedTextures=function(){return this.numUsedTextures},t.prototype.getNumFreeTextures=function(){return this.numFreeTextures},t.prototype.dispose=function(){var g=this;if(null!=this.freeTextures){for(var te in this.freeTextures)this.freeTextures[te].forEach(function(te){g.gpgpu.deleteMatrixTexture(te)});for(var te in this.usedTextures)this.usedTextures[te].forEach(function(te){g.gpgpu.deleteMatrixTexture(te)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0}},t}();function vs(g,te){if(g===tW.UPLOAD)return tV.PACKED_2X2_FLOAT32;if(g===tW.RENDER||null==g)return th.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?te?tV.PACKED_2X2_FLOAT32:tV.UNPACKED_FLOAT32:te?tV.PACKED_2X2_FLOAT16:tV.UNPACKED_FLOAT16;if(g===tW.DOWNLOAD||g===tW.PIXELS)return tV.PACKED_4X1_UNSIGNED_BYTE;throw Error("Unknown logical texture type "+g)}function ms(g,te,tr){return g[0]+"_"+g[1]+"_"+te+"_"+tr}var gs=function(g,te){this.variableNames=["A"];for(var tr=Array(g.length),to=0;to<tr.length;to++)tr[to]=g[to]*te[to];this.outputShape=tr,this.rank=tr.length;var tu=wa(this.rank),tc=function(g){var te=g.length;if(te>5)throw Error("Tile for rank "+te+" is not yet supported");if(1===te)return"imod(resRC, "+g[0]+")";for(var tr=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],to=[],tu=0;tu<g.length;tu++)to.push("imod("+tr[tu]+", "+g[tu]+")");return to.join()}(g);this.userCode="\n      void main() {\n        "+tu+" resRC = getOutputCoords();\n        setOutput(getA("+tc+"));\n      }\n    "},ys=function(g,te){this.variableNames=["A"];for(var tr=Array(g.length),to=0;to<tr.length;to++)tr[to]=g[te[to]];this.outputShape=tr,this.rank=tr.length;var tu=wa(this.rank),tc=function(g){var te=g.length;if(te>6)throw Error("Transpose for rank "+te+" is not yet supported");for(var tr=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],to=Array(te),tu=0;tu<g.length;tu++)to[g[tu]]=tr[tu];return to.join()}(te);this.userCode="\n    void main() {\n      "+tu+" resRC = getOutputCoords();\n      setOutput(getA("+tc+"));\n    }\n    "},xs=function(g,te){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;for(var tr=Array(g.length),to=0;to<tr.length;to++)tr[to]=g[te[to]];if(this.outputShape=tr,this.rank=tr.length,this.rank>6)throw Error("Packed transpose for rank "+this.rank+" is not yet supported.");var tu=wa(this.rank),tc=ia("rc",this.rank),tl=Array(this.rank);for(to=0;to<te.length;to++)tl[te[to]]=tc[to];var th="vec2("+tl.slice(-2).join()+")",td="++"+tc[this.rank-1]+" < "+tr[this.rank-1],tf="getChannel(getA("+tl.join()+"), "+th+")";this.userCode="\n    void main() {\n      "+tu+" rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = "+tf+";\n      if("+td+") {\n        result[1] = "+tf+";\n      }\n      --"+tc[this.rank-1]+";\n      if(++"+tc[this.rank-2]+" < "+tr[this.rank-2]+") {\n        result[2] = "+tf+";\n        if("+td+") {\n          result[3] = "+tf+";\n        }\n      }\n      setOutput(result);\n    }\n    "},Cs=function(g,te){this.variableNames=["A"],this.outputShape=g,this.userCode="\n      float unaryOperation(float x) {\n        "+te+"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "},eh="if (isnan(x)) return x;",ed="return abs(x);",ef=eh+"\n  return (x < 0.0) ? 0.0 : x;\n",ep=eh+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",ev="return (x >= 0.0) ? x : (exp(x) - 1.0);",em="return -x;",eg="return ceil(x);",ey="return floor(x);",ex="return exp(x);",eb="return exp(x) - 1.0;",eC=eh+"\n  return sin(x);\n",ew=eh+"\n  return cos(x);\n",eE=eh+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n",eR=eh+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n",eI=eh+"\n  return atan(x);\n",ek=eh+"return log(x + sqrt(x * x + 1.0));",eA=eh+"\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));",eS=eh+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;",eD="return x;",eN="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",eT="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",eF="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",Xs=function(g,te){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=g,this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        "+te+"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "},Ys=function(g){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=g;var te=g.length,tr=sa("rc",te),to=wa(te),tu=function(g,te){if(1===g)return"rc";for(var tr="",to=0;to<g;to++)tr+=te[to],to<g-1&&(tr+=",");return tr}(te,tr),tc=tr.slice(-2),tl=te<=1?"rc":"vec2("+tc.join(",")+")";this.userCode="\n      void main() {\n        "+to+" rc = getOutputCoords();\n        vec4 packedInput = getA("+tu+");\n\n        setOutput(getChannel(packedInput, "+tl+"));\n      }\n    "},eO={};function Qs(g,te){if(void 0===te&&(te=!1),"linear"===g)return"return x;";if("relu"===g)return te?eN:ef;if("elu"===g)return te?eF:ev;if("relu6"===g)return te?eT:ep;if("prelu"===g)return te?n1:n0;throw Error("Activation "+g+" has not been implemented for the WebGL backend.")}var e_=function(g){function o(te){var tr,to=g.call(this)||this;if(to.pendingRead=new WeakMap,to.pendingDisposal=new WeakSet,to.dataRefCount=new WeakMap,to.numBytesInGPU=0,to.uploadWaitMs=0,to.downloadWaitMs=0,to.warnedAboutMemory=!1,to.pendingDeletes=0,to.disposed=!1,!th.getBool("HAS_WEBGL"))throw Error("WebGL is not supported on this device");if(null==te){var tu=jt(th.getNumber("WEBGL_VERSION"));to.binaryCache=((tr=th.getNumber("WEBGL_VERSION"))in eO||(eO[tr]={}),eO[tr]),to.gpgpu=new n8(tu),to.canvas=tu.canvas,to.gpgpuCreatedLocally=!0}else to.gpgpu=te,to.binaryCache={},to.gpgpuCreatedLocally=!1,to.canvas=te.gl.canvas;return to.textureManager=new el(to.gpgpu),to.numMBBeforeWarning=null==th.global.screen?1024:th.global.screen.height*th.global.screen.width*window.devicePixelRatio*600/1024/1024,to.texData=new nG(to,tB),to}return e(o,g),o.prototype.numDataIds=function(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes},o.prototype.write=function(g,te,tr){if(th.getBool("DEBUG")&&this.checkNumericalProblems(g),"complex64"===tr&&null!=g)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");var to={};return this.texData.set(to,{shape:te,dtype:tr,values:g,usage:tW.UPLOAD}),to},o.prototype.move=function(g,te,tr,to){if(th.getBool("DEBUG")&&this.checkNumericalProblems(te),"complex64"===to)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(g,{shape:tr,dtype:to,values:te,usage:tW.UPLOAD})},o.prototype.readSync=function(g){var te=this.texData.get(g),tr=te.values,to=te.dtype,tu=te.complexTensors,tc=te.slice,tl=te.shape,th=te.isPacked;if(null!=tc){var td=void 0;td=th?new Xs(tl,eD):new Cs(tl,eD);var tf=this.runWebGLProgram(td,[{dataId:g,shape:tl,dtype:to}],to),tp=this.readSync(tf.dataId);return this.disposeData(tf.dataId),tp}if(null!=tr)return this.convertAndCacheOnCPU(g);if("string"===to)return tr;var tv,tm,tg=null!=this.activeTimers;return tg&&(tv=et()),tm="complex64"===to?Vo(tu.real.dataSync(),tu.imag.dataSync()):this.getValuesFromTexture(g),tg&&(this.downloadWaitMs+=et()-tv),this.convertAndCacheOnCPU(g,tm)},o.prototype.read=function(g){return n(this,void 0,void 0,function(){var te,tr,to,tu,tc,tl,td,tf,tp,tv,tm,tg,ty,tx,tb,tC,tw,tE,tR,tI;return r(this,function(tk){switch(tk.label){case 0:if(this.pendingRead.has(g))return te=this.pendingRead.get(g),[2,new Promise(function(g){return te.push(g)})];if(to=(tr=this.texData.get(g)).values,tu=tr.shape,tc=tr.slice,tl=tr.dtype,td=tr.complexTensors,tf=tr.isPacked,null!=tc)return tp=void 0,tp=tf?new Xs(tu,eD):new Cs(tu,eD),tv=this.runWebGLProgram(tp,[{dataId:g,shape:tu,dtype:tl}],tl),tm=this.read(tv.dataId),this.disposeData(tv.dataId),[2,tm];if(null!=to)return[2,this.convertAndCacheOnCPU(g)];if(!th.getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===th.getNumber("WEBGL_VERSION"))throw Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");return tg=null,"complex64"!==tl&&th.get("WEBGL_BUFFER_SUPPORTED")&&(ty=this.decode(g),tx=this.texData.get(ty.dataId),tg=(tI=this.gpgpu).createBufferFromTexture.apply(tI,[tx.texture].concat(Yt(tu)))),this.pendingRead.set(g,[]),"complex64"===tl?[3,2]:[4,this.gpgpu.createAndWaitForFence()];case 1:tk.sent(),tk.label=2;case 2:return"complex64"!==tl?[3,4]:[4,Promise.all([td.real.data(),td.imag.data()])];case 3:return tb=Vo((tC=tk.sent())[0],tC[1]),[3,5];case 4:null==tg?tb=this.getValuesFromTexture(g):(tw=k(tu),tb=this.gpgpu.downloadFloat32MatrixFromBuffer(tg,tw)),tk.label=5;case 5:return null!=ty&&this.disposeData(ty.dataId),tE=this.convertAndCacheOnCPU(g,tb),tR=this.pendingRead.get(g),this.pendingRead.delete(g),tR.forEach(function(g){return g(tE)}),this.pendingDisposal.has(g)&&(this.pendingDisposal.delete(g),this.disposeData(g),this.pendingDeletes--),[2,tE]}})})},o.prototype.checkNumericalProblems=function(g){if(null!=g)for(var te=0;te<g.length;te++){var tr=g[te];if(!ee(tr)){if(th.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value "+tr+" cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value "+tr+" cannot be represented on this device.")}}},o.prototype.getValuesFromTexture=function(g){var te,tr=this.texData.get(g),to=tr.shape,tu=tr.dtype,tc=tr.isPacked,tl=k(to);if(th.getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){var td=this.decode(g),tf=this.texData.get(td.dataId),tp=(te=this.gpgpu).downloadMatrixFromPackedTexture.apply(te,[tf.texture].concat(Yt(to))).subarray(0,tl);return this.disposeData(td.dataId),tp}var tv=th.getBool("WEBGL_PACK")&&!0===tc,tm=tv?Te(to):to,tg=tv?new ci(tm):new ui(tm),ty=this.runWebGLProgram(tg,[{shape:tm,dtype:tu,dataId:g}],"float32"),tx=this.texData.get(ty.dataId),tb=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(tx.texture,tx.texShape[0],tx.texShape[1]).subarray(0,tl);return this.disposeData(ty.dataId),tb},o.prototype.time=function(g){return n(this,void 0,void 0,function(){var te,tr,to,tu,tc,tl,td;return r(this,function(tf){switch(tf.label){case 0:return te=this.activeTimers,tr=[],to=!1,null==this.programTimersStack?(this.programTimersStack=tr,to=!0):this.activeTimers.push(tr),this.activeTimers=tr,g(),tu=I(this.activeTimers.map(function(g){return g.query})).filter(function(g){return null!=g}),tc=I(this.activeTimers.map(function(g){return g.name})).filter(function(g){return null!=g}),this.activeTimers=te,to&&(this.programTimersStack=null),tl={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},th.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?[4,Promise.all(tu)]:[3,2];case 1:return td=tf.sent(),tl.kernelMs=w(td),tl.getExtraProfileInfo=function(){return td.map(function(g,te){return{name:tc[te],ms:g}}).map(function(g){return g.name+": "+g.ms}).join(", ")},[3,3];case 2:tl.kernelMs={error:"WebGL query timers are not supported in this environment."},tf.label=3;case 3:return this.uploadWaitMs=0,this.downloadWaitMs=0,[2,tl]}})})},o.prototype.memory=function(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU}},o.prototype.startTimer=function(){return th.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:et(),endMs:null}},o.prototype.endTimer=function(g){return th.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.endQuery():g.endMs=et(),g},o.prototype.getQueryTime=function(g){return n(this,void 0,void 0,function(){var te;return r(this,function(tr){return th.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?[2,this.gpgpu.waitForQueryAndGetTime(g)]:[2,(te=g).endMs-te.startMs]})})},o.prototype.disposeData=function(g){if(!this.pendingDisposal.has(g)){if(this.pendingRead.has(g))return this.pendingDisposal.add(g),void this.pendingDeletes++;if(this.texData.has(g)){this.releaseGPUData(g);var te=this.texData.get(g).complexTensors;null!=te&&(te.real.dispose(),te.imag.dispose()),this.texData.delete(g)}}},o.prototype.releaseGPUData=function(g){var te=this.texData.get(g),tr=te.texture,to=te.dtype,tu=te.texShape,tc=te.usage,tl=te.isPacked,th=te.slice,td=th&&th.origDataId||g,tf=this.dataRefCount.get(td);tf>1?this.dataRefCount.set(td,tf-1):(this.dataRefCount.delete(td),null!=tr&&(this.numBytesInGPU-=this.computeBytes(tu,to),this.textureManager.releaseTexture(tr,tu,tc,tl)));var tp=this.texData.get(g);tp.texture=null,tp.texShape=null,tp.isPacked=!1,tp.slice=null},o.prototype.getTexture=function(g){return this.uploadToGPU(g),this.texData.get(g).texture},o.prototype.getDataInfo=function(g){return this.texData.get(g)},o.prototype.getCPUBackend=function(){return th.getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=tB.findBackend("cpu")),this.cpuBackend):null},o.prototype.shouldExecuteOnCPU=function(g,te){var tr=this;return void 0===te&&(te=128),null!=this.getCPUBackend()&&g.every(function(g){return null==tr.texData.get(g.dataId).texture&&g.size<te})},o.prototype.getGPGPUContext=function(){return this.gpgpu},o.prototype.complex=function(g,te){var tr=this.makeOutput(g.shape,"complex64");return this.texData.get(tr.dataId).complexTensors={real:tB.keep(g.clone()),imag:tB.keep(te.clone())},tr},o.prototype.real=function(g){return this.texData.get(g.dataId).complexTensors.real.clone()},o.prototype.imag=function(g){return this.texData.get(g.dataId).complexTensors.imag.clone()},o.prototype.slice=function(g,te,tr){if(this.shouldExecuteOnCPU([g]))return this.cpuBackend.slice(g,te,tr);if(0===k(tr))return Fn([],tr,g.dtype);var to=this.texData.get(g.dataId).isPacked,tu=io(g.shape,te,tr);if(to||!tu){var tc=th.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ec(tr):new n9(tr),tl=tc.getCustomSetupFunc(te);return this.compileAndRun(tc,[g],null,tl)}return this.uploadToGPU(g.dataId),this.shallowSlice(g,te,tr)},o.prototype.shallowSlice=function(g,te,tr){var to=this.texData.get(g.dataId),tu=this.makeOutput(tr,g.dtype),tc=this.texData.get(tu.dataId);Object.assign(tc,to),tc.shape=tr,tc.dtype=g.dtype;var tl=so(te,g.strides);to.slice&&(tl+=to.slice.flatOffset),tc.slice={flatOffset:tl,origDataId:to.slice&&to.slice.origDataId||g.dataId};var th=this.dataRefCount.get(tc.slice.origDataId)||1;return this.dataRefCount.set(tc.slice.origDataId,th+1),tu},o.prototype.stridedSlice=function(g,te,tr,to){if(this.shouldExecuteOnCPU([g]))return this.cpuBackend.stridedSlice(g,te,tr,to);var tu=ro(te,tr,to);if(tu.some(function(g){return 0===g}))return Fn([],tu);var tc=new ds(te,to,tu);return this.compileAndRun(tc,[g])},o.prototype.reverse=function(g,te){var tr=th.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new is(g.shape,te):new as(g.shape,te);return this.compileAndRun(tr,[g])},o.prototype.concat=function(g,te){if("complex64"===g[0].dtype){var tr=g.map(function(g){return tQ(g)}),to=g.map(function(g){return tZ(g)});return tJ(this.concat(tr,te),this.concat(to,te))}if(this.shouldExecuteOnCPU(g))return this.cpuBackend.concat(g,te);if(1===g.length)return g[0];if(g.length>th.getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){var tu=Math.floor(g.length/2),tc=this.concat(g.slice(0,tu),te),tl=this.concat(g.slice(tu),te);return this.concat([tc,tl],te)}if(th.getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&g[0].rank>1){var td=new Ga(g.map(function(g){return g.shape}),te);return this.compileAndRun(td,g)}var tf=Sn(g.map(function(g){return g.shape}),te),tp=g.map(function(g){return g.as2D(-1,k(g.shape.slice(te)))}),tv=new za(tp.map(function(g){return g.shape}));return this.compileAndRun(tv,tp).reshape(tf)},o.prototype.neg=function(g){if(this.shouldExecuteOnCPU([g]))return this.cpuBackend.neg(g);if(th.getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(g,em,g.dtype);var te=new Cs(g.shape,em);return this.compileAndRun(te,[g])},o.prototype.batchMatMul=function(g,te,tr,to){var tu=tr?g.shape[2]:g.shape[1],tc=to?te.shape[1]:te.shape[2],tl=tr?g.shape[1]:g.shape[2],th=g.shape[0];if((1===tu||1===tc)&&tl>1e3){tr&&(g=g.transpose([0,2,1])),to&&(te=te.transpose([0,2,1]));var td=1===tc?g:g.as3D(th,tl,1),tf=1===tc?2:1,tp=1===tc?te.as3D(th,1,tl):te;return this.multiply(td,tp).sum(tf,!0)}var tv=Dt(g.dtype,te.dtype),tm=new Hi(g.shape,[th,tu,tc],tr,to);return this.compileAndRun(tm,[g,te],tv)},o.prototype.fusedBatchMatMul=function(g){var te=g.a,tr=g.b,to=g.transposeA,tu=g.transposeB,tc=g.bias,tl=g.activation,th=g.preluActivationWeights,td=to?te.shape[2]:te.shape[1],tf=tu?tr.shape[1]:tr.shape[2],tp=te.shape[0],tv=Dt(te.dtype,tr.dtype),tm=null!=tc,tg=null!=th,ty=tl?Qs(tl,!0):null,tx=new Hi(te.shape,[tp,td,tf],to,tu,tm,ty,tg),tb=[te,tr];return tc&&tb.push(tc),th&&tb.push(th),this.compileAndRun(tx,tb,tv)},o.prototype.multiply=function(g,te){if("complex64"===g.dtype){var tr=this.texData.get(g.dataId),to=this.texData.get(te.dataId),tu=new Na("return areal * breal - aimag * bimag;",g.shape,te.shape),tc=new Na("return areal * bimag + aimag * breal;",g.shape,te.shape),tl=[this.makeComplexComponentTensorInfo(g,tr.complexTensors.real),this.makeComplexComponentTensorInfo(g,tr.complexTensors.imag),this.makeComplexComponentTensorInfo(te,to.complexTensors.real),this.makeComplexComponentTensorInfo(te,to.complexTensors.imag)],td=this.compileAndRun(tu,tl),tf=this.compileAndRun(tc,tl),tp=this.complex(td,tf);return td.dispose(),tf.dispose(),tp}if(this.shouldExecuteOnCPU([g,te]))return this.cpuBackend.multiply(g,te);if(th.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(g,te,nZ,g.dtype);var tv=new Ba(nZ,g.shape,te.shape);return this.compileAndRun(tv,[g,te],g.dtype)},o.prototype.batchNormalization=function(g,te,tr,to,tu,tc){var tl=[g,te,tr],td=null;null!=tc&&(td=tc.shape,tl.push(tc));var tf=null;if(null!=tu&&(tf=tu.shape,tl.push(tu)),th.getBool("WEBGL_PACK_NORMALIZATION")){var tp=new Aa(g.shape,te.shape,tr.shape,td,tf,to);return this.compileAndRun(tp,tl)}var tv=new Sa(g.shape,te.shape,tr.shape,td,tf,to);return this.compileAndRun(tv,tl)},o.prototype.localResponseNormalization4D=function(g,te,tr,to,tu){var tc=th.getBool("WEBGL_PACK_NORMALIZATION")?new Vi(g.shape,te,tr,to,tu):new Wi(g.shape,te,tr,to,tu);return this.compileAndRun(tc,[g])},o.prototype.LRNGrad=function(g,te,tr,to,tu,tc,tl){var th=new Ui(te.shape,to,tu,tc,tl);return this.compileAndRun(th,[te,tr,g])},o.prototype.tile=function(g,te){if("string"===g.dtype){var tr=this.readSync(g.dataId).map(function(g){return ot(g)});return ta(dr(g.shape,g.dtype,tr),te)}var to=new gs(g.shape,te);return this.compileAndRun(to,[g])},o.prototype.pad=function(g,te,tr){var to=th.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Yi(g.shape,te,tr):new Xi(g.shape,te,tr);return this.compileAndRun(to,[g])},o.prototype.transpose=function(g,te){if(this.shouldExecuteOnCPU([g]))return this.cpuBackend.transpose(g,te);var tr=th.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new xs(g.shape,te):new ys(g.shape,te);return this.compileAndRun(tr,[g])},o.prototype.gather=function(g,te,tr){if(this.shouldExecuteOnCPU([g,te]))return this.cpuBackend.gather(g,te,tr);var to=new mi(g.shape,te.size,tr);return this.compileAndRun(to,[g,te])},o.prototype.batchToSpaceND=function(g,te,tr){C(g.rank<=4,function(){return"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"});var to=te.reduce(function(g,te){return g*te}),tu=zr(g.shape,te,to),tc=Gr(tu.length,te.length),tl=Hr(g.shape,te,to),th=qr(tr,te.length),td=Kr(tl,tr,te.length);return g.reshape(tu).transpose(tc).reshape(tl).slice(th,td)},o.prototype.spaceToBatchND=function(g,te,tr){C(g.rank<=4,function(){return"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"});var to=te.reduce(function(g,te){return g*te}),tu=[[0,0]];tu.push.apply(tu,tr);for(var tc=1+te.length;tc<g.shape.length;++tc)tu.push([0,0]);var tl=g.pad(tu),th=zr(tl.shape,te,to,!1),td=Gr(th.length,te.length,!1),tf=Hr(tl.shape,te,to,!1);return tl.reshape(th).transpose(td).reshape(tf)},o.prototype.reduce=function(g,te,tr){var to=g.shape[0],tu=g.shape[1],tc=new Ji({windowSize:$r(tu),inSize:tu,batchSize:to},te),tl=this.compileAndRun(tc,[g],tr);return 1===tl.shape[1]?tl:this.reduce(tl,te,tr)},o.prototype.argReduce=function(g,te,tr){void 0===tr&&(tr=null);var to=g.shape[0],tu=g.shape[1];null!=tr&&(to=tr.shape[0],tu=tr.shape[1]);var tc=new aa({windowSize:$r(tu),inSize:tu,batchSize:to},te,null==tr),tl=[g];null!=tr&&tl.push(tr);var th=this.compileAndRun(tc,tl,"int32");return 1===th.shape[1]?th:this.argReduce(g,te,th)},o.prototype.argReducePacked=function(g,te,tr){void 0===tr&&(tr=null);var to=null!=tr?tr.shape:g.shape,tu=$r(to[to.length-1]),tc=new Ra(to,tu,te,null==tr),tl=null==tr?[g]:[g,tr],th=this.compileAndRun(tc,tl,"int32");return th.rank===g.rank?this.argReducePacked(g,te,th):th},o.prototype.sum=function(g,te){Cn("sum",te,g.rank);var tr=bn(g.shape,te),to=tr[0],tu=k(tr[1]),tc=g.as2D(-1,tu),tl=Tt(g.dtype);return this.reduce(tc,"sum",tl).reshape(to)},o.prototype.prod=function(g,te){if(this.shouldExecuteOnCPU([g]))return this.cpuBackend.prod(g,te);var tr=bn(g.shape,te),to=tr[0],tu=k(tr[1]),tc=g.as2D(-1,tu),tl=Tt(g.dtype);return this.reduce(tc,"prod",tl).reshape(to)},o.prototype.unsortedSegmentSum=function(g,te,tr){var to=0,tu=En([0],g.rank),tc=g;null!=tu&&(tc=g.transpose(tu),to=In(1,g.rank)[0]);var tl=function(g,te,tr){for(var to=[],tu=g.length,tc=0;tc<tu;tc++)tc!==te?to.push(g[tc]):to.push(tr);return to}(tc.shape,to,tr),th=k([tc.shape[to]]),td=tc.as2D(-1,th),tf=Tt(g.dtype),tp=this.segOpCompute(td,"unsortedSegmentSum",te,tf,tr).reshape(tl);return null!=tu&&(tp=tp.transpose(Rn(tu))),tp},o.prototype.segOpCompute=function(g,te,tr,to,tu){var tc=g.shape[0],tl=g.shape[1],th=function(g,te){var tr,to=!1;for(g<=30?(tr=g,to=!0):tr=Y(g,Math.floor(Math.sqrt(g)));!to;)tr>te||tr===g?to=!0:tr=Y(g,tr+1);return tr}(tl,tu),td=new us({windowSize:th,inSize:tl,batchSize:tc,numSegments:tu},te),tf=this.compileAndRun(td,[g,tr],to);return tf.shape[1]===tu?tf:(tr=Kn(0,tu).tile([tl/th]),this.segOpCompute(tf,te,tr,to,tu))},o.prototype.argMinMaxReduce=function(g,te,tr){var to=[te];if(Cn("arg"+tr.charAt(0).toUpperCase()+tr.slice(1),to,g.rank),!th.getBool("WEBGL_PACK_REDUCE")||g.rank<=2){var tu=bn(g.shape,to),tc=tu[0],tl=k(tu[1]),td=g.as2D(-1,tl);return this.argReduce(td,tr).reshape(tc)}return this.argReducePacked(g,tr)},o.prototype.argMin=function(g,te){return this.argMinMaxReduce(g,te,"min")},o.prototype.argMax=function(g,te){return this.argMinMaxReduce(g,te,"max")},o.prototype.cumsum=function(g,te,tr,to){if(te!==g.rank-1)throw Error("WebGL cumsum shader expects an inner-most axis="+(g.rank-1)+" but got axis="+te);var tu=new ni(g.shape,tr,to);return this.compileAndRun(tu,[g])},o.prototype.equal=function(g,te){if(th.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(g,te,"\n  return vec4(equal(a, b));\n","bool");var tr=new Ba("return float(a == b);",g.shape,te.shape);return this.compileAndRun(tr,[g,te],"bool")},o.prototype.notEqual=function(g,te){if(th.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(g,te,"\n  return vec4(notEqual(a, b));\n","bool");var tr=new Ba("return float(a != b);",g.shape,te.shape);return this.compileAndRun(tr,[g,te],"bool")},o.prototype.less=function(g,te){if(this.shouldExecuteOnCPU([g,te]))return this.cpuBackend.less(g,te);if(th.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(g,te,"\n  return vec4(lessThan(a, b));\n","bool");var tr=new Ba("return float(a < b);",g.shape,te.shape);return this.compileAndRun(tr,[g,te],"bool")},o.prototype.lessEqual=function(g,te){if(th.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(g,te,"\n  return vec4(lessThanEqual(a, b));\n","bool");var tr=new Ba("return float(a <= b);",g.shape,te.shape);return this.compileAndRun(tr,[g,te],"bool")},o.prototype.greater=function(g,te){if(this.shouldExecuteOnCPU([g,te]))return this.cpuBackend.greater(g,te);if(th.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(g,te,"\n  return vec4(greaterThan(a, b));\n","bool");var tr=new Ba("return float(a > b);",g.shape,te.shape);return this.compileAndRun(tr,[g,te],"bool")},o.prototype.greaterEqual=function(g,te){if(th.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(g,te,"\n  return vec4(greaterThanEqual(a, b));\n","bool");var tr=new Ba("return float(a >= b);",g.shape,te.shape);return this.compileAndRun(tr,[g,te],"bool")},o.prototype.logicalNot=function(g){var te=new Cs(g.shape,"return float(!(x >= 1.0));");return this.compileAndRun(te,[g])},o.prototype.logicalAnd=function(g,te){if(th.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(g,te,"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n","bool");var tr=new Ba("return float(a >= 1.0 && b >= 1.0);",g.shape,te.shape);return this.compileAndRun(tr,[g,te],"bool")},o.prototype.logicalOr=function(g,te){if(th.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(g,te,"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n","bool");var tr=new Ba("return float(a >= 1.0 || b >= 1.0);",g.shape,te.shape);return this.compileAndRun(tr,[g,te],"bool")},o.prototype.select=function(g,te,tr){var to=new cs(g.rank,te.shape,te.rank);return this.compileAndRun(to,[g,te,tr],Dt(te.dtype,tr.dtype))},o.prototype.where=function(g){dn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");var te=g.dataSync();return na(g.shape,te)},o.prototype.topk=function(g,te,tr){return ea(g.dataSync(),g.shape,g.dtype,te)},o.prototype.min=function(g,te){Cn("min",te,g.rank);var tr=bn(g.shape,te),to=tr[0],tu=k(tr[1]),tc=g.as2D(-1,tu);return this.reduce(tc,"min",tc.dtype).reshape(to)},o.prototype.minimum=function(g,te){if(this.shouldExecuteOnCPU([g,te]))return this.cpuBackend.minimum(g,te);var tr=th.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",g.shape,te.shape):new Ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",g.shape,te.shape);return this.compileAndRun(tr,[g,te])},o.prototype.mod=function(g,te){var tr=th.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",g.shape,te.shape):new Ba("if (b == 0.0) return NAN;\n  return mod(a, b);",g.shape,te.shape);return this.compileAndRun(tr,[g,te])},o.prototype.max=function(g,te){if(this.shouldExecuteOnCPU([g]))return this.cpuBackend.max(g,te);Cn("max",te,g.rank);var tr=bn(g.shape,te),to=tr[0],tu=k(tr[1]),tc=g.as2D(-1,tu);return this.reduce(tc,"max",tc.dtype).reshape(to)},o.prototype.maximum=function(g,te){if(this.shouldExecuteOnCPU([g,te]))return this.cpuBackend.maximum(g,te);var tr=th.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",g.shape,te.shape):new Ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",g.shape,te.shape);return this.compileAndRun(tr,[g,te])},o.prototype.all=function(g,te){Cn("all",te,g.rank);var tr=bn(g.shape,te),to=tr[0],tu=k(tr[1]),tc=g.as2D(-1,tu);return this.reduce(tc,"all",tc.dtype).reshape(to)},o.prototype.any=function(g,te){Cn("any",te,g.rank);var tr=bn(g.shape,te),to=tr[0],tu=k(tr[1]),tc=g.as2D(-1,tu);return this.reduce(tc,"any",tc.dtype).reshape(to)},o.prototype.realDivide=function(g,te){if(th.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(g,te,"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n","float32",!0);var tr=new Ba("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",g.shape,te.shape);return this.compileAndRun(tr,[g,te],"float32")},o.prototype.floorDiv=function(g,te){if(th.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(g,te,"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n","int32");var tr=new Ba("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",g.shape,te.shape);return this.compileAndRun(tr,[g,te],"int32")},o.prototype.add=function(g,te){if("complex64"===g.dtype&&"complex64"===te.dtype)return this.complexSeparableBinaryOp(g,te,nJ);if(this.shouldExecuteOnCPU([g,te]))return this.cpuBackend.add(g,te);var tr=Dt(g.dtype,te.dtype);if(th.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(g,te,nJ,tr);var to=new Ba(nJ,g.shape,te.shape);return this.compileAndRun(to,[g,te],tr)},o.prototype.packedUnaryOp=function(g,te,tr){var to=new Xs(g.shape,te);return this.compileAndRun(to,[g],tr)},o.prototype.packedBinaryOp=function(g,te,tr,to,tu){void 0===tu&&(tu=!1);var tc=new La(tr,g.shape,te.shape,tu);return this.compileAndRun(tc,[g,te],to)},o.prototype.complexSeparableBinaryOp=function(g,te,tr){var to=this,tu=this.texData.get(g.dataId),tc=this.texData.get(te.dataId),tl=[[tu.complexTensors.real,tc.complexTensors.real],[tu.complexTensors.imag,tc.complexTensors.imag]].map(function(tu){var tc=tu[0],tl=tu[1],th=to.makeComplexComponentTensorInfo(g,tc),td=to.makeComplexComponentTensorInfo(te,tl),tf=new Ba(tr,g.shape,te.shape);return to.compileAndRun(tf,[th,td],Dt(tc.dtype,tl.dtype))}),th=tl[0],td=tl[1],tf=this.complex(th,td);return th.dispose(),td.dispose(),tf},o.prototype.makeComplexComponentTensorInfo=function(g,te){return{dataId:te.dataId,dtype:te.dtype,shape:g.shape}},o.prototype.addN=function(g){if(1===g.length)return g[0];if(g.length>th.get("WEBGL_MAX_TEXTURES_IN_SHADER")){var te=Math.floor(g.length/2),tr=this.addN(g.slice(0,te)),to=this.addN(g.slice(te));return this.addN([tr,to])}var tu=g.map(function(g){return g.dtype}).reduce(function(g,te){return Dt(g,te)}),tc=g.map(function(g){return g.shape}),tl=th.getBool("WEBGL_PACK")?new oa(g[0].shape,tc):new ra(g[0].shape,tc);return this.compileAndRun(tl,g,tu)},o.prototype.subtract=function(g,te){if("complex64"===g.dtype&&"complex64"===te.dtype)return this.complexSeparableBinaryOp(g,te,nQ);if(this.shouldExecuteOnCPU([g,te]))return this.cpuBackend.subtract(g,te);var tr=Dt(g.dtype,te.dtype);if(th.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(g,te,nQ,g.dtype);var to=new Ba(nQ,g.shape,te.shape);return this.compileAndRun(to,[g,te],tr)},o.prototype.pow=function(g,te){var tr=th.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",g.shape,te.shape):new Ba("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",g.shape,te.shape),to=Dt(g.dtype,te.dtype);return this.compileAndRun(tr,[g,te],to)},o.prototype.ceil=function(g){if(this.shouldExecuteOnCPU([g]))return this.cpuBackend.ceil(g);if(th.getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(g,eg,g.dtype);var te=new Cs(g.shape,eg);return this.compileAndRun(te,[g])},o.prototype.floor=function(g){if(this.shouldExecuteOnCPU([g]))return this.cpuBackend.floor(g);if(th.getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(g,ey,g.dtype);var te=new Cs(g.shape,ey);return this.compileAndRun(te,[g])},o.prototype.sign=function(g){var te=new Cs(g.shape,"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");return this.compileAndRun(te,[g])},o.prototype.isNaN=function(g){var te=new Cs(g.shape,"return float(isnan(x));");return this.compileAndRun(te,[g],"bool")},o.prototype.isInf=function(g){var te=new Cs(g.shape,"return float(isinf(x));");return this.compileAndRun(te,[g],"bool")},o.prototype.isFinite=function(g){var te=new Cs(g.shape,"return float(!isnan(x) && !isinf(x));");return this.compileAndRun(te,[g],"bool")},o.prototype.round=function(g){var te=new Cs(g.shape,"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");return this.compileAndRun(te,[g])},o.prototype.exp=function(g){if(this.shouldExecuteOnCPU([g]))return this.cpuBackend.exp(g);if(th.getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(g,ex,g.dtype);var te=new Cs(g.shape,ex);return this.compileAndRun(te,[g])},o.prototype.expm1=function(g){if(this.shouldExecuteOnCPU([g]))return this.cpuBackend.expm1(g);if(th.getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(g,eb,g.dtype);var te=new Cs(g.shape,eb);return this.compileAndRun(te,[g])},o.prototype.softmax=function(g,te){var tr=O([te],g.shape),to=this.max(g,tr),tu=wn(to.shape,tr),tc=this.subtract(g,to.reshape(tu)),tl=this.exp(tc),th=this.sum(tl,tr).reshape(tu);return this.realDivide(tl,th)},o.prototype.log=function(g){if(this.shouldExecuteOnCPU([g]))return this.cpuBackend.log(g);if(th.getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(g,"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",g.dtype);var te=new Cs(g.shape,"if (x < 0.0) return NAN;\n  return log(x);");return this.compileAndRun(te,[g])},o.prototype.log1p=function(g){var te=new Cs(g.shape,"return log(1.0 + x);");return this.compileAndRun(te,[g])},o.prototype.sqrt=function(g){var te=new Cs(g.shape,"return sqrt(x);");return this.compileAndRun(te,[g])},o.prototype.rsqrt=function(g){if(this.shouldExecuteOnCPU([g]))return this.cpuBackend.rsqrt(g);var te=new Cs(g.shape,"return inversesqrt(x);");return this.compileAndRun(te,[g])},o.prototype.reciprocal=function(g){var te=new Cs(g.shape,"return 1.0 / x;");return this.compileAndRun(te,[g])},o.prototype.relu=function(g){var te;return te=th.getBool("WEBGL_PACK")?new Xs(g.shape,eN):new Cs(g.shape,ef),this.compileAndRun(te,[g])},o.prototype.relu6=function(g){var te;return te=th.getBool("WEBGL_PACK")?new Xs(g.shape,eT):new Cs(g.shape,ep),this.compileAndRun(te,[g])},o.prototype.prelu=function(g,te){var tr=th.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La(n1,g.shape,te.shape):new Ba(n0,g.shape,te.shape);return this.compileAndRun(tr,[g,te])},o.prototype.elu=function(g){if(th.getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(g,eF,g.dtype);var te=new Cs(g.shape,ev);return this.compileAndRun(te,[g])},o.prototype.eluDer=function(g,te){var tr=th.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",g.shape,te.shape):new Ba("return (b >= 1.0) ? a : a * (b + 1.0);",g.shape,te.shape);return this.compileAndRun(tr,[g,te])},o.prototype.selu=function(g){var te=new Cs(g.shape,"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = 1.7580993408473768;\n  float scale = 1.0507009873554805;\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n");return this.compileAndRun(te,[g])},o.prototype.int=function(g){var te=new Cs(g.shape,"return float(int(x));");return this.compileAndRun(te,[g],"int32")},o.prototype.clip=function(g,te,tr){var to,tu=(to=th.getBool("WEBGL_PACK_CLIP")?new n3(g.shape):new n2(g.shape)).getCustomSetupFunc(te,tr);return this.compileAndRun(to,[g],null,tu)},o.prototype.abs=function(g){if(this.shouldExecuteOnCPU([g]))return this.cpuBackend.abs(g);if(th.getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(g,ed,g.dtype);var te=new Cs(g.shape,ed);return this.compileAndRun(te,[g])},o.prototype.complexAbs=function(g){var te=this.texData.get(g.dataId),tr=new Va(g.shape),to=[this.makeComplexComponentTensorInfo(g,te.complexTensors.real),this.makeComplexComponentTensorInfo(g,te.complexTensors.imag)];return this.compileAndRun(tr,to)},o.prototype.sigmoid=function(g){var te=new Cs(g.shape,"return 1.0 / (1.0 + exp(-1.0 * x));");return this.compileAndRun(te,[g])},o.prototype.softplus=function(g){var te=new Cs(g.shape,"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");return this.compileAndRun(te,[g])},o.prototype.sin=function(g){var te=new Cs(g.shape,eC);return this.compileAndRun(te,[g])},o.prototype.cos=function(g){var te=new Cs(g.shape,ew);return this.compileAndRun(te,[g])},o.prototype.tan=function(g){var te=new Cs(g.shape,"return tan(x);");return this.compileAndRun(te,[g])},o.prototype.asin=function(g){var te=new Cs(g.shape,eE);return this.compileAndRun(te,[g])},o.prototype.acos=function(g){var te=new Cs(g.shape,eR);return this.compileAndRun(te,[g])},o.prototype.atan=function(g){var te=new Cs(g.shape,eI);return this.compileAndRun(te,[g])},o.prototype.atan2=function(g,te){var tr=th.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",g.shape,te.shape):new Ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",g.shape,te.shape);return this.compileAndRun(tr,[g,te])},o.prototype.sinh=function(g){var te=new Cs(g.shape,"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");return this.compileAndRun(te,[g])},o.prototype.cosh=function(g){var te=new Cs(g.shape,"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");return this.compileAndRun(te,[g])},o.prototype.tanh=function(g){var te=new Cs(g.shape,"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");return this.compileAndRun(te,[g])},o.prototype.asinh=function(g){var te=new Cs(g.shape,ek);return this.compileAndRun(te,[g])},o.prototype.acosh=function(g){var te=new Cs(g.shape,eA);return this.compileAndRun(te,[g])},o.prototype.atanh=function(g){var te=new Cs(g.shape,eS);return this.compileAndRun(te,[g])},o.prototype.erf=function(g){var te=new Cs(g.shape,'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n');return this.compileAndRun(te,[g])},o.prototype.step=function(g,te){var tr,to=new Cs(g.shape,(void 0===(tr=te)&&(tr=0),eh+"\n    return x > 0.0 ? 1.0 : float("+tr+");\n  "));return this.compileAndRun(to,[g])},o.prototype.conv2dByMatMul=function(g,te,tr,to,tu,tc){var tl=g.shape,td=this.texData.get(g.dataId),tf=tr.inChannels,tp=tl[0]*tl[1]*tl[2],tv=tr.outChannels,tm="channelsLast"===tr.dataFormat,tg=tl[2]%2!=0&&!!td.isPacked;if((1===tp||1===tv)&&tf>1e3||!th.getBool("WEBGL_LAZILY_UNPACK")||!th.getBool("WEBGL_PACK_BINARY_OPERATIONS")||!tg){var ty=tm?tl[0]*tl[1]*tl[2]:tl[0]*tl[2]*tl[3],tx=this.reshape(g,[1,ty,tr.inChannels]),tb=this.reshape(te,[1,tr.inChannels,tr.outChannels]);return this.reshape(this.fusedBatchMatMul({a:tx,b:tb,transposeA:!1,transposeB:!1,bias:to,activation:tu,preluActivationWeights:tc}),tr.outShape)}var tC=tm?tl[0]*tl[1]*(tl[2]+1):tl[0]*tl[2]*(tl[3]+1),tw={dataId:g.dataId,shape:[1,tC,tr.inChannels],dtype:g.dtype},tE=td.shape;td.shape=td.shape.slice(),td.shape[td.shape.length-2]++,C(_e(td.shape,tw.shape),function(){return"packed reshape "+td.shape+" to "+tw.shape+" isn't free"});var tR=this.reshape(te,[1,tr.inChannels,tr.outChannels]),tI=this.fusedBatchMatMul({a:tw,b:tR,transposeA:!1,transposeB:!1,bias:to,activation:tu,preluActivationWeights:tc}),tk=this.texData.get(tI.dataId);return C(tk.isPacked,function(){return"batchMatMul result is expected to be packed"}),td.shape=tE,tk.shape=tr.outShape,tB.makeTensorFromDataId(tI.dataId,tr.outShape,tI.dtype)},o.prototype.conv2dWithIm2Row=function(g,te,tr,to,tu,tc){var tl=tr.filterWidth,th=tr.filterHeight,td=tr.inChannels,tf=tr.outWidth,tp=tr.outHeight,tv="channelsLast"===tr.dataFormat,tm=tl*th*td,tg=tp*tf,ty=[tm,tg],tx=g.squeeze([0]),tb=te.reshape([1,tm,-1]),tC=new Li(ty,tx.shape,tr),tw=this.compileAndRun(tC,[tx]).reshape([1,ty[0],ty[1]]),tE=null!=to,tR=null!=tc,tI=tu?Qs(tu,!0):null,tk=new Hi(tw.shape,[1,tg,tr.outChannels],!0,!1,tE,tI,tR),tA=[tw,tb];to&&tA.push(to),tR&&tA.push(tc);var tS=this.compileAndRun(tk,tA);return tv?tS.reshape([1,tp,tf,tr.outChannels]):tS.reshape([1,tr.outChannels,tp,tf])},o.prototype.fusedConv2d=function(g){var te=g.input,tr=g.filter,to=g.convInfo,tu=g.bias,tc=g.activation,tl=g.preluActivationWeights;if(1===to.filterHeight&&1===to.filterWidth&&1===to.dilationHeight&&1===to.dilationWidth&&1===to.strideHeight&&1===to.strideWidth&&("SAME"===to.padInfo.type||"VALID"===to.padInfo.type))return this.conv2dByMatMul(te,tr,to,tu,tc,tl);if(th.getBool("WEBGL_CONV_IM2COL")&&1===te.shape[0])return this.conv2dWithIm2Row(te,tr,to,tu,tc,tl);var td=null!=tl,tf=new Qa(to,null!=tu,tc?Qs(tc,!1):null,td),tp=[te,tr];return tu&&tp.push(tu),tl&&tp.push(tl),this.compileAndRun(tf,tp)},o.prototype.conv2d=function(g,te,tr){if(1===tr.filterHeight&&1===tr.filterWidth&&1===tr.dilationHeight&&1===tr.dilationWidth&&1===tr.strideHeight&&1===tr.strideWidth&&("SAME"===tr.padInfo.type||"VALID"===tr.padInfo.type))return this.conv2dByMatMul(g,te,tr);if(th.getBool("WEBGL_CONV_IM2COL")&&1===g.shape[0])return this.conv2dWithIm2Row(g,te,tr);var to=new Qa(tr);return this.compileAndRun(to,[g,te])},o.prototype.conv2dDerInput=function(g,te,tr){var to=new Ka(tr);return this.compileAndRun(to,[g,te])},o.prototype.conv2dDerFilter=function(g,te,tr){var to=new qa(tr);return this.compileAndRun(to,[g,te])},o.prototype.fusedDepthwiseConv2D=function(g){var te,tr=g.input,to=g.filter,tu=g.convInfo,tc=g.bias,tl=g.activation,td=g.preluActivationWeights,tf=th.getBool("WEBGL_PACK_DEPTHWISECONV")&&tu.strideWidth<=2&&tu.outChannels/tu.inChannels==1,tp=tl?Qs(tl,tf):null,tv=[tr,to],tm=null!=tc,tg=null!=td;return tm&&tv.push(tc),tg&&tv.push(td),te=tf?new ti(tu,tm,tp,tg):new Za(tu,tm,tp,tg),this.compileAndRun(te,tv)},o.prototype.depthwiseConv2D=function(g,te,tr){var to;return to=th.getBool("WEBGL_PACK_DEPTHWISECONV")&&tr.strideWidth<=2&&tr.outChannels/tr.inChannels==1?new ti(tr):new Za(tr),this.compileAndRun(to,[g,te])},o.prototype.depthwiseConv2DDerInput=function(g,te,tr){var to=new $a(tr);return this.compileAndRun(to,[g,te])},o.prototype.depthwiseConv2DDerFilter=function(g,te,tr){var to=new Ya(tr);return this.compileAndRun(to,[g,te])},o.prototype.conv3d=function(g,te,tr){var to=new Ja(tr);return this.compileAndRun(to,[g,te])},o.prototype.conv3dDerInput=function(g,te,tr){var to=new Xa(tr);return this.compileAndRun(to,[g,te])},o.prototype.conv3dDerFilter=function(g,te,tr){var to=new ja(tr);return this.compileAndRun(to,[g,te])},o.prototype.maxPool=function(g,te){var tr=new $i(te,"max",!1);return this.compileAndRun(tr,[g])},o.prototype.avgPool=function(g,te){var tr=new $i(te,"avg",!1);return this.compileAndRun(tr,[g],"float32")},o.prototype.maxPoolBackprop=function(g,te,tr,to){var tu=new $i(to,"max",!0),tc=this.compileAndRun(tu,[te]),tl=new zi(to),th=this.compileAndRun(tl,[g,tc],te.dtype);return tc.dispose(),th},o.prototype.avgPoolBackprop=function(g,te,tr){var to=new Ia(tr);return this.compileAndRun(to,[g],te.dtype)},o.prototype.cast=function(g,te){return Po(g,te,this)},o.prototype.unstack=function(g,te){for(var tr=g.shape[te],to=Array(g.rank-1),tu=0,tc=0;tc<g.rank;tc++)tc!==te&&(to[tu++]=g.shape[tc]);var tl=Array(g.rank).fill(0),th=g.shape.slice();th[te]=1;var td=Array(tr);for(tc=0;tc<td.length;tc++)tl[te]=tc,td[tc]=this.slice(g,tl,th).reshape(to);return td},o.prototype.avgPool3d=function(g,te){var tr=new Qi(te,"avg",!1);return this.compileAndRun(tr,[g],"float32")},o.prototype.avgPool3dBackprop=function(g,te,tr){var to=new ka(tr);return this.compileAndRun(to,[g],te.dtype)},o.prototype.maxPool3d=function(g,te){var tr=new Qi(te,"max",!1);return this.compileAndRun(tr,[g],"float32")},o.prototype.maxPool3dBackprop=function(g,te,tr,to){var tu=new Qi(to,"max",!0),tc=this.compileAndRun(tu,[te]),tl=new Gi(to),th=this.compileAndRun(tl,[g,tc],te.dtype);return tc.dispose(),th},o.prototype.reshape=function(g,te){var tr=this.texData.get(g.dataId);if(tr.isPacked&&!_e(g.shape,te)&&(null===tr.texture||!_e(tr.shape,te))){var to=this.packedReshape(g,te);return tB.makeTensorFromDataId(to.dataId,to.shape,to.dtype)}return Lo(g,te)},o.prototype.resizeBilinear=function(g,te,tr,to){var tu=th.getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ns(g.shape,te,tr,to):new es(g.shape,te,tr,to);return this.compileAndRun(tu,[g],"float32")},o.prototype.resizeBilinearBackprop=function(g,te,tr){var to=new ts(g,te,tr);return this.compileAndRun(to,[g])},o.prototype.resizeNearestNeighbor=function(g,te,tr,to){var tu=new os(g.shape,te,tr,to);return this.compileAndRun(tu,[g])},o.prototype.resizeNearestNeighborBackprop=function(g,te,tr){var to=new rs(g,te,tr);return this.compileAndRun(to,[g])},o.prototype.multinomial=function(g,te,tr,to){var tu=te?g:nz(g),tc=new n7(tu.shape[0],tu.shape[1],tr),tl=tc.getCustomSetupFunc(to);return this.compileAndRun(tc,[tu],"int32",tl)},o.prototype.oneHot=function(g,te,tr,to){var tu=new Ki(g.size,te,tr,to);return this.compileAndRun(tu,[g])},o.prototype.diag=function(g){var te=new si(g.size);return this.compileAndRun(te,[g])},o.prototype.nonMaxSuppression=function(g,te,tr,to,tu){return dn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"),jo(g.dataSync(),te.dataSync(),tr,to,tu)},o.prototype.cropAndResize=function(g,te,tr,to,tu,tc){var tl=new ei(g.shape,te.shape,to,tu,tc);return this.compileAndRun(tl,[g,te,tr],"float32")},o.prototype.depthToSpace=function(g,te,tr){C(te>1,function(){return"blockSize should be > 1 for depthToSpace, but was: "+te});var to=g.shape[0],tu="NHWC"===tr?g.shape[1]:g.shape[2],tc="NHWC"===tr?g.shape[2]:g.shape[3],tl="NHWC"===tr?g.shape[3]:g.shape[1],th=tu*te,td=tc*te,tf=tl/(te*te),tp=new n4("NHWC"===tr?[to,th,td,tf]:[to,tf,th,td],te,tr);return this.compileAndRun(tp,[g])},o.prototype.split=function(g,te,tr){return Zo(g,te,tr)},o.prototype.scatterND=function(g,te,tr){var to=Zr(0,g,tr),tu=to.sliceRank,tc=to.numUpdates,tl=to.sliceSize,th=to.strides,td=to.outputSize,tf=[td/tl,tl],tp=g.reshape([tc,tu]),tv=te.reshape([tc,tl]);if(0===td)return Lo(Fn([]),tr);var tm=On(0),tg=new ss(tc,tu,tp.rank,tv.rank,th,tf);return this.compileAndRun(tg,[tv,tp,tm]).reshape(tr)},o.prototype.sparseToDense=function(g,te,tr,to){var tu=Zr(0,g,tr),tc=tu.sliceRank,tl=tu.numUpdates,th=tu.strides,td=tu.outputSize,tf=new ss(tl,tc,g.rank,te.rank,th,[td,1],!1);return this.compileAndRun(tf,[te,g,to]).reshape(tr)},o.prototype.fft=function(g){return this.fftImpl(g,!1)},o.prototype.ifft=function(g){return this.fftImpl(g,!0)},o.prototype.fftImpl=function(g,te){var tr=this.texData.get(g.dataId),to=new pi("return real * expR - imag * expI;",g.shape,te),tu=new pi("return real * expI + imag * expR;",g.shape,te),tc=[this.makeComplexComponentTensorInfo(g,tr.complexTensors.real),this.makeComplexComponentTensorInfo(g,tr.complexTensors.imag)],tl=this.compileAndRun(to,tc),th=this.compileAndRun(tu,tc),td=this.complex(tl,th).as2D(g.shape[0],g.shape[1]);return tl.dispose(),th.dispose(),td},o.prototype.gatherND=function(g,te){var tr=te.shape,to=tr[tr.length-1],tu=jr(g,te),tc=tu[0],tl=tu[1],th=tu[2],td=tu[3],tf=te.reshape([tl,to]),tp=g.reshape([g.size/th,th]),tv=new gi(to,td,[tl,th]);return this.compileAndRun(tv,[tp,tf]).reshape(tc)},o.prototype.fill=function(g,te,tr){if("string"===(tr=tr||j(te))){var to=P(tr,k(g));return to.fill(te),tB.makeTensor(to,g,tr,this)}var tu=new n5(g,te),tc=tu.getCustomSetupFunc(te);return this.compileAndRun(tu,[],tr,tc)},o.prototype.onesLike=function(g){if("string"===g.dtype)throw Error("onesLike is not supported under string dtype");return this.fill(g.shape,1,g.dtype)},o.prototype.zerosLike=function(g){return this.fill(g.shape,"string"===g.dtype?"":0,g.dtype)},o.prototype.linspace=function(g,te,tr){return Wo(g,te,tr)},o.prototype.makeTensorInfo=function(g,te){var tr=this.write(null,g,te);return this.texData.get(tr).usage=null,{dataId:tr,shape:g,dtype:te}},o.prototype.makeOutput=function(g,te){var tr=this.makeTensorInfo(g,te).dataId;return tB.makeTensorFromDataId(tr,g,te,this)},o.prototype.unpackTensor=function(g){var te=new Ys(g.shape);return this.runWebGLProgram(te,[g],g.dtype)},o.prototype.packTensor=function(g){var te=new ji(g.shape);return this.runWebGLProgram(te,[g],g.dtype,null,!0)},o.prototype.packedReshape=function(g,te){var tr=[Ae(g.shape)].concat(De(g.shape)),to={dtype:g.dtype,shape:tr,dataId:g.dataId},tu=new Zi([Ae(te)].concat(De(te)),tr),tc=this.runWebGLProgram(tu,[to],g.dtype,null,!0);return{dataId:tc.dataId,shape:te,dtype:tc.dtype}},o.prototype.decode=function(g){var te,tr=this.texData.get(g),to=tr.isPacked,tu=tr.shape,tc=tr.dtype,tl=Te(tu);return te=to?new ai(tl):new oi(tl),{dtype:tc,shape:tu,dataId:this.runWebGLProgram(te,[{shape:tl,dtype:tc,dataId:g}],tc,null,!0).dataId}},o.prototype.runWebGLProgram=function(g,te,tr,to,tu){var tc,tl,td,tf=this;void 0===tu&&(tu=!1);var tp=this.makeTensorInfo(g.outputShape,tr),tv=this.texData.get(tp.dataId);if(g.packedOutput&&(tv.isPacked=!0),g.outPackingScheme===tL.DENSE){var tm=Yt(g.outputShape);tv.texShape=tm.map(function(g){return 2*g})}if(null!=g.outTexUsage&&(tv.usage=g.outTexUsage),0===k(tp.shape))return tv.values=B(tp.dtype,0),tp;var tg=[],ty=te.map(function(te){if("complex64"===te.dtype)throw Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");var tr=tf.texData.get(te.dataId);if(null==tr.texture){if(!g.packedInputs&&k(te.shape)<=th.getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:te.shape,texData:null,isUniform:!0,uniformValues:tr.values};g.packedInputs&&(tr.isPacked=!0,tr.shape=te.shape)}else if(!!tr.isPacked!=!!g.packedInputs)te=tr.isPacked?tf.unpackTensor(te):tf.packTensor(te),tg.push(te),tr=tf.texData.get(te.dataId);else if(tr.isPacked&&!_e(tr.shape,te.shape)){var to=te,tu=te.shape;te.shape=tr.shape,te=tf.packedReshape(te,tu),tg.push(te),tr=tf.texData.get(te.dataId),to.shape=tu}return tf.uploadToGPU(te.dataId),{shape:te.shape,texData:tr,isUniform:!1}});this.uploadToGPU(tp.dataId);var tx,tb={shape:tp.shape,texData:tv,isUniform:!1},tC=function(g,te,tr){var to="";te.concat(tr).forEach(function(g){var te=null!=g.texData&&null!=g.texData.slice&&g.texData.slice.flatOffset>0,tr=g.isUniform?"uniform":g.texData.texShape;to+=g.shape+"_"+tr+"_"+te});var tu=g.userCode;return g.constructor.name+("_"+to)+"_"+tu}(g,ty,tb),tw=this.getAndSaveBinary(tC,function(){return function(g,te,tr,to){var tu=te.userCode,tc=tr.map(function(g,tr){var to={logicalShape:g.shape,texShape:g.isUniform?null:g.texData.texShape,isUniform:g.isUniform,isPacked:!g.isUniform&&g.texData.isPacked,flatOffset:null};return null!=g.texData&&null!=g.texData.slice&&g.texData.slice.flatOffset>0&&(to.flatOffset=g.texData.slice.flatOffset),{name:te.variableNames[tr],shapeInfo:to}}),tl=tc.map(function(g){return g.shapeInfo}),td={logicalShape:to.shape,texShape:to.texData.texShape,isUniform:!1,isPacked:to.texData.isPacked,flatOffset:null},tf=fa(tc,td,tu,te.packedInputs),tp=g.createProgram(tf),tv=null,tm=g.getUniformLocation(tp,"NAN",!1);1===th.getNumber("WEBGL_VERSION")&&(tv=g.getUniformLocation(tp,"INFINITY",!1));for(var tg={},ty=0;ty<te.variableNames.length;ty++){var tx=te.variableNames[ty];tg[tx]=g.getUniformLocation(tp,tx,!1),tg["offset"+tx]=g.getUniformLocation(tp,"offset"+tx,!1)}return{program:te,source:tf,webGLProgram:tp,uniformLocations:tg,inShapeInfos:tl,outShapeInfo:td,infLoc:tv,nanLoc:tm}}(tf.gpgpu,g,ty,tb)}),tE=null!=this.activeTimers;if(tE&&(tx=this.startTimer()),tc=this.gpgpu,Pi(tw.inShapeInfos,ty),Pi([tw.outShapeInfo],[tb]),tl=tb.texData.texture,td=tb.texData.texShape,tb.texData.isPacked?tc.setOutputPackedMatrixTexture(tl,td[0],td[1]):tc.setOutputMatrixTexture(tl,td[0],td[1]),tc.setProgram(tw.webGLProgram),1===th.getNumber("WEBGL_VERSION")&&null!==tw.infLoc&&tc.gl.uniform1f(tw.infLoc,1/0),null!==tw.nanLoc&&tc.gl.uniform1f(tw.nanLoc,NaN),ty.forEach(function(g,te){var tr=tw.program.variableNames[te],to=tw.uniformLocations[tr],tu=tw.uniformLocations["offset"+tr];if(null!=to){if(g.isUniform){if(2>k(g.shape))tc.gl.uniform1f(to,g.uniformValues[0]);else{var tl=g.uniformValues;tl instanceof Float32Array||(tl=new Float32Array(tl)),tc.gl.uniform1fv(to,tl)}}else null!=g.texData.slice&&null!=tu&&tc.gl.uniform1i(tu,g.texData.slice.flatOffset),tc.setInputMatrixTexture(g.texData.texture,to,te)}}),null!=to&&to(tc,tw.webGLProgram),tc.executeProgram(),tg.forEach(function(g){return tf.disposeData(g.dataId)}),tE&&(tx=this.endTimer(tx),this.activeTimers.push({name:g.constructor.name,query:this.getQueryTime(tx)})),!th.getBool("WEBGL_LAZILY_UNPACK")&&tv.isPacked&&!1===tu){var tR=this.unpackTensor(tp);return this.disposeData(tp.dataId),tR}return tp},o.prototype.compileAndRun=function(g,te,tr,to,tu){void 0===tu&&(tu=!1),tr=tr||te[0].dtype;var tc=this.runWebGLProgram(g,te,tr,to,tu);return tB.makeTensorFromDataId(tc.dataId,tc.shape,tc.dtype)},o.prototype.getAndSaveBinary=function(g,te){return g in this.binaryCache||(this.binaryCache[g]=te()),this.binaryCache[g]},o.prototype.getTextureManager=function(){return this.textureManager},o.prototype.dispose=function(){var g=this;this.disposed||(th.getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(function(te){g.gpgpu.deleteProgram(g.binaryCache[te].webGLProgram),delete g.binaryCache[te]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)},o.prototype.floatPrecision=function(){var g=this;return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Ze(function(){if(!th.get("WEBGL_RENDER_FLOAT32_ENABLED")){var te=th.getBool("DEBUG");th.set("DEBUG",!1);var tr=g.abs(On(1e-8)).dataSync()[0];if(th.set("DEBUG",te),tr>0)return 32}return 16})),this.floatPrecisionValue},o.prototype.epsilon=function(){return 32===this.floatPrecision()?1e-7:1e-4},o.prototype.uploadToGPU=function(g){var te,tr=this.texData.get(g),to=tr.shape,tu=tr.dtype,tc=tr.values,tl=tr.texture,th=tr.usage,td=tr.isPacked;if(null==tl){var tf,tp=null!=this.activeTimers;tp&&(tf=et());var tv=tr.texShape;if(null==tv&&(tv=Ne(to,td),tr.texShape=tv),null!=tc){var tm=Te(to),tg=void 0,ty=tv[1],tx=tv[0],tb=tc instanceof Uint8Array;td?(ty=(te=$t(tv[0],tv[1]))[0],tg=new hi(tm,[tx=te[1],ty],tb)):tg=new li(tm,[tx,ty],tb);var tC=this.makeTensorInfo([tx,ty],tu);this.texData.get(tC.dataId).usage=tb?tW.PIXELS:tW.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(tC.dataId),ty,tx,tc);var tw=this.runWebGLProgram(tg,[tC],tu,null,!0),tE=this.texData.get(tw.dataId);tr.texture=tE.texture,tr.texShape=tE.texShape,tr.isPacked=tE.isPacked,tr.usage=tE.usage,this.disposeData(tC.dataId),this.texData.delete(tw.dataId),tr.values=null,tp&&(this.uploadWaitMs+=et()-tf)}else{var tR=this.acquireTexture(tv,th,tu,td);tr.texture=tR}}},o.prototype.convertAndCacheOnCPU=function(g,te){var tr=this.texData.get(g),to=tr.dtype;return this.releaseGPUData(g),null!=te&&(tr.values=function(g,te){if("float32"===te||"complex64"===te)return g;if("int32"===te||"bool"===te){for(var tr="int32"===te?new Int32Array(g.length):new Uint8Array(g.length),to=0;to<tr.length;++to)tr[to]=Math.round(g[to]);return tr}throw Error("Unknown dtype "+te)}(te,to)),tr.values},o.prototype.acquireTexture=function(g,te,tr,to){if(this.numBytesInGPU+=this.computeBytes(g,tr),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){var tu=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: "+tu+" MB, most likely due to a memory leak")}return this.textureManager.acquireTexture(g,te,to)},o.prototype.computeBytes=function(g,te){return g[0]*g[1]*z(te)},o}(nq);Wt()&&tB.registerBackend("webgl",function(){return new e_},2);var eM=An({square_:function(g){var te=mn(g,"x","square"),tr=[te];return tB.runKernelFunc(function(g,tr){return tr([te]),g.square(te)},{x:te},null,"Square",{},tr,[])}}),eB="SquaredDifference",eP=An({squaredDifference_:function(g,te){var tr,to=mn(g,"a","squaredDifference"),tu=mn(te,"b","squaredDifference");to=(tr=Nt(to,tu))[0],tu=tr[1],Ro(to.shape,tu.shape);var tc={a:to,b:tu},tl=[to,tu];return tB.runKernelFunc(function(g,te){var tr=g.squaredDifference(to,tu);return te([to,tu]),tr},tc,function(g,te){var tr=te[0],to=te[1],tu=On(2);return{a:function(){return g.mul(tr.sub(to).mul(tu))},b:function(){return g.mul(to.sub(tr).mul(tu))}}},eB,{},tl,[])}}),eL=An({abs_:function(g){var te=mn(g,"x","abs");return"complex64"===te.dtype?tB.runKernelFunc(function(g){return g.complexAbs(te)},{$x:te}):tB.runKernelFunc(function(g,tr){var to=g.abs(te);return tr([te]),to},{x:te},function(g,te){var tr=te[0];return{x:function(){return g.mul(tr.toFloat().step(-1))}}},"Abs")}}),eW=An({acos_:function(g){var te=mn(g,"x","acos");return tB.runKernelFunc(function(g,tr){var to=g.acos(te);return tr([te]),to},{$x:te},function(g,te){var tr=te[0];return{$x:function(){return g.divStrict(On(1).sub(tr.toFloat().square()).sqrt()).neg()}}})}}),eV=An({acosh_:function(g){var te=mn(g,"x","acosh");return tB.runKernelFunc(function(g,tr){var to=g.acosh(te);return tr([te]),to},{$x:te},function(g,te){var tr=te[0];return{$x:function(){return g.divStrict(tr.toFloat().square().sub(1).sqrt())}}})}}),eU=An({asin_:function(g){var te=mn(g,"x","asin");return tB.runKernelFunc(function(g,tr){var to=g.asin(te);return tr([te]),to},{$x:te},function(g,te){var tr=te[0];return{$x:function(){return g.divStrict(On(1).sub(tr.toFloat().square()).sqrt())}}})}}),ez=An({asinh_:function(g){var te=mn(g,"x","asinh");return tB.runKernelFunc(function(g,tr){var to=g.asinh(te);return tr([te]),to},{$x:te},function(g,te){var tr=te[0];return{$x:function(){return g.divStrict(On(1).add(tr.toFloat().square()).sqrt())}}})}}),eH=An({atan_:function(g){var te=mn(g,"x","atan");return tB.runKernelFunc(function(g,tr){var to=g.atan(te);return tr([te]),to},{$x:te},function(g,te){var tr=te[0];return{$x:function(){return g.div(tr.toFloat().square().add(1))}}})}}),eG=An({atanh_:function(g){var te=mn(g,"x","atanh");return tB.runKernelFunc(function(g,tr){var to=g.atanh(te);return tr([te]),to},{$x:te},function(g,te){var tr=te[0];return{$x:function(){return g.div(On(1).sub(tr.toFloat().square()))}}})}}),eq=An({ceil_:function(g){var te=mn(g,"x","ceil");return tB.runKernelFunc(function(g){return g.ceil(te)},{$x:te},function(g){return{$x:function(){return t1(g)}}})}}),eK=An({clipByValue_:function(g,te,tr){var to=mn(g,"x","clipByValue");C(te<=tr,function(){return"Error in clip: min ("+te+") must be less than or equal to max ("+tr+")."});var tu=[to];return tB.runKernelFunc(function(g,tu){var tc=g.clip(to,te,tr);return tu([to]),tc},{x:to},function(g,to){var tu=to[0];return{x:function(){return g.where(tu.greaterEqual(te).logicalAnd(tu.lessEqual(tr)),t1(g))}}},"ClipByValue",{min:te,max:tr},tu)}}),ej=An({cos_:function(g){var te=mn(g,"x","cos"),tr=[te];return tB.runKernelFunc(function(g,tr){var to=g.cos(te);return tr([te]),to},{x:te},function(g,te){var tr=te[0];return{x:function(){return tr.toFloat().sin().neg().mul(g)}}},"Cos",{},tr)}}),eX=An({cosh_:function(g){var te=mn(g,"x","cosh");return tB.runKernelFunc(function(g,tr){var to=g.cosh(te);return tr([te]),to},{$x:te},function(g,te){var tr=te[0];return{$x:function(){return tr.toFloat().sinh().mulStrict(g)}}})}}),e$=An({erf_:function(g){var te=mn(g,"x","erf");return C("int32"===te.dtype||"float32"===te.dtype,function(){return"Input dtype must be `int32` or `float32`."}),"int32"===te.dtype&&(te=te.toFloat()),tB.runKernelFunc(function(g,tr){var to=g.erf(te);return tr([te]),to},{$x:te},function(g,te){var tr=te[0];return{$x:function(){return g.mul(tr.square().neg().exp().mul(2/Math.sqrt(Math.PI)))}}})}}),eY=An({exp_:function(g){var te=mn(g,"x","exp");return tB.runKernelFunc(function(g,tr){var to=g.exp(te);return tr([to]),to},{x:te},function(g,te){return{x:function(){return g.mulStrict(te[0])}}},"Exp",{},[],[!0])}}),eJ=An({expm1_:function(g){var te=mn(g,"x","expm1");return tB.runKernelFunc(function(g,tr){var to=g.expm1(te);return tr([te]),to},{$x:te},function(g,te){var tr=te[0];return{$x:function(){return g.mul(tr.exp())}}})}}),eQ=An({floor_:function(g){var te=mn(g,"x","floor");return tB.runKernelFunc(function(g){return g.floor(te)},{$x:te},function(g){return{$x:function(){return t1(g)}}})}}),eZ=An({log_:function(g){var te=mn(g,"x","log"),tr=[te];return tB.runKernelFunc(function(g,tr){var to=g.log(te);return tr([te]),to},{x:te},function(g,te){var tr=te[0];return{x:function(){return g.div(tr.toFloat())}}},"Log",{},tr)}}),e0=An({log1p_:function(g){var te=mn(g,"x","log1p");return tB.runKernelFunc(function(g,tr){var to=g.log1p(te);return tr([te]),to},{$x:te},function(g,te){var tr=te[0];return{$x:function(){return g.div(tr.add(1))}}})}}),e1=An({logSigmoid_:function(g){var te=mn(g,"x","logSigmoid");return tB.runKernelFunc(function(g,tr){var to=g.softplus(te.neg()).neg();return tr([te]),to},{$x:te},function(g,te){var tr=te[0];return{$x:function(){return g.mul(tr.neg().sigmoid())}}})}}),e2=An({neg_:function(g){var te=mn(g,"x","neg"),tr=[te];return tB.runKernelFunc(function(g){return g.neg(te)},{x:te},function(g){return{x:function(){return g.neg()}}},"Neg",{},tr)}}),e3=An({reciprocal_:function(g){var te=mn(g,"x","reciprocal");return tB.runKernelFunc(function(g,tr){var to=g.reciprocal(te);return tr([te]),to},{$x:te},function(g,te){var tr=te[0];return{$x:function(){return g.div(tr.square().neg())}}})}}),e4=An({round_:function(g){var te=mn(g,"x","round");return tB.runKernelFunc(function(g){return g.round(te)},{$x:te},function(g){return{$x:function(){return t1(g)}}})}}),e5=An({rsqrt_:function(g){var te=mn(g,"x","rsqrt"),tr=[te];return tB.runKernelFunc(function(g,tr){var to=g.rsqrt(te);return tr([te]),to},{x:te},function(g,te){var tr=te[0];return{x:function(){return g.div(tr.pow(1.5).mul(2)).neg()}}},"Rsqrt",{},tr)}}),e6=An({sigmoid_:function(g){var te=mn(g,"x","sigmoid");return tB.runKernelFunc(function(g,tr){var to=g.sigmoid(te);return tr([to]),to},{x:te},function(g,te){var tr=te[0];return{x:function(){return g.mul(tr.mul(On(1).sub(tr)))}}},"Sigmoid")}}),e8=An({sign_:function(g){var te=mn(g,"x","sign");return tB.runKernelFunc(function(g){return g.sign(te)},{$x:te},function(g){return{$x:function(){return t1(g)}}})}}),e7=An({isNaN_:function(g){var te=mn(g,"x","isNaN");return tB.runKernelFunc(function(g){return g.isNaN(te)},{$x:te},function(g){return{$x:function(){return t1(g)}}})}}),e9=An({isInf_:function(g){var te=mn(g,"x","isInf");return tB.runKernelFunc(function(g){return g.isInf(te)},{$x:te},function(g){return{$x:function(){return t1(g)}}})}}),rn=An({isFinite_:function(g){var te=mn(g,"x","isFinite");return tB.runKernelFunc(function(g){return g.isFinite(te)},{$x:te},function(g){return{$x:function(){return t1(g)}}})}}),rr=An({sin_:function(g){var te=mn(g,"x","sin"),tr=[te];return tB.runKernelFunc(function(g,tr){var to=g.sin(te);return tr([te]),to},{x:te},function(g,te){var tr=te[0];return{x:function(){return tr.toFloat().cos().mul(g)}}},"Sin",{},tr)}}),ru=An({sinh_:function(g){var te=mn(g,"x","sinh");return tB.runKernelFunc(function(g,tr){var to=g.sinh(te);return tr([te]),to},{$x:te},function(g,te){var tr=te[0];return{$x:function(){return tr.toFloat().cosh().mulStrict(g)}}})}}),rc=An({softplus_:function(g){var te=mn(g,"x","softplus");return tB.runKernelFunc(function(g,tr){var to=g.softplus(te);return tr([te]),to},{$x:te},function(g,te){var tr=te[0];return{$x:function(){return g.mul(tr.sigmoid())}}})}}),rl=An({sqrt_:function(g){var te=mn(g,"x","sqrt");return tB.runKernelFunc(function(g,tr){var to=g.sqrt(te);return tr([te]),to},{$x:te},function(g,te){var tr=te[0];return{$x:function(){return g.div(tr.toFloat().sqrt().mul(2))}}})}}),rd=An({step_:function(g,te){void 0===te&&(te=0);var tr=mn(g,"x","step");return tB.runKernelFunc(function(g){return g.step(tr,te)},{$x:tr},function(g){return{$x:function(){return t1(g)}}})}}),rf=An({tan_:function(g){var te=mn(g,"x","tan");return tB.runKernelFunc(function(g,tr){var to=g.tan(te);return tr([te]),to},{$x:te},function(g,te){var tr=te[0];return{$x:function(){return g.div(tr.cos().square())}}})}}),rp=An({tanh_:function(g){var te=mn(g,"x","tanh");return tB.runKernelFunc(function(g,tr){var to=g.tanh(te);return tr([to]),to},{x:te},function(g,te){var tr=te[0];return{x:function(){return On(1).sub(tr.square()).mulStrict(g)}}},"Tanh",{},null,[!0])}});function Pu(g,te,tr,to,tu,tc){var tl,th,td=mn(g,"x","batchNorm"),tf=mn(te,"mean","batchNorm"),tp=mn(tr,"variance","batchNorm");return null!=tu&&(tl=mn(tu,"scale","batchNorm")),null!=to&&(th=mn(to,"offset","batchNorm")),C(2===td.rank,function(){return"Error in batchNorm3D: x must be rank 3 but got rank "+td.rank+"."}),C(2===tf.rank||1===tf.rank,function(){return"Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank "+tf.rank+"."}),C(2===tp.rank||1===tp.rank,function(){return"Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank "+tp.rank+"."}),null!=tl&&C(2===tl.rank||1===tl.rank,function(){return"Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank "+tl.rank+"."}),null!=th&&C(2===th.rank||1===th.rank,function(){return"Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank "+th.rank+"."}),Uu(td,tf,tp,th,tl,tc)}function Lu(g,te,tr,to,tu,tc){var tl,th,td=mn(g,"x","batchNorm"),tf=mn(te,"mean","batchNorm"),tp=mn(tr,"variance","batchNorm");return null!=tu&&(tl=mn(tu,"scale","batchNorm")),null!=to&&(th=mn(to,"offset","batchNorm")),C(3===td.rank,function(){return"Error in batchNorm3D: x must be rank 3 but got rank "+td.rank+"."}),C(3===tf.rank||1===tf.rank,function(){return"Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank "+tf.rank+"."}),C(3===tp.rank||1===tp.rank,function(){return"Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank "+tp.rank+"."}),null!=tl&&C(3===tl.rank||1===tl.rank,function(){return"Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank "+tl.rank+"."}),null!=th&&C(3===th.rank||1===th.rank,function(){return"Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank "+th.rank+"."}),Uu(td,tf,tp,th,tl,tc)}function Wu(g,te,tr,to,tu,tc){var tl,th,td=mn(g,"x","batchNorm"),tf=mn(te,"mean","batchNorm"),tp=mn(tr,"variance","batchNorm");return null!=tu&&(tl=mn(tu,"scale","batchNorm")),null!=to&&(th=mn(to,"offset","batchNorm")),C(4===td.rank,function(){return"Error in batchNorm4D: x must be rank 4 but got rank "+td.rank+"."}),C(4===tf.rank||1===tf.rank,function(){return"Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank "+tf.rank+"."}),C(4===tp.rank||1===tp.rank,function(){return"Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank "+tp.rank+"."}),null!=tl&&C(4===tl.rank||1===tl.rank,function(){return"Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank "+tl.rank+"."}),null!=th&&C(4===th.rank||1===th.rank,function(){return"Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank "+th.rank+"."}),Uu(td,tf,tp,th,tl,tc)}function Uu(g,te,tr,to,tu,tc){null==tc&&(tc=.001);var tl,th,td,tf=mn(g,"x","batchNorm"),tp=mn(te,"mean","batchNorm"),tv=mn(tr,"variance","batchNorm");null!=tu&&(tl=mn(tu,"scale","batchNorm")),null!=to&&(th=mn(to,"offset","batchNorm")),C(tp.rank===tv.rank,function(){return"Batch normalization gradient requires mean and variance to have equal ranks."}),C(null==th||tp.rank===th.rank,function(){return"Batch normalization gradient requires mean and offset to have equal ranks."}),C(null==tl||tp.rank===tl.rank,function(){return"Batch normalization gradient requires mean and scale to have equal ranks."}),td=0===tf.rank||1===tf.rank?tf.as4D(1,1,1,tf.size):2===tf.rank?tf.as4D(1,1,tf.shape[0],tf.shape[1]):3===tf.rank?tf.as4D(1,tf.shape[0],tf.shape[1],tf.shape[2]):tf;var tm=[tf,tp,tv,tl];return tB.runKernelFunc(function(g,te){var tr=g.batchNormalization(td,Vu(tp),Vu(tv),tc,Vu(tl),Vu(th));return te([tf,tp,tv,tl]),tr},{x:tf,mean:tp,variance:tv,scale:tl,offset:th},function(g,te){var tr=te[0],to=te[1],tu=te[2],tl=te[3],th=null==tl?On(1):tl,tf=Eo(to.shape,td.shape),tp=[];if(1===to.rank){for(var tv=0;tv<td.shape.length-1;++tv)tp.push(td.shape[tv]);tp.push(1)}var tm=tr.sub(to),tg=g.mul(th),ty=e5(tu.add(On(tc))),tx=ty.mul(ty).mul(ty).mul(On(-.5));return{x:function(){return 1===to.rank?g.mul(nW(ty.as4D(1,1,1,to.shape[0]),tp)).mul(th).reshape(tr.shape):g.mul(ty).mul(th).reshape(tr.shape)},mean:function(){var g=ty.mul(On(-1)).mul(tg);return 1===to.rank&&(g=g.sum(tf)),g.reshape(to.shape)},variance:function(){var g=tx.mul(tm).mul(tg);return 1===to.rank&&(g=g.sum(tf)),g.reshape(to.shape)},scale:function(){var te=tm.mul(ty),tr=g.mul(te);return 1===to.rank&&(tr=tr.sum(tf)),tr.reshape(to.shape)},offset:function(){var te=g;return 1===to.rank&&(te=te.sum(tf)),te.reshape(to.shape)}}},"BatchNormalization",{varianceEpsilon:tc},tm).reshape(tf.shape)}function Vu(g){return null==g?null:0===g.rank?g.as1D():1===g.rank?g:2===g.rank?g.as4D(1,1,g.shape[0],g.shape[1]):3===g.rank?g.as4D(1,g.shape[0],g.shape[1],g.shape[2]):g}function zu(){Xe("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon")}var rv=An({batchNormalization2d_:function(g,te,tr,to,tu,tc){return void 0===to&&(to=.001),zu(),Pu(g,te,tr,tc,tu,to)}}),rm=An({batchNormalization3d_:function(g,te,tr,to,tu,tc){return void 0===to&&(to=.001),zu(),Lu(g,te,tr,tc,tu,to)}}),rg=An({batchNormalization4d_:function(g,te,tr,to,tu,tc){return void 0===to&&(to=.001),zu(),Wu(g,te,tr,tc,tu,to)}}),ry=An({batchNormalization_:function(g,te,tr,to,tu,tc){return void 0===to&&(to=.001),zu(),Uu(g,te,tr,tc,tu,to)}}),rx=An({batchNorm_:Uu}),rb=An({batchNorm2d_:Pu}),rC=An({batchNorm3d_:Lu}),rw=An({batchNorm4d_:Wu}),rE=An({logicalAnd_:function(g,te){var tr=mn(g,"a","logicalAnd","bool"),to=mn(te,"b","logicalAnd","bool");return Ro(tr.shape,to.shape),tB.runKernelFunc(function(g){return g.logicalAnd(tr,to)},{a:tr,b:to},null,"LogicalAnd")}}),rR=An({logicalNot_:function(g){var te=mn(g,"x","logicalNot","bool");return tB.runKernelFunc(function(g){return g.logicalNot(te)},{$x:te})}}),rI=An({logicalOr_:function(g,te){var tr=mn(g,"a","logicalOr","bool"),to=mn(te,"b","logicalOr","bool");return Ro(tr.shape,to.shape),tB.runKernelFunc(function(g){return g.logicalOr(tr,to)},{$a:tr,$b:to})}}),rk=An({logicalXor_:function(g,te){var tr=mn(g,"a","logicalXor","bool"),to=mn(te,"b","logicalXor","bool");return Ro(tr.shape,to.shape),rI(g,te).logicalAnd(rE(g,te).logicalNot())}}),rA=An({where_:function(g,te,tr){var to=mn(te,"a","where"),tu=mn(tr,"b","where"),tc=mn(g,"condition","where","bool");return E(to.shape,tu.shape,"Error in where: "),1===tc.rank?C(tc.shape[0]===to.shape[0],function(){return"The first dimension of `a` must match the size of `condition`."}):E(tc.shape,tu.shape,"Error in where: "),tB.runKernelFunc(function(g,te){var tr=g.select(tc,to,tu);return te([tc]),tr},{$condition:tc,$a:to,$b:tu},function(g,te){var tr=te[0];return{$condition:function(){return t1(tr).toFloat()},$a:function(){return g.mul(tr.cast(g.dtype))},$b:function(){return g.mul(tr.logicalNot().cast(g.dtype))}}})}}),nc=function(g){return n(this,void 0,void 0,function(){var te,tr,to;return r(this,function(tu){switch(tu.label){case 0:return[4,(te=mn(g,"condition","whereAsync","bool")).data()];case 1:return tr=tu.sent(),to=na(te.shape,tr),g!==te&&te.dispose(),[2,to]}})})},rS=An({add_:function(g,te){var tr,to=mn(g,"a","add"),tu=mn(te,"b","add");to=(tr=Nt(to,tu))[0],tu=tr[1];var tc=Ro(to.shape,tu.shape);return tB.runKernelFunc(function(g){return g.add(to,tu)},{a:to,b:tu},function(g){return{a:function(){var te=g,tr=Eo(to.shape,tc);return tr.length>0&&(te=te.sum(tr)),te.reshape(to.shape)},b:function(){var te=g,tr=Eo(tu.shape,tc);return tr.length>0&&(te=te.sum(tr)),te.reshape(tu.shape)}}},"Add")}}),rD=An({addN_:function(g){C(Array.isArray(g),function(){return"The argument passed to tf.addN() must be a list of tensors"}),C(g.length>=1,function(){return"Must pass at least one tensor to tf.addN(), but got "+g.length});var te=g.map(function(g,te){return mn(g,"tensors"+te,"addN")}),tr=te[0];return te.forEach(function(g){if(g.dtype!==tr.dtype)throw Error("All tensors passed to tf.addN() must have the same dtype")}),te.forEach(function(g){if(!S(g.shape,tr.shape))throw Error("All tensors passed to tf.addN() must have the same shape")}),tB.runKernelFunc(function(g){return g.addN(te)},te,function(g){var tr={};return te.forEach(function(te,to){tr[to]=function(){return g.clone()}}),tr},"AddN")}}),rN=An({addStrict_:function(g,te){var tr=mn(g,"a","addStrict"),to=mn(te,"b","addStrict");return E(tr.shape,to.shape,"Error in addStrict: "),tr.add(to)}}),rT=An({atan2_:function(g,te){var tr,to=mn(g,"a","atan2"),tu=mn(te,"b","atan2");to=(tr=Nt(to,tu))[0],tu=tr[1];var tc=Ro(to.shape,tu.shape);return tB.runKernelFunc(function(g,te){var tr=g.atan2(to,tu);return te([to,tu]),tr},{$a:to,$b:tu},function(g,te){var tr=te[0],to=te[1];return{$a:function(){var te=rS(tr.square(),to.square()),tu=g.mul(to.div(te)),tl=Eo(tr.shape,tc);return tl.length>0&&(tu=tu.sum(tl)),tu.reshape(tr.shape)},$b:function(){var te=rS(tr.square(),to.square()),tu=e2(g.mul(tr.div(te))),tl=Eo(to.shape,tc);return tl.length>0&&(tu=tu.sum(tl)),tu.reshape(to.shape)}}})}}),rF=An({div_:function(g,te){var tr,to=mn(g,"a","div"),tu=mn(te,"b","div");if(to=(tr=Nt(to,tu))[0],tu=tr[1],"int32"===to.dtype&&"int32"===tu.dtype)return rM(to,tu);var tc=Ro(to.shape,tu.shape);return tB.runKernelFunc(function(g,te){var tr=g.realDivide(to,tu);return te([to,tu]),tr},{a:to,b:tu},function(g,te){var tr=te[0],to=te[1];return{a:function(){var te=g.div(to.toFloat()),tu=Eo(tr.shape,tc);return tu.length>0?te.sum(tu).reshape(tr.shape):te},b:function(){var te=g.mul(tr.toFloat()),tu=Eo(to.shape,tc);tu.length>0&&(te=te.sum(tu).reshape(to.shape));var tl=to.square();return te.div(tl.toFloat()).neg()}}},"Div")}}),rO=An({divNoNan_:function(g,te){var tr,to=mn(g,"a","div"),tu=mn(te,"b","div"),tc=rF(to=(tr=Nt(to,tu))[0],tu=tr[1]),tl=t1(tc);return rA(tu.equal(tl),tl,tc)}}),r_=An({divStrict_:function(g,te){var tr=mn(g,"a","div"),to=mn(te,"b","div");return E(tr.shape,to.shape,"Error in divideStrict: "),tr.div(to)}}),rM=An({floorDiv_:function(g,te){var tr,to=mn(g,"a","floorDiv"),tu=mn(te,"b","floorDiv");to=(tr=Nt(to,tu))[0],tu=tr[1];var tc=Ro(to.shape,tu.shape);return tB.runKernelFunc(function(g,te){var tr=g.floorDiv(to,tu);return te([to,tu]),tr},{a:to,b:tu},function(g,te){var tr=te[0],to=te[1];return{a:function(){var te=g.div(to.toFloat()),tu=Eo(tr.shape,tc);return tu.length>0?te.sum(tu).reshape(tr.shape):te},b:function(){var te=g.mul(tr.toFloat()),tu=Eo(to.shape,tc);tu.length>0&&(te=te.sum(tu).reshape(to.shape));var tl=to.square();return te.div(tl.toFloat()).neg()}}},"FloorDiv")}}),rB=An({maximum_:function(g,te){var tr,to=mn(g,"a","maximum"),tu=mn(te,"b","maximum");return to=(tr=Nt(to,tu))[0],tu=tr[1],"bool"===to.dtype&&(to=to.toInt(),tu=tu.toInt()),Ro(to.shape,tu.shape),tB.runKernelFunc(function(g,te){var tr=g.maximum(to,tu);return te([to,tu]),tr},{a:to,b:tu},function(g,te){var tr=te[0],to=te[1];return{a:function(){return g.mul(tr.greaterEqual(to).toFloat())},b:function(){return g.mul(tr.less(to).toFloat())}}},"Maximum")}}),rP=An({maximumStrict_:function(g,te){var tr=mn(g,"a","maximumStrict"),to=mn(te,"b","maximumStrict");return E(tr.shape,to.shape,"Error in maximumStrict: "),tr.maximum(to)}}),rL=An({minimum_:function(g,te){var tr,to=mn(g,"a","minimum"),tu=mn(te,"b","minimum");return to=(tr=Nt(to,tu))[0],tu=tr[1],"bool"===to.dtype&&(to=to.toInt(),tu=tu.toInt()),Ro(to.shape,tu.shape),tB.runKernelFunc(function(g,te){var tr=g.minimum(to,tu);return te([to,tu]),tr},{a:to,b:tu},function(g,te){var tr=te[0],to=te[1];return{a:function(){return g.mul(tr.lessEqual(to).toFloat())},b:function(){return g.mul(tr.greater(to).toFloat())}}},"Minimum")}}),rW=An({minimumStrict_:function(g,te){var tr=mn(g,"a","minimumStrict"),to=mn(te,"b","minimumStrict");return E(tr.shape,to.shape,"Error in minimumStrict: "),tr.minimum(to)}}),rV=An({mod_:function(g,te){var tr,to=mn(g,"a","mod"),tu=mn(te,"b","mod");to=(tr=Nt(to,tu))[0],tu=tr[1];var tc=Ro(to.shape,tu.shape);return tB.runKernelFunc(function(g,te){var tr=g.mod(to,tu);return te([to,tu]),tr},{$a:to,$b:tu},function(g,te){var tr=te[0],to=te[1];return{$a:function(){var te=Eo(tr.shape,tc);return te.length>0?g.sum(te).reshape(tr.shape):g},$b:function(){var te=g.mul(tr.div(to).floor().neg()),tu=Eo(to.shape,tc);return tu.length>0?te.sum(tu).reshape(to.shape):te}}})}}),rU=An({modStrict_:function(g,te){var tr=mn(g,"a","modStrict"),to=mn(te,"b","modStrict");return E(tr.shape,to.shape,"Error in modStrict: "),tr.mod(to)}}),rz=An({mul_:function(g,te){var tr,to=mn(g,"a","mul"),tu=mn(te,"b","mul");to=(tr=Nt(to,tu))[0],tu=tr[1];var tc=Ro(to.shape,tu.shape);return tB.runKernelFunc(function(g,te){var tr=g.multiply(to,tu);return te([to,tu]),tr},{a:to,b:tu},function(g,te){var tr=te[0],to=te[1];return{a:function(){var te=g.mul(to.toFloat()),tu=Eo(tr.shape,tc);return tu.length>0?te.sum(tu).reshape(tr.shape):te},b:function(){var te=g.mul(tr.toFloat()),tu=Eo(to.shape,tc);return tu.length>0?te.sum(tu).reshape(to.shape):te}}},"Mul")}}),rH=An({mulStrict_:function(g,te){var tr=mn(g,"a","mul"),to=mn(te,"b","mul");return E(tr.shape,to.shape,"Error in multiplyStrict: "),tr.mul(to)}}),rG=An({pow_:function(g,te){var tr,to=mn(g,"base","pow"),tu=mn(te,"exp","pow");to=(tr=Nt(to,tu))[0],tu=tr[1];var tc=Ro(to.shape,tu.shape),tl=[to,tu];return tB.runKernelFunc(function(g,te){var tr=g.pow(to,tu);return te([to,tu,tr]),tr},{a:to,b:tu},function(g,te){var tr=te[0],to=te[1],tu=te[2];return{a:function(){var te=to.toFloat(),tu=g.mul(te.mul(tr.pow(te.sub(On(1))))),tl=Eo(tr.shape,tc);return tl.length>0&&(tu=tu.sum(tl)),tu.reshape(tr.shape)},b:function(){var te=tr.greater(0),tl=tr.log().where(te,t1(tr)),th=g.mul(tu.mul(tl)),td=Eo(to.shape,tc);return td.length>0&&(th=th.sum(td)),th.reshape(to.shape)}}},"Pow",{},tl,[!0])}}),rq=An({powStrict_:function(g,te){return E(g.shape,te.shape,"Error in powStrict: "),g.pow(te)}}),rK=An({squaredDifferenceStrict_:function(g,te){var tr=mn(g,"a","squaredDifferenceStrict"),to=mn(te,"b","squaredDifferenceStrict");return E(tr.shape,to.shape,"Error in squaredDifferenceStrict: "),tr.squaredDifference(to)}}),rj=An({sub_:function(g,te){var tr,to=mn(g,"a","sub"),tu=mn(te,"b","sub");to=(tr=Nt(to,tu))[0],tu=tr[1];var tc=Ro(to.shape,tu.shape);return tB.runKernelFunc(function(g){return g.subtract(to,tu)},{a:to,b:tu},function(g){return{a:function(){var te=g,tr=Eo(to.shape,tc);return tr.length>0&&(te=te.sum(tr)),te.reshape(to.shape)},b:function(){var te=g,tr=Eo(tu.shape,tc);return tr.length>0&&(te=te.sum(tr)),te.neg().reshape(tu.shape)}}},"Sub")}}),rX=An({subStrict_:function(g,te){var tr=mn(g,"a","subStrict"),to=mn(te,"b","subStrict");return E(tr.shape,to.shape,"Error in subStrict: "),tr.sub(to)}}),r$=An({equal_:function(g,te){var tr,to=mn(g,"a","equal"),tu=mn(te,"b","equal");return to=(tr=Nt(to,tu))[0],tu=tr[1],Ro(to.shape,tu.shape),tB.runKernelFunc(function(g){return g.equal(to,tu)},{$a:to,$b:tu})}}),rY=An({equalStrict_:function(g,te){var tr=mn(g,"a","equalStrict"),to=mn(te,"b","equalStrict");return E(tr.shape,to.shape,"Error in equalStrict: "),tr.equal(to)}}),rJ=An({greater_:function(g,te){var tr,to=mn(g,"a","greater"),tu=mn(te,"b","greater");return to=(tr=Nt(to,tu))[0],tu=tr[1],Ro(to.shape,tu.shape),tB.runKernelFunc(function(g){return g.greater(to,tu)},{a:to,b:tu},null,"Greater")}}),rQ=An({greaterEqual_:function(g,te){var tr,to=mn(g,"a","greaterEqual"),tu=mn(te,"b","greaterEqual");return to=(tr=Nt(to,tu))[0],tu=tr[1],Ro(to.shape,tu.shape),tB.runKernelFunc(function(g,te){var tr=g.greaterEqual(to,tu);return te([to,tu]),tr},{a:to,b:tu},function(g,te){var tr=te[0],to=te[1];return{a:function(){return t1(tr)},b:function(){return t1(to)}}},"GreaterEqual")}}),rZ=An({greaterEqualStrict_:function(g,te){var tr=mn(g,"a","greaterEqualStrict"),to=mn(te,"b","greaterEqualStrict");return E(tr.shape,to.shape,"Error in greaterEqualStrict: "),tr.greaterEqual(to)}}),r0=An({greaterStrict_:function(g,te){var tr=mn(g,"a","greaterStrict"),to=mn(te,"b","greaterStrict");return E(tr.shape,to.shape,"Error in greaterStrict: "),tr.greater(to)}}),r1=An({less_:function(g,te){var tr,to=mn(g,"a","less"),tu=mn(te,"b","less");return to=(tr=Nt(to,tu))[0],tu=tr[1],Ro(to.shape,tu.shape),tB.runKernelFunc(function(g){return g.less(to,tu)},{a:to,b:tu},null,"Less")}}),r2=An({lessEqual_:function(g,te){var tr,to=mn(g,"a","lessEqual"),tu=mn(te,"b","lessEqual");return to=(tr=Nt(to,tu))[0],tu=tr[1],Ro(to.shape,tu.shape),tB.runKernelFunc(function(g,te){var tr=g.lessEqual(to,tu);return te([to,tu]),tr},{a:to,b:tu},null,"LessEqual")}}),r3=An({lessEqualStrict_:function(g,te){var tr=mn(g,"a","lessEqualStrict"),to=mn(te,"b","lessEqualStrict");return E(tr.shape,to.shape,"Error in lessEqualStrict: "),tr.lessEqual(to)}}),r4=An({lessStrict_:function(g,te){var tr=mn(g,"a","lessStrict"),to=mn(te,"b","lessStrict");return E(tr.shape,to.shape,"Error in lessStrict: "),tr.less(to)}}),r5=An({notEqual_:function(g,te){var tr,to=mn(g,"a","notEqual"),tu=mn(te,"b","notEqual");return to=(tr=Nt(to,tu))[0],tu=tr[1],Ro(to.shape,tu.shape),tB.runKernelFunc(function(g){return g.notEqual(to,tu)},{a:to,b:tu},null,"NotEqual")}}),r6=An({notEqualStrict_:function(g,te){var tr=mn(g,"a","notEqualStrict"),to=mn(te,"b","notEqualStrict");return E(tr.shape,to.shape,"Error in notEqualStrict: "),tr.notEqual(to)}});function Bc(g,te){for(var tr=[],to=g;to<te;++to)tr.push(to);return tr}function Pc(g){for(var te=[],tr=0;tr<g.length;++tr)for(var to=0;to<g[tr].length;++to)te.push(g[tr][to]);return te}var r8=An({gather_:function(g,te,tr){void 0===tr&&(tr=0);var to=mn(g,"x","gather"),tu=mn(te,"indices","gather","int32");tr=O(tr,to.shape)[0];var tc=function(g,te,tr){for(var to=g.shape[tr],tu=[],tc=1,tl=1,th=0;th<tr;th++)tu.push(g.shape[th]),tc*=g.shape[th];for(th=0;th<te.rank;th++)tu.push(te.shape[th]);for(th=tr+1;th<g.rank;th++)tu.push(g.shape[th]),tl*=g.shape[th];return{batchSize:tc,sliceSize:tl,dimSize:to,outputShape:tu}}(to,tu,tr);return tB.runKernelFunc(function(g,te){var tc=g.gather(to,tu.flatten(),tr);return te([tu]),tc},{x:to,indices:tu},function(g,te){var tu=te[0];return{x:function(){var te=to.shape,tc=tu.size,tl=te.slice(0,tr),th=tl.length,td=te.slice(tr,te.length).slice(1),tf=td.length,tp=Bc(0,th),tv=Bc(th+1,th+1+tf),tm=Pc([tl,[tc],td]),tg=g.reshape(tm),ty=tu.reshape([tc]),tx=Pc([[th],tp,tv]),tb=r7(tg.transpose(tx),ty,to.shape[tr]),tC=Rn(tx);return tb.transpose(tC)},indices:function(){return tu}}},"Gather",{axis:tr}).reshape(tc.outputShape)}}),r7=An({unsortedSegmentSum_:function(g,te,tr){var to=mn(g,"x","unsortedSegmentSum"),tu=mn(te,"segmentIds","unsortedSegmentSum","int32");return C(A(tr),function(){return"numSegments must be of dtype int"}),tB.runKernelFunc(function(g,te){var tc=g.unsortedSegmentSum(to,tu,tr);return te([tu]),tc},{$x:to},function(g,te){var tr=te[0];return{$x:function(){return function(g,te){for(var tr=rB(te,t1(te)),to=r8(g,tr),tu=rQ(te,On(0,"int32")),tc=to.rank-tu.rank,tl=0;tl<tc;++tl)tu=nw(tu,tl+1);tu=rE(tu,zn(to.shape,"bool"));var th=t1(to);return rA(tu,to,th)}(g,tr)}}})}});function Vc(g,te,tr,to,tu,tc,tl){void 0===tc&&(tc="NHWC"),C(g.length===te.rank,function(){return"Length of inShape ("+g.length+") and rank of dy ("+te.rank+") must match"});var th=g,td=te,tf=!1;3===te.rank&&(tf=!0,td=te.as4D(1,te.shape[0],te.shape[1],te.shape[2]),th=[1,g[0],g[1],g[2]]),C(4===th.length,function(){return"Error in conv2dDerInput: inShape must be length 4, but got length "+th.length+"."}),C(4===td.rank,function(){return"Error in conv2dDerInput: dy must be rank 4, but got rank "+td.rank}),C(4===tr.rank,function(){return"Error in conv2dDerInput: filter must be rank 4, but got rank "+tr.rank});var tp="NHWC"===tc?th[3]:th[1],tv="NHWC"===tc?td.shape[3]:td.shape[1];C(tp===tr.shape[2],function(){return"Error in conv2dDerInput: depth of input ("+tp+") must match input depth for filter "+tr.shape[2]+"."}),C(tv===tr.shape[3],function(){return"Error in conv2dDerInput: depth of output ("+tv+") must match output depth for filter "+tr.shape[3]+"."}),null!=tl&&C(A(tu),function(){return"Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode "+tl+" but got pad "+tu+"."});var tm=Bo(tc),tg=So(th,tr.shape,to,1,tu,tl,!1,tm),ty=tB.runKernelFunc(function(g,te){var to=g.conv2dDerInput(td,tr,tg);return te([tr,td]),to},{dy4D:td,filter:tr},function(g,te){var tr=te[0],th=te[1];return{dy4D:function(){return on(g,tr,to,tu,tc,1,tl)},filter:function(){return ou(g,th,tr.shape,to,tu,tc,tl)}}});return tf?ty.as3D(ty.shape[1],ty.shape[2],ty.shape[3]):ty}function zc(g){var te="number"==typeof g?[g,g,g]:2===g.length?[g[0],g[1],1]:g,tr=te[0],to=te[1],tu=te[2];return 1===tr&&1===to&&1===tu}function Gc(g,te,tr,to,tu){C(g.length===te.rank,function(){return"Length of inShape ("+g.length+") and rank of dy ("+te.rank+") must match"});var tc=g,tl=te,th=!1;4===te.rank&&(th=!0,tl=te.as5D(1,te.shape[0],te.shape[1],te.shape[2],te.shape[3]),tc=[1,g[0],g[1],g[2],g[3]]);var td=tc[4],tf=tl.shape[4];C(5===tc.length,function(){return"Error in conv3dDerInput: inShape must be length 5, but got length "+tc.length+"."}),C(5===tl.rank,function(){return"Error in conv3dDerInput: dy must be rank 5, but got rank "+tl.rank}),C(5===tr.rank,function(){return"Error in conv3dDerInput: filter must be rank 5, but got rank "+tr.rank}),C(td===tr.shape[3],function(){return"Error in conv3dDerInput: depth of input ("+td+") must match input depth for filter "+tr.shape[3]+"."}),C(tf===tr.shape[4],function(){return"Error in conv3dDerInput: depth of output ("+tf+") must match output depth for filter "+tr.shape[4]+"."});var tp=Ao(tc,tr.shape,to,1,tu),tv=tB.runKernelFunc(function(g){return g.conv3dDerInput(tl,tr,tp)},{dy5D:tl});return th?tv.as4D(tv.shape[1],tv.shape[2],tv.shape[3],tv.shape[4]):tv}var r9=An({conv1d_:function(g,te,tr,to,tu,tc,tl){void 0===tu&&(tu="NWC"),void 0===tc&&(tc=1);var th=mn(g,"x","conv1d"),td=mn(te,"filter","conv1d"),tf=th,tp=!1;2===th.rank&&(tp=!0,tf=th.as3D(1,th.shape[0],th.shape[1])),C(3===tf.rank,function(){return"Error in conv1d: input must be rank 3, but got rank "+tf.rank+"."}),C(3===td.rank,function(){return"Error in conv1d: filter must be rank 3, but got rank "+td.rank+"."}),null!=tl&&C(A(to),function(){return"Error in conv1d: pad must be an integer when using, dimRoundingMode "+tl+" but got pad "+to+"."}),C(tf.shape[2]===td.shape[1],function(){return"Error in conv1d: depth of input ("+tf.shape[2]+") must match input depth for filter "+td.shape[1]+"."}),C(Mo(tr,tc),function(){return"Error in conv1D: Either stride or dilation must be 1. Got stride "+tr+" and dilation '"+tc+"'"}),C("NWC"===tu,function(){return"Error in conv1d: got dataFormat of "+tu+" but only NWC is currently supported."});var tv=td.as4D(1,td.shape[0],td.shape[1],td.shape[2]),tm=on(tf.as4D(tf.shape[0],1,tf.shape[1],tf.shape[2]),tv,[1,tr],to,"NHWC",[1,tc],tl);return tp?tm.as2D(tm.shape[2],tm.shape[3]):tm.as3D(tm.shape[0],tm.shape[2],tm.shape[3])}}),on=An({conv2d_:function(g,te,tr,to,tu,tc,tl){void 0===tu&&(tu="NHWC"),void 0===tc&&(tc=[1,1]);var th=mn(g,"x","conv2d"),td=mn(te,"filter","conv2d"),tf=th,tp=!1;3===th.rank&&(tp=!0,tf=th.as4D(1,th.shape[0],th.shape[1],th.shape[2])),C(4===tf.rank,function(){return"Error in conv2d: input must be rank 4, but got rank "+tf.rank+"."}),C(4===td.rank,function(){return"Error in conv2d: filter must be rank 4, but got rank "+td.rank+"."}),null!=tl&&C(A(to),function(){return"Error in conv2d: pad must be an integer when using, dimRoundingMode "+tl+" but got pad "+to+"."});var tv="NHWC"===tu?tf.shape[3]:tf.shape[1];C(tv===td.shape[2],function(){return"Error in conv2d: depth of input ("+tv+") must match input depth for filter "+td.shape[2]+"."}),C(Mo(tr,tc),function(){return"Error in conv2D: Either strides or dilations must be 1. Got strides "+tr+" and dilations '"+tc+"'"});var tm=Bo(tu),tg=So(tf.shape,td.shape,tr,tc,to,tl,!1,tm),ty=[td,tf],tx=tB.runKernelFunc(function(g,te){var tr=g.conv2d(tf,td,tg);return te([td,tf]),tr},{x:tf,filter:td},function(g,te){var tl=te[0],th=te[1];return C(Oo(tc),function(){return"Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+tc+"'"}),{x:function(){return oc(th.shape,g,tl,tr,to,tu)},filter:function(){return ou(th,g,tl.shape,tr,to,tu)}}},"Conv2D",tg,ty);return tp?tx.as3D(tx.shape[1],tx.shape[2],tx.shape[3]):tx}}),or=An({conv3d_:function(g,te,tr,to,tu,tc){void 0===tu&&(tu="NDHWC"),void 0===tc&&(tc=[1,1,1]);var tl,th=mn(g,"x","conv3d"),td=mn(te,"filter","conv3d"),tf=th,tp=!1;4===th.rank&&(tp=!0,tf=th.as5D(1,th.shape[0],th.shape[1],th.shape[2],th.shape[3])),C(5===tf.rank,function(){return"Error in conv3d: input must be rank 5, but got rank "+tf.rank+"."}),C(5===td.rank,function(){return"Error in conv3d: filter must be rank 5, but got rank "+td.rank+"."}),C(tf.shape[4]===td.shape[3],function(){return"Error in conv3d: depth of input ("+tf.shape[4]+") must match input depth for filter "+td.shape[3]+"."}),C((tl=tc,zc(tr)||zc(tl)),function(){return"Error in conv3D: Either strides or dilations must be 1. Got strides "+tr+" and dilations '"+tc+"'"}),C("NDHWC"===tu,function(){return"Error in conv3d: got dataFormat of "+tu+" but only NDHWC is currently supported."});var tv=Ao(tf.shape,td.shape,tr,tc,to),tm=tB.runKernelFunc(function(g,te){var tr=g.conv3d(tf,td,tv);return te([tf,td]),tr},{x:tf,$filter:td},function(g,te){C(zc(tc),function(){return"Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+tc+"'"});var tu=te[0],tl=te[1];return{x:function(){return Gc(tu.shape,g,tl,tr,to)},$filter:function(){var te,tc,th,td;return te=tl.shape,tc=tu,4===tu.rank&&(tc=tu.as5D(1,tu.shape[0],tu.shape[1],tu.shape[2],tu.shape[3])),4===(th=g).rank&&(th=g.as5D(1,g.shape[0],g.shape[1],g.shape[2],g.shape[3])),C(5===tc.rank,function(){return"Error in conv3dDerFilter: input must be rank 5, but got shape "+tc.shape+"."}),C(5===th.rank,function(){return"Error in conv3dDerFilter: dy must be rank 5, but got shape "+th.shape+"."}),C(5===te.length,function(){return"Error in conv3dDerFilter: filterShape must be length 5, but got "+te+"."}),C(tc.shape[4]===te[3],function(){return"Error in conv3dDerFilter: depth of input "+tc.shape[4]+") must match input depth in filter ("+te[3]+"."}),C(th.shape[4]===te[4],function(){return"Error in conv3dDerFilter: depth of dy ("+th.shape[4]+") must match output depth for filter ("+te[4]+")."}),td=Ao(tc.shape,te,tr,1,to),tB.runKernelFunc(function(g){return g.conv3dDerFilter(tc,th,td)},{x5D:tc,dy5D:th})}}});return tp?tm.as4D(tm.shape[1],tm.shape[2],tm.shape[3],tm.shape[4]):tm}}),ou=An({conv2dDerFilter_:function(g,te,tr,to,tu,tc,tl){void 0===tc&&(tc="NHWC");var th=g;3===g.rank&&(th=g.as4D(1,g.shape[0],g.shape[1],g.shape[2]));var td=te;3===td.rank&&(td=te.as4D(1,te.shape[0],te.shape[1],te.shape[2])),C(4===th.rank,function(){return"Error in conv2dDerFilter: input must be rank 4, but got shape "+th.shape+"."}),C(4===td.rank,function(){return"Error in conv2dDerFilter: dy must be rank 4, but got shape "+td.shape+"."}),C(4===tr.length,function(){return"Error in conv2dDerFilter: filterShape must be length 4, but got "+tr+"."});var tf="NHWC"===tc?th.shape[3]:th.shape[1],tp="NHWC"===tc?td.shape[3]:td.shape[1];C(tf===tr[2],function(){return"Error in conv2dDerFilter: depth of input "+tf+") must match input depth in filter ("+tr[2]+"."}),C(tp===tr[3],function(){return"Error in conv2dDerFilter: depth of dy ("+tp+") must match output depth for filter ("+tr[3]+")."}),null!=tl&&C(A(tu),function(){return"Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode "+tl+" but got pad "+tu+"."});var tv=Bo(tc),tm=So(th.shape,tr,to,1,tu,tl,!1,tv);return tB.runKernelFunc(function(g){return g.conv2dDerFilter(th,td,tm)},{x4D:th,dy4D:td})}}),oc=An({conv2dDerInput_:Vc}),ol=An({depthwiseConv2d_:function(g,te,tr,to,tu,tc,tl){void 0===tu&&(tu="NHWC"),void 0===tc&&(tc=[1,1]);var th=mn(g,"x","depthwiseConv2d"),td=mn(te,"filter","depthwiseConv2d"),tf=th,tp=!1;3===th.rank&&(tp=!0,tf=th.as4D(1,th.shape[0],th.shape[1],th.shape[2])),C(4===tf.rank,function(){return"Error in depthwiseConv2d: input must be rank 4, but got rank "+tf.rank+"."}),C(4===td.rank,function(){return"Error in depthwiseConv2d: filter must be rank 4, but got rank "+td.rank+"."}),C(tf.shape[3]===td.shape[2],function(){return"Error in depthwiseConv2d: number of input channels ("+tf.shape[3]+") must match the inChannels dimension in filter "+td.shape[2]+"."}),null==tc&&(tc=[1,1]),C(Mo(tr,tc),function(){return"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+tr+" and dilations '"+tc+"'"}),null!=tl&&C(A(to),function(){return"Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode "+tl+" but got pad "+to+"."});var tv=So(tf.shape,td.shape,tr,tc,to,tl,!0),tm=[tf,td],tg=tB.runKernelFunc(function(g,te){var tr=g.depthwiseConv2D(tf,td,tv);return te([tf,td]),tr},{x:tf,filter:td},function(g,te){C(Oo(tc),function(){return"Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+tc+"'"});var tr=te[0],to=te[1];return{x:function(){return oh(tr.shape,g,to,tv)},filter:function(){return od(tr,g,to.shape,tv)}}},"DepthwiseConv2dNative",tv,tm);return tp?tg.as3D(tg.shape[1],tg.shape[2],tg.shape[3]):tg}}),oh=An({depthwiseConv2dDerInput_:function(g,te,tr,to){var tu=te,tc=!1;3===te.rank&&(tc=!0,tu=te.as4D(1,te.shape[0],te.shape[1],te.shape[2]));var tl=tB.runKernelFunc(function(g){return g.depthwiseConv2DDerInput(tu,tr,to)},{dy4D:tu});return tc?tl.as3D(tl.shape[1],tl.shape[2],tl.shape[3]):tl}}),od=An({depthwiseConv2dDerFilter_:function(g,te,tr,to){var tu=g;3===g.rank&&(tu=g.as4D(1,g.shape[0],g.shape[1],g.shape[2]));var tc=te;return 3===tc.rank&&(tc=te.as4D(1,te.shape[0],te.shape[1],te.shape[2])),tB.runKernelFunc(function(g){return g.depthwiseConv2DDerFilter(tu,tc,to)},{x4D:tu,dy4D:tc})}}),of=An({separableConv2d_:function(g,te,tr,to,tu,tc,tl){void 0===tc&&(tc=[1,1]),void 0===tl&&(tl="NHWC");var th=mn(g,"x","separableConv2d"),td=mn(te,"depthwiseFilter","separableConv2d"),tf=mn(tr,"pointwiseFilter","separableConv2d"),tp=th,tv=!1;if(3===th.rank&&(tv=!0,tp=th.as4D(1,th.shape[0],th.shape[1],th.shape[2])),"NCHW"===tl)throw Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");C(4===tp.rank,function(){return"Error in separableConv2d: input must be rank 4, but got rank "+tp.rank+"."}),C(4===td.rank,function(){return"Error in separableConv2d: depthwise filter must be rank 4, but got rank "+td.rank+"."}),C(4===tf.rank,function(){return"Error in separableConv2d: pointwise filter must be rank 4, but got rank "+td.rank+"."}),C(1===tf.shape[0],function(){return"Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got "+tf.shape[0]+"."}),C(1===tf.shape[1],function(){return"Error in separableConv2d: the second dimension of pointwise filter must be 1, but got "+tf.shape[1]+"."});var tm=td.shape[2],tg=td.shape[3];C(tf.shape[2]===tm*tg,function(){return"Error in separableConv2d: the third dimension of pointwise filter must be "+tm*tg+", but got "+tf.shape[2]+"."});var ty=on(ol(tp,td,to,tu,tl,tc),tf,1,"valid",tl);return tv?ty.as3D(ty.shape[1],ty.shape[2],ty.shape[3]):ty}}),op=An({conv2dTranspose_:function(g,te,tr,to,tu,tc){return Vc(tr,mn(g,"x","conv2dTranspose"),mn(te,"filter","conv2dTranspose"),to,tu,"NHWC",tc)}}),ov=An({conv3dTranspose_:function(g,te,tr,to,tu){return Gc(tr,mn(g,"x","conv3dTranspose"),mn(te,"filter","conv3dTranspose"),to,tu)}}),om=An({matMul_:function(g,te,tr,to){void 0===tr&&(tr=!1),void 0===to&&(to=!1);var tu,tc=mn(g,"a","matMul"),tl=mn(te,"b","matMul");tc=(tu=Nt(tc,tl))[0],tl=tu[1];var th=tr?tc.shape[tc.rank-2]:tc.shape[tc.rank-1],td=to?tl.shape[tl.rank-1]:tl.shape[tl.rank-2],tf=tr?tc.shape[tc.rank-1]:tc.shape[tc.rank-2],tp=to?tl.shape[tl.rank-2]:tl.shape[tl.rank-1],tv=tc.shape.slice(0,-2),tm=tl.shape.slice(0,-2),tg=k(tv),ty=k(tm);C(tc.rank>=2&&tl.rank>=2&&tc.rank===tl.rank,function(){return"Error in matMul: inputs must have the same rank of at least 2, got ranks "+tc.rank+" and "+tl.rank+"."}),C(S(tv,tm),function(){return"Error in matMul: outer dimensions ("+tv+") and ("+tm+") of Tensors with shapes "+tc.shape+" and "+tl.shape+" must match."}),C(th===td,function(){return"Error in matMul: inner shapes ("+th+") and ("+td+") of Tensors with shapes "+tc.shape+" and "+tl.shape+" and transposeA="+tr+" and transposeB="+to+" must match."});var tx=tc.shape.slice(0,-2).concat([tf,tp]),tb=tr?tc.as3D(tg,th,tf):tc.as3D(tg,tf,th),tC=to?tl.as3D(ty,tp,td):tl.as3D(ty,td,tp),tw={transposeA:tr,transposeB:to};return tB.runKernelFunc(function(g,te){var tu=g.batchMatMul(tb,tC,tr,to);return te([tb,tC]),tu},{a:tb,b:tC},function(g,te){var tu=te[0],tc=te[1];return tr||to?!tr&&to?{a:function(){return g.matMul(tc,!1,!1)},b:function(){return g.matMul(tu,!0,!1)}}:tr&&!to?{a:function(){return tc.matMul(g,!1,!0)},b:function(){return tu.matMul(g,!1,!1)}}:{a:function(){return tc.matMul(g,!0,!0)},b:function(){return g.matMul(tu,!0,!0)}}:{a:function(){return g.matMul(tc,!1,!0)},b:function(){return tu.matMul(g,!0,!1)}}},"BatchMatMul",tw).reshape(tx)}}),og=An({dot_:function(g,te){var tr=mn(g,"t1","dot"),to=mn(te,"t2","dot");C(!(1!==tr.rank&&2!==tr.rank||1!==to.rank&&2!==to.rank),function(){return"Error in dot: inputs must all be rank 1 or 2, but got ranks "+tr.rank+" and "+to.rank+"."});var tu=1===tr.rank?tr.size:tr.shape[1],tc=1===to.rank?to.size:to.shape[0];return C(tu===tc,function(){return"Error in dot: inner dimensions of inputs must match, but got "+tu+" and "+tc+"."}),1===tr.rank&&1===to.rank?tr.as2D(1,-1).matMul(to.as2D(-1,1)).asScalar():1===tr.rank&&2===to.rank?tr.as2D(1,-1).matMul(to.as2D(to.shape[0],to.shape[1])).as1D():2===tr.rank&&1===to.rank?tr.matMul(to.as2D(-1,1)).as1D():tr.matMul(to.as2D(to.shape[0],to.shape[1]))}}),oy=An({outerProduct_:function(g,te){var tr=mn(g,"v1","outerProduct"),to=mn(te,"v2","outerProduct");return C(1===tr.rank&&1===to.rank,function(){return"Error in outerProduct: inputs must be rank 1, but got ranks "+tr.rank+" and "+to.rank+"."}),tr.as2D(-1,1).matMul(to.as2D(1,-1))}}),ox=An({reverse_:function(g,te){var tr=mn(g,"x","reverse");if(0===tr.rank)return tr.clone();var to=O(te,tr.shape);return tB.runKernelFunc(function(g){return g.reverse(tr,to)},{$x:tr},function(g){return{$x:function(){return g.reverse(to)}}}).reshapeAs(tr)}}),ob=An({reverse1d_:function(g){var te=mn(g,"x","reverse");return C(1===te.rank,function(){return"Error in reverse1D: x must be rank 1 but got rank "+te.rank+"."}),ox(te,0)}}),oC=An({reverse2d_:function(g,te){var tr=mn(g,"x","reverse");return C(2===tr.rank,function(){return"Error in reverse2D: x must be rank 2 but got rank "+tr.rank+"."}),ox(tr,te)}}),ow=An({reverse3d_:function(g,te){var tr=mn(g,"x","reverse");return C(3===tr.rank,function(){return"Error in reverse3D: x must be rank 3 but got rank "+tr.rank+"."}),ox(tr,te)}}),oE=An({reverse4d_:function(g,te){var tr=mn(g,"x","reverse");return C(4===tr.rank,function(){return"Error in reverse4D: x must be rank 4 but got rank "+tr.rank+"."}),ox(tr,te)}});function cl(g,te,tr,to,tu,tc){var tl=mn(g,"x","maxPool"),th=tl,td=!1;3===tl.rank&&(td=!0,th=tl.as4D(1,tl.shape[0],tl.shape[1],tl.shape[2])),null==to&&(to=[1,1]),C(4===th.rank,function(){return"Error in maxPool: input must be rank 4 but got rank "+th.rank+"."}),C(Mo(tr,to),function(){return"Error in maxPool: Either strides or dilations must be 1. Got strides "+tr+" and dilations '"+to+"'"}),null!=tc&&C(A(tu),function(){return"Error in maxPool: pad must be an integer when using, dimRoundingMode "+tc+" but got pad "+tu+"."});var tf=Io(th.shape,te,tr,to,tu,tc);if(1===tf.filterWidth&&1===tf.filterHeight&&S(tf.inShape,tf.outShape))return tl.clone();var tp=[th],tv=tB.runKernelFunc(function(g,te){var tr=g.maxPool(th,tf);return te([th,tr]),tr},{x:th},function(g,tc){var tl=tc[0],th=tc[1];return{x:function(){var tc,td,tf,tp,tv,tm;return tc=to,tf=mn(g,"dy","maxPoolBackprop"),tp=mn(tl,"input","maxPoolBackprop"),tv=mn(th,"output","maxPoolBackprop"),C(tp.rank===tf.rank,function(){return"Rank of input ("+tp.rank+") does not match rank of dy ("+tf.rank+")"}),null==tc&&(tc=[1,1]),C(Mo(tr,tc),function(){return"Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides "+tr+" and dilations '"+tc+"'"}),C(4===tf.rank,function(){return"Error in maxPoolBackprop: dy must be rank 4 but got rank "+tf.rank+"."}),C(4===tp.rank,function(){return"Error in maxPoolBackprop: input must be rank 4 but got rank "+tp.rank+"."}),null!=td&&C(A(tu),function(){return"Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode "+td+" but got pad "+tu+"."}),tm=Io(tp.shape,te,tr,tc,tu,td),tB.runKernelFunc(function(g){return g.maxPoolBackprop(tf,tp,tv,tm)},{$dy:tf,$input:tp})}}},"MaxPool",tf,tp);return td?tv.as3D(tv.shape[1],tv.shape[2],tv.shape[3]):tv}function ll(g,te,tr,to,tu,tc){var tl=mn(g,"x","avgPool","float32");null==to&&(to=[1,1]),C(Mo(tr,to),function(){return"Error in avgPool: Either strides or dilations must be 1. Got strides "+tr+" and dilations '"+to+"'"});var th=tl,td=!1;3===tl.rank&&(td=!0,th=tl.as4D(1,tl.shape[0],tl.shape[1],tl.shape[2])),C(4===th.rank,function(){return"Error in avgPool: x must be rank 4 but got rank "+th.rank+"."}),null!=tc&&C(A(tu),function(){return"Error in avgPool: pad must be an integer when using, dimRoundingMode "+tc+" but got pad "+tu+"."});var tf=Io(th.shape,te,tr,to,tu,tc);if(1===tf.filterWidth&&1===tf.filterHeight&&S(tf.inShape,tf.outShape))return tl.clone();var tp=tB.runKernelFunc(function(g){return g.avgPool(th,tf)},{x:th},function(g){return{x:function(){var tc,tl,td,tf,tp,tv,tm,tg,ty;return tc=th,tl=to,td=mn(g,"dy","avgPoolBackprop"),C((tf=mn(tc,"input","avgPoolBackprop")).rank===td.rank,function(){return"Rank of input ("+tf.rank+") does not match rank of dy ("+td.rank+")"}),null==tl&&(tl=[1,1]),C(Mo(tr,tl),function(){return"Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides "+tr+" and dilations '"+tl+"'"}),tp=tf,tv=td,tm=!1,3===tf.rank&&(tm=!0,tp=tf.as4D(1,tf.shape[0],tf.shape[1],tf.shape[2]),tv=td.as4D(1,td.shape[0],td.shape[1],td.shape[2])),C(4===tv.rank,function(){return"Error in avgPoolBackprop: dy must be rank 4 but got rank "+tv.rank+"."}),C(4===tp.rank,function(){return"Error in avgPoolBackprop: input must be rank 4 but got rank "+tp.rank+"."}),tg=Io(tp.shape,te,tr,tl,tu),ty=tB.runKernelFunc(function(g){return g.avgPoolBackprop(tv,tp,tg)},{dy4D:tv,input4D:tp}),tm?ty.as3D(ty.shape[1],ty.shape[2],ty.shape[3]):ty}}},"AvgPool",tf);return tp=tp.cast(tl.dtype),td?tp.as3D(tp.shape[1],tp.shape[2],tp.shape[3]):tp}var oR=An({maxPool_:function(g,te,tr,to,tu){return cl(g,te,tr,1,to,tu)}}),oI=An({avgPool_:function(g,te,tr,to,tu){return ll(g,te,tr,1,to,tu)}}),ok=An({pool_:function(g,te,tr,to,tu,tc){null==tu&&(tu=[1,1]),null==tc&&(tc=1),0===to&&(to="valid");var tl,th,td,tf,tp,tv,tm,tg,ty,tx=mn(g,"x","maxPool"),tb=tx,tC=!1;3===tx.rank&&(tC=!0,tb=tx.as4D(1,tx.shape[0],tx.shape[1],tx.shape[2])),C(Mo(tc,tu),function(){return"Error in pool: Either strides or dilations must be 1. Got strides "+tc+" and dilations '"+tu+"'"});var tw,tE=Io(tb.shape,te,tc,tu,to),tR=[tE.dilationHeight,tE.dilationWidth];tw="same"===to?(th=(tl=[tE.filterHeight,tE.filterWidth].map(function(g,te){return g+(g-1)*(tR[te]-1)}).map(function(g){return g-1})).map(function(g){return Math.floor(g/2)}),td=tl.map(function(g,te){return g-th[te]}),tl.map(function(g,te){return[th[te],td[te]]})):[[0,0],[0,0]];var tI=1===tR[0]&&1===tR[1],tk=(tf=[tE.inHeight,tE.inWidth],tp=tw.map(function(g){return g[0]}),tm=tf.concat(tp,tv=tw.map(function(g){return g[1]})),tg=tR.map(function(g,te){return(g-tm[te]%g)%g}),ty=tv.map(function(g,te){return g+tg[te]}),[tR.map(function(g,te){return[tp[te],ty[te]]}),tR.map(function(g,te){return[0,tg[te]]})]),tA=tk[0],tS=tk[1],tD=tI?to:"valid",tN=tI?tb:nB(tb,tR,tA),tT=("avg"===tr?function(){return ll(tN,te,tc,1,tD)}:function(){return cl(tN,te,tc,1,tD)})(),tF=tI?tT:nm(tT,tR,tS);return tC?tF.as3D(tF.shape[1],tF.shape[2],tF.shape[3]):tF}}),oA=An({maxPool3d_:function(g,te,tr,to,tu,tc,tl){void 0===tc&&(tc="NDHWC");var th=mn(g,"x","maxPool3d"),td=th,tf=!1;4===th.rank&&(tf=!0,td=th.as5D(1,th.shape[0],th.shape[1],th.shape[2],th.shape[3])),null==tl&&(tl=[1,1,1]),C(5===td.rank,function(){return"Error in maxPool3d: x must be rank 5 but got rank "+td.rank+"."}),C("NDHWC"===tc,function(){return"Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of "+tc}),C(Mo(tr,tl),function(){return"Error in maxPool3d: Either strides or dilations must be 1. Got strides "+tr+" and dilations '"+tl+"'"}),null!=tu&&C(A(to),function(){return"Error in maxPool3d: pad must be an integer when using, dimRoundingMode "+tu+" but got pad "+to+"."});var tp=ko(td.shape,te,tr,tl,to,tu,tc),tv=tB.runKernelFunc(function(g,te){var tr=g.maxPool3d(td,tp);return te([td,tr]),tr},{x:td},function(g,tc){var th=tc[0],td=tc[1];return{x:function(){var tc,tf,tp,tv,tm,tg,ty,tx,tb,tC;return tc=tl,tf=mn(g,"dy","maxPool3dBackprop"),tp=mn(th,"input","maxPool3dBackprop"),tv=mn(td,"output","maxPool3dBackprop"),tm=tf,tg=tp,ty=tv,tx=!1,4===tp.rank&&(tx=!0,tm=tf.as5D(1,tf.shape[0],tf.shape[1],tf.shape[2],tf.shape[3]),tg=tp.as5D(1,tp.shape[0],tp.shape[1],tp.shape[2],tp.shape[3]),ty=tv.as5D(1,tv.shape[0],tv.shape[1],tv.shape[2],tv.shape[3])),C(5===tm.rank,function(){return"Error in maxPool3dBackprop: dy must be rank 5 but got rank "+tm.rank+"."}),C(5===tg.rank,function(){return"Error in maxPool3dBackprop: input must be rank 5 but got rank "+tg.rank+"."}),C(5===ty.rank,function(){return"Error in maxPool3dBackprop: output must be rank 5 but got rank "+ty.rank+"."}),null==tc&&(tc=[1,1,1]),C(Mo(tr,tc),function(){return"Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides "+tr+" and dilations '"+tc+"'"}),null!=tu&&C(A(to),function(){return"Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode "+tu+" but got pad "+to+"."}),tb=ko(tg.shape,te,tr,tc,to,tu),tC=tB.runKernelFunc(function(g){return g.maxPool3dBackprop(tm,tg,ty,tb)},{dy5D:tm,input5D:tg}),tx?tC.as4D(tC.shape[1],tC.shape[2],tC.shape[3],tC.shape[4]):tC}}});return tf?tv.as4D(tv.shape[1],tv.shape[2],tv.shape[3],tv.shape[4]):tv}}),oS=An({avgPool3d_:function(g,te,tr,to,tu,tc,tl){void 0===tc&&(tc="NDHWC");var th=mn(g,"x","avgPool3d","float32"),td=th,tf=!1;4===th.rank&&(tf=!0,td=th.as5D(1,th.shape[0],th.shape[1],th.shape[2],th.shape[3])),null==tl&&(tl=[1,1,1]),C(5===td.rank,function(){return"Error in avgPool3d: x must be rank 5 but got rank "+td.rank+"."}),C("NDHWC"===tc,function(){return"Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of "+tc}),C(Mo(tr,tl),function(){return"Error in avgPool3d: Either strides or dilations must be 1. Got strides "+tr+" and dilations '"+tl+"'"}),null!=tu&&C(A(to),function(){return"Error in avgPool3d: pad must be an integer when using, dimRoundingMode "+tu+" but got pad "+to+"."});var tp=ko(td.shape,te,tr,tl,to,tu,tc),tv=tB.runKernelFunc(function(g){return g.avgPool3d(td,tp)},{x:td},function(g){return{x:function(){var tc,th,tf,tp,tv,tm,tg,ty,tx;return tc=td,th=tl,tf=mn(g,"dy","avgPool3dBackprop"),tp=mn(tc,"input","avgPool3dBackprop"),tv=tf,tm=tp,tg=!1,4===tp.rank&&(tg=!0,tv=tf.as5D(1,tf.shape[0],tf.shape[1],tf.shape[2],tf.shape[3]),tm=tp.as5D(1,tp.shape[0],tp.shape[1],tp.shape[2],tp.shape[3])),C(5===tv.rank,function(){return"Error in avgPool3dBackprop: dy must be rank 5 but got rank "+tv.rank+"."}),C(5===tm.rank,function(){return"Error in avgPool3dBackprop: input must be rank 5 but got rank "+tm.rank+"."}),null==th&&(th=[1,1,1]),C(Mo(tr,th),function(){return"Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides "+tr+" and dilations '"+th+"'"}),null!=tu&&C(A(to),function(){return"Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode "+tu+" but got pad "+to+"."}),ty=ko(tm.shape,te,tr,th,to,tu),tx=tB.runKernelFunc(function(g){return g.avgPool3dBackprop(tv,tm,ty)},{dy5D:tv,input5D:tm}),tg?tx.as4D(tx.shape[1],tx.shape[2],tx.shape[3],tx.shape[4]):tx}}});return tv=tv.cast(td.dtype),tf?tv.as4D(tv.shape[1],tv.shape[2],tv.shape[3],tv.shape[4]):tv}}),oD=An({slice_:function(g,te,tr){var to,tu,tc=mn(g,"x","slice");if(0===tc.rank)throw Error("Slicing scalar is not possible");(to="number"==typeof te?[te].concat(Array(tc.rank-1).fill(0)):te.length<tc.rank?te.concat(Array(tc.rank-te.length).fill(0)):te.slice()).forEach(function(g){C(-1!==g,function(){return"slice() does not support negative begin indexing."})}),tu=(tu=null==tr?Array(tc.rank).fill(-1):"number"==typeof tr?[tr].concat(Array(tc.rank-1).fill(-1)):tr.length<tc.rank?tr.concat(Array(tc.rank-tr.length).fill(-1)):tr).map(function(g,te){return g>=0?g:(C(-1===g,function(){return"Negative size values should be exactly -1 but got "+g+" for the slice() size at index "+te+"."}),tc.shape[te]-to[te])}),eo(tc,to,tu);var tl=tc.shape,th={begin:to,size:tu};return tB.runKernelFunc(function(g){return g.slice(tc,to,tu)},{x:tc},function(g){for(var te=[],tr=0;tr<g.rank;tr++)te.push([to[tr],tl[tr]-to[tr]-tu[tr]]);return{x:function(){return g.pad(te)}}},"Slice",th)}}),oN=An({slice1d_:function(g,te,tr){var to=mn(g,"x","slice1d");return C(1===to.rank,function(){return"slice1d expects a rank-1 tensor, but got a rank-"+to.rank+" tensor"}),oD(to,[te],[tr])}}),oT=An({slice2d_:function(g,te,tr){var to=mn(g,"x","slice2d");return C(2===to.rank,function(){return"slice2d expects a rank-2 tensor, but got a rank-"+to.rank+" tensor"}),oD(to,te,tr)}}),oF=An({slice3d_:function(g,te,tr){var to=mn(g,"x","slice3d");return C(3===to.rank,function(){return"slice3d expects a rank-3 tensor, but got a rank-"+to.rank+" tensor"}),oD(to,te,tr)}}),oO=An({slice4d_:function(g,te,tr){var to=mn(g,"x","slice4d");return C(4===to.rank,function(){return"slice4d expects a rank-4 tensor, but got a rank-"+to.rank+" tensor"}),oD(to,te,tr)}});function wl(g,te,tr,to,tu){return te.rank<tr.rank&&(te=te.reshape(wn(te.shape,to))),g.rank<tr.rank&&(g=g.reshape(wn(g.shape,to))),{x:function(){var to=g.mul(tr.equal(te).cast(g.dtype));return null==tu?to:to.transpose(tu)}}}var o_=An({all_:function(g,te,tr){void 0===te&&(te=null),void 0===tr&&(tr=!1);var to=mn(g,"x","all","bool"),tu=O(te,to.shape),tc=tu,tl=En(tc,to.rank);null!=tl&&(to=to.transpose(tl),tc=In(tc.length,to.rank));var th=tB.runKernelFunc(function(g){return g.all(to,tc)},{$x:to});if(tr){var td=wn(th.shape,tu);return th.reshape(td)}return th}}),oM=An({any_:function(g,te,tr){void 0===te&&(te=null),void 0===tr&&(tr=!1);var to=mn(g,"x","any","bool"),tu=O(te,to.shape),tc=tu,tl=En(tc,to.rank);null!=tl&&(to=to.transpose(tl),tc=In(tc.length,to.rank));var th=tB.runKernelFunc(function(g){return g.any(to,tc)},{$x:to});if(tr){var td=wn(th.shape,tu);return th.reshape(td)}return th}}),oB=An({argMax_:function(g,te){void 0===te&&(te=0);var tr=mn(g,"x","argMax");null==te&&(te=0);var to=O(te,tr.shape),tu=En(to,tr.rank);null!=tu&&(tr=tr.transpose(tu),to=In(to.length,tr.rank));var tc={axis:to[0]},tl=[tr];return tB.runKernelFunc(function(g,te){var tu=g.argMax(tr,to[0]);return te([tr]),tu},{x:tr},function(g,te){var tr=te[0];return{x:function(){return t1(tr)}}},"ArgMax",tc,tl)}}),oP=An({argMin_:function(g,te){void 0===te&&(te=0);var tr=mn(g,"x","argMin");null==te&&(te=0);var to=O(te,tr.shape),tu=En(to,tr.rank);return null!=tu&&(tr=tr.transpose(tu),to=In(to.length,tr.rank)),tB.runKernelFunc(function(g,te){var tu=g.argMin(tr,to[0]);return te([tr]),tu},{$x:tr},function(g,te){var tr=te[0];return{$x:function(){return t1(tr)}}})}}),oL=An({logSumExp_:function(g,te,tr){void 0===te&&(te=null),void 0===tr&&(tr=!1);var to=mn(g,"x","logSumExp"),tu=O(te,to.shape),tc=to.max(tu,!0),tl=to.sub(tc).exp().sum(tu).log(),th=tc.reshape(tl.shape).add(tl);if(tr){var td=wn(th.shape,tu);return th.reshape(td)}return th}}),oW=An({max_:function(g,te,tr){void 0===te&&(te=null),void 0===tr&&(tr=!1);var to=mn(g,"x","max"),tu=to,tc=O(te,to.shape),tl=tc,th=En(tl,to.rank);null!=th&&(to=to.transpose(th),tl=In(tl.length,to.rank));var td=[to],tf=tB.runKernelFunc(function(g,te){var tr=g.max(to,tl);return te([tu,tr]),tr},{x:to},function(g,te){return wl(g,te[1],te[0],tc,th)},"Max",{axes:tl},td,[!0]);if(tr){var tp=wn(tf.shape,tc);tf=tf.reshape(tp)}return tf}}),oV=An({mean_:function(g,te,tr){void 0===te&&(te=null),void 0===tr&&(tr=!1);var to=mn(g,"x","mean"),tu=O(te,to.shape),tc=k(bn(to.shape,tu)[1]);return vo(function(g){var to=On(tc);return{value:(to.dtype===g.dtype?g:g.cast(to.dtype)).div(to).sum(te,tr),gradFunc:function(te){var tr=g.shape.slice();return tu.forEach(function(g){tr[g]=1}),te.reshape(tr).mul(zn(g.shape,"float32")).div(tc)}}})(to)}}),oU=An({min_:function(g,te,tr){void 0===te&&(te=null),void 0===tr&&(tr=!1);var to=mn(g,"x","min"),tu=to,tc=O(te,to.shape),tl=tc,th=En(tl,to.rank);null!=th&&(to=to.transpose(th),tl=In(tl.length,to.rank));var td=[to],tf=tB.runKernelFunc(function(g,te){var tr=g.min(to,tl);return te([tu,tr]),tr},{x:to},function(g,te){return wl(g,te[1],te[0],tc,th)},"Min",{axes:tl},td,[!0]);if(tr){var tp=wn(tf.shape,tc);tf=tf.reshape(tp)}return tf}}),oz=An({moments_:function(g,te,tr){void 0===te&&(te=null),void 0===tr&&(tr=!1);var to=O(te,(g=mn(g,"x","moments")).shape),tu=g.mean(to,tr),tc=tu.shape;tr||(tc=wn(tu.shape,to));var tl=g.toFloat().sub(tu.reshape(tc)).square();return{mean:tu,variance:tl.mean(to,tr)}}}),oH=An({sum_:function(g,te,tr){void 0===te&&(te=null),void 0===tr&&(tr=!1);var to=mn(g,"x","sum");"bool"===to.dtype&&(to=to.toInt());var tu=O(te,to.shape);return vo(function(g){var te=En(tu,g.rank),to=tu,tc=g;null!=te&&(tc=g.transpose(te),to=In(to.length,g.rank));var i=function(te){var tr=g.shape.slice();return tu.forEach(function(g){tr[g]=1}),te.reshape(tr).mul(zn(g.shape,"float32"))},tl={axes:to},th=tB.runKernelFunc(function(g){return g.sum(tc,to)},{x:tc},function(g){return{x:function(){return i(g)}}},"Sum",tl);if(tr){var td=wn(th.shape,tu);th=th.reshape(td)}return{value:th,gradFunc:i}})(to)}}),oG=An({prod_:function(g,te,tr){void 0===te&&(te=null),void 0===tr&&(tr=!1);var to=mn(g,"x","prod");"bool"===to.dtype&&(to=to.toInt());var tu=O(te,to.shape),tc=En(tu,to.rank),tl=tu,th=to;null!=tc&&(th=to.transpose(tc),tl=In(tl.length,to.rank));var td=tB.runKernelFunc(function(g){return g.prod(th,tl)},{permutedX:th});if(tr){var tf=wn(td.shape,tu);td=td.reshape(tf)}return td}}),oq=An({elu_:function(g){var te=mn(g,"x","elu");return tB.runKernelFunc(function(g,tr){var to=g.elu(te);return tr([to]),to},{$x:te},function(g,te){var tr=te[0];return{$x:function(){return tB.runKernelFunc(function(te){return te.eluDer(g,tr)},{dy:g,y:tr})}}})}}),oK=An({leakyRelu_:function(g,te){void 0===te&&(te=.2);var tr=mn(g,"x","leakyRelu");return rB(On(te).mul(tr),tr)}}),oj=An({prelu_:function(g,te){var tr=mn(g,"x","prelu"),to=mn(te,"alpha","prelu");return tB.runKernelFunc(function(g,te){var tu=g.prelu(tr,to);return te([tr,to]),tu},{x:tr,alpha:to},function(g,te){var tr=te[0],to=te[1],tu=tr.greater(0);return{x:function(){return rA(tu,g,g.mul(to))},alpha:function(){var te=rA(tu,t1(g),g.mul(tr)),tc=Eo(to.shape,g.shape);return tc.length>0&&(te=te.sum(tc)),te.reshape(to.shape)}}},"Prelu")}}),oX=An({relu_:function(g){var te=mn(g,"x","relu");return"bool"===te.dtype?te.toInt():tB.runKernelFunc(function(g,tr){var to=g.relu(te);return tr([te]),to},{x:te},function(g,te){var tr=te[0];return{x:function(){return g.mulStrict(tr.step().toFloat())}}},"Relu")}}),o$=An({relu6_:function(g){var te=mn(g,"x","relu6");return"bool"===te.dtype?te.toInt():tB.runKernelFunc(function(g,tr){var to=g.relu6(te);return tr([te]),to},{x:te},function(g,te){var tr=te[0],to=tr.lessEqual(6).mul(tr.step());return{x:function(){return g.mulStrict(to.toFloat())}}},"Relu6")}}),oY=An({selu_:function(g){var te=mn(g,"x","selu");return tB.runKernelFunc(function(g,tr){var to=g.selu(te);return tr([te]),to},{$x:te},function(g,te){var tr=te[0];return{$x:function(){var te=tr.greater(On(0)),to=On(1.7580993408473768),tu=On(1.0507009873554805);return rA(te,g.mul(tu),g.mul(to).mul(tr.toFloat().exp()))}}})}}),oJ=An({transpose_:function(g,te){var tr=mn(g,"x","transpose");if(null==te&&(te=tr.shape.map(function(g,te){return te}).reverse()),C(tr.rank===te.length,function(){return"Error in transpose: rank of input "+tr.rank+" must match length of perm "+te+"."}),te.forEach(function(g){C(g>=0&&g<tr.rank,function(){return"All entries in 'perm' must be between 0 and "+(tr.rank-1)+" but got "+te})}),tr.rank<=1)return tr.clone();var to={perm:te};return tB.runKernelFunc(function(g){return g.transpose(tr,te)},{x:tr},function(g){var tr=Rn(te);return{x:function(){return g.transpose(tr)}}},"Transpose",to)}}),oQ=An({localResponseNormalization_:function(g,te,tr,to,tu){void 0===te&&(te=5),void 0===tr&&(tr=1),void 0===to&&(to=1),void 0===tu&&(tu=.5);var tc=mn(g,"x","localResponseNormalization");C(4===tc.rank||3===tc.rank,function(){return"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank "+tc.rank+"."}),C(A(te),function(){return"Error in localResponseNormalization: depthRadius must be an integer but got depthRadius "+te+"."});var tl=tc,th=!1;3===tc.rank&&(th=!0,tl=tc.as4D(1,tc.shape[0],tc.shape[1],tc.shape[2]));var td=tB.runKernelFunc(function(g,tc){var th=g.localResponseNormalization4D(tl,te,tr,to,tu);return tc([tl,th]),th},{x4D:tl},function(g,tc){var tl=tc[0],th=tc[1];return{x4D:function(){return tB.runKernelFunc(function(tc){return tc.LRNGrad(g,tl,th,te,tr,to,tu)},{})}}});return th?td.as3D(td.shape[1],td.shape[2],td.shape[3]):td}}),oZ=An({norm_:function(g,te,tr,to){void 0===te&&(te="euclidean"),void 0===tr&&(tr=null),void 0===to&&(to=!1);var tu=function t(g,te,tr){if(void 0===tr&&(tr=null),0===g.rank)return g.abs();if(1!==g.rank&&null===tr)return t(g.reshape([-1]),te,tr);if(1===g.rank||"number"==typeof tr||Array.isArray(tr)&&1===tr.length){if(1===te)return g.abs().sum(tr);if(te===1/0)return g.abs().max(tr);if(te===-1/0)return g.abs().min(tr);if("euclidean"===te||2===te)return g.abs().pow(On(2,"int32")).sum(tr).sqrt();throw Error("Error in norm: invalid ord value: "+te)}if(Array.isArray(tr)&&2===tr.length){if(1===te)return g.abs().sum(tr[0]).max(tr[1]-1);if(te===1/0)return g.abs().sum(tr[1]).max(tr[0]);if(te===-1/0)return g.abs().sum(tr[1]).min(tr[0]);if("fro"===te||"euclidean"===te)return g.square().sum(tr).sqrt();throw Error("Error in norm: invalid ord value: "+te)}throw Error("Error in norm: invalid axis: "+tr)}(g=mn(g,"x","norm"),te,tr),tc=tu.shape;if(to){var tl=O(tr,g.shape);tc=wn(tu.shape,tl)}return tu.reshape(tc)}}),o0=An({basicLSTMCell_:function(g,te,tr,to,tu,tc){var tl=mn(g,"forgetBias","basicLSTMCell"),th=mn(te,"lstmKernel","basicLSTMCell"),td=mn(tr,"lstmBias","basicLSTMCell"),tf=mn(to,"data","basicLSTMCell"),tp=mn(tu,"c","basicLSTMCell"),tv=mn(tc,"h","basicLSTMCell"),tm=tf.concat(tv,1).matMul(th).add(td),tg=tm.shape[0],ty=tm.shape[1]/4,tx=[tg,ty],tb=tm.slice([0,0],tx),tC=tm.slice([0,ty],tx),tw=tm.slice([0,2*ty],tx),tE=tm.slice([0,3*ty],tx),tR=tb.sigmoid().mulStrict(tC.tanh()).addStrict(tp.mulStrict(tl.add(tw).sigmoid())),tI=tR.tanh().mulStrict(tE.sigmoid());return[tR,tI]}}),o1=An({multiRNNCell_:function(g,te,tr,to){for(var tu=mn(te,"data","multiRNNCell"),tc=gn(tr,"c","multiRNNCell"),tl=gn(to,"h","multiRNNCell"),th=tu,td=[],tf=0;tf<g.length;tf++){var tp=g[tf](th,tc[tf],tl[tf]);td.push(tp[0]),td.push(tp[1]),th=tp[1]}var tv=[],tm=[];for(tf=0;tf<td.length;tf+=2)tv.push(td[tf]),tm.push(td[tf+1]);return[tv,tm]}}),o2=An({movingAverage_:function(g,te,tr,to,tu){void 0===tu&&(tu=!0);var tc=mn(g,"v","movingAverage"),tl=mn(te,"x","movingAverage"),th=mn(tr,"decay","movingAverage");Ft(tc,tl),C(S(tc.shape,tl.shape),function(){return"Shape mismatch in v and x"});var td=On(1),tf=td.sub(th),tp=tl.sub(tc).mul(tf);if(tu){C(null!=to,function(){return"When using zeroDebias: true, step is required."});var tv=mn(to,"step","movingAverage");tp=tp.div(td.sub(rG(th,tv)))}return tc.add(tp)}}),o3=An({stridedSlice_:function(g,te,tr,to,tu,tc,tl,th,td){if(void 0===tu&&(tu=0),void 0===tc&&(tc=0),void 0===tl&&(tl=0),void 0===th&&(th=0),void 0===td&&(td=0),null==to&&(to=Array(te.length)),0!==tl)throw Error("ellipsis mask is not yet supported");var tf=mn(g,"x","stridedSlice"),tp=no(th),tv=tf.shape.slice();tp.forEach(function(g){te[g]=0,tr[g]=1,tv.splice(g,0,1)}),tf=tf.reshape(tv);for(var tm=0;tm<tf.rank;tm++)te[tm]=oo(tu,te,to,tf.shape,tm),tr[tm]=ao(tc,tr,to,tf.shape,tm),to[tm]=to[tm]||1;var tg=no(td);tg.forEach(function(g){tr[g]=te[g]+1,to[g]=1});var ty=ro(te,tr,to),tx=ty.filter(function(g,te){return -1===tg.indexOf(te)});return to.every(function(g){return 1===g})?oD(tf,te,ty).reshape(tx):tB.runKernelFunc(function(g){return g.stridedSlice(tf,te,tr,to)},{$x:tf}).reshape(tx)}}),o4=An({topk_:function(g,te,tr){void 0===te&&(te=1),void 0===tr&&(tr=!0);var to=mn(g,"x","topk");if(0===to.rank)throw Error("topk() expects the input to be of rank 1 or higher");var tu=to.shape[to.shape.length-1];if(te>tu)throw Error("'k' passed to topk() must be <= the last dimension ("+tu+") but got "+te);var tc=tB.runKernelFunc(function(g){return g.topk(to,te,tr)},{$x:to});return{values:tc[0],indices:tc[1]}}}),o5=An({scatterND_:function(g,te,tr){var to=mn(g,"indices","scatterND","int32"),tu=mn(te,"updates","scatterND");return Jr(tu,to,tr),tB.runKernelFunc(function(g){return g.scatterND(to,tu,tr)},{indices:to,updates:tu},null,"ScatterNd",{shape:tr})}}),o6=An({fft_:function(g){C("complex64"===g.dtype,function(){return"The dtype for tf.spectral.fft() must be complex64 but got "+g.dtype+"."});var te=g.shape[g.shape.length-1],tr=g.size/te,to=g.as2D(tr,te);return tB.runKernelFunc(function(g){return g.fft(to)},{input:g}).reshape(g.shape)}}),o8=An({ifft_:function(g){C("complex64"===g.dtype,function(){return"The dtype for tf.spectral.ifft() must be complex64 but got "+g.dtype+"."});var te=g.shape[g.shape.length-1],tr=g.size/te,to=g.as2D(tr,te);return tB.runKernelFunc(function(g){return g.ifft(to)},{input:g}).reshape(g.shape)}}),o7=An({rfft_:function(g,te){C("float32"===g.dtype,function(){return"The dtype for rfft() must be real value but got "+g.dtype});var tr,to=g.shape[g.shape.length-1],tu=g.size/to;if(null!=te&&te<to){var tc=g.shape.map(function(g){return 0}),tl=g.shape.map(function(g){return g});tl[g.shape.length-1]=te,tr=g.slice(tc,tl),to=te}else if(null!=te&&te>to){var th=g.shape.map(function(g){return g});th[g.shape.length-1]=te-to,tr=g.concat(Gn(th),g.shape.length-1),to=te}else tr=g;var td=tr.zerosLike(),tf=o6(tJ(tr,td).as2D(tu,to)),tp=Math.floor(to/2)+1,tv=tQ(tf),tm=tZ(tf),tg=tv.split([tp,to-tp],tv.shape.length-1),ty=tm.split([tp,to-tp],tm.shape.length-1),tx=tr.shape.slice();return tx[tr.shape.length-1]=tp,tJ(tg[0],ty[0]).reshape(tx)}}),o9=An({irfft_:function(g){var te=g.shape[g.shape.length-1],tr=g.size/te;if(te<=2){var to=g.as2D(tr,te),tu=o8(to);return tQ(tu)}var tc=[tr,2*(te-1)],tl=tQ(g).as2D(tr,te),th=tZ(g).as2D(tr,te),td=tl.slice([0,1],[tr,te-2]).reverse(1),tf=th.slice([0,1],[tr,te-2]).reverse(1).mul(On(-1));return tQ(tu=o8(to=tJ(tl.concat(td,1),th.concat(tf,1)).as2D(tc[0],tc[1])))}}),an=Object.freeze({fft:o6,ifft:o8,rfft:o7,irfft:o9}),ar=An({sparseToDense_:function(g,te,tr,to){void 0===to&&(to=0);var tu=mn(g,"sparseIndices","sparseToDense","int32"),tc=mn(te,"sparseValues","sparseToDense"),tl=mn(to,"defaultValue","sparseToDense",tc.dtype);return function(g,te,tr,to){if("int32"!==g.dtype)throw Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was "+g.dtype+".");if(g.rank>2)throw Error("sparseIndices should be a scalar, vector, or matrix, but got shape "+g.shape+".");var tu=g.rank>0?g.shape[0]:1,tc=g.rank>1?g.shape[1]:1;if(tr.length!==tc)throw Error("outputShape has incorrect number of elements:, "+tr.length+", should be: "+tc+".");var tl=te.size;if(0!==te.rank&&(1!==te.rank||tl!==tu))throw Error("sparseValues has incorrect shape "+te.shape+", should be [] or ["+tu+"]");if(te.dtype!==to.dtype)throw Error("sparseValues.dtype must match defaultValues.dtype")}(tu,tc,tr,tl),tB.runKernelFunc(function(g){return g.sparseToDense(tu,tc,tr,tl)},{$sparseIndices:tu,$sparseValues:tc,$defaultValue:tl})}}),au=An({gatherND_:function(g,te){var tr=mn(te,"indices","gatherND","int32"),to=mn(g,"x","gatherND");return tB.runKernelFunc(function(g){return g.gatherND(to,tr)},{x:to,indices:tr},null,"GatherNd")}}),ac=An({diag_:function(g){var te=mn(g,"x","diag").flatten(),tr=g.shape.concat(g.shape);return tB.runKernelFunc(function(g){return g.diag(te)},{$x:te}).reshape(tr)}}),al=An({dropout_:function(g,te,tr,to){var tu=mn(g,"x","dropout");if(C("float32"===tu.dtype,function(){return"x has to be a floating point tensor since it's going to be scaled, but got a "+tu.dtype+" tensor instead."}),C(te>=0&&te<1,function(){return"rate must be a float in the range [0, 1), but got "+te+"."}),0===te)return g instanceof tb?tu.clone():tu;var tc=function(g,te){if(null==te)return g.shape.slice();if(S(g.shape,te))return te;if(g.shape.length===te.length){for(var tr=[],to=0;to<g.shape.length;to++)null==te[to]&&null!=g.shape[to]?tr.push(g.shape[to]):tr.push(te[to]);return tr}return te}(tu,tr),tl=1-te,th=n_(tc,0,1,"float32",to).add(tl).floor().div(tl);return tu.mul(th)}});function rh(g,te,tr){for(var to=1-g%2,tu=new Float32Array(g),tc=0;tc<g;++tc){var tl=2*Math.PI*tc/(g+to-1);tu[tc]=te-tr*Math.cos(tl)}return Mn(tu,"float32")}var ah=An({hannWindow_:function(g){return rh(g,.5,.5)}}),ad=An({hammingWindow_:function(g){return rh(g,.54,.46)}}),af=An({frame_:function(g,te,tr,to,tu){void 0===to&&(to=!1),void 0===tu&&(tu=0);for(var tc=0,tl=[];tc+te<=g.size;)tl.push(oD(g,tc,te)),tc+=tr;if(to)for(;tc<g.size;){var th=tc+te-g.size,td=t2([oD(g,tc,te-th),Hn([th],tu)]);tl.push(td),tc+=tr}return 0===tl.length?Bn([],[0,te]):t2(tl).as2D(tl.length,te)}}),ap=An({stft_:function(g,te,tr,to,tu){void 0===tu&&(tu=ah),null==to&&(to=Math.floor(Math.pow(2,Math.ceil(Math.log(te)/Math.log(2)))));for(var tc=af(g,te,tr),tl=rz(tc,tu(te)),th=[],td=0;td<tc.shape[0];td++)th.push(o7(tl.slice([td,0],[1,te]),to));return t2(th)}}),av=Object.freeze({hannWindow:ah,hammingWindow:ad,frame:af,stft:ap});(aO=aF||(aF={}))[aO.NONE=0]="NONE",aO[aO.MEAN=1]="MEAN",aO[aO.SUM=2]="SUM",aO[aO.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS";var am=An({absoluteDifference_:function(g,te,tr,to){void 0===to&&(to=aF.SUM_BY_NONZERO_WEIGHTS);var tu=mn(g,"labels","absoluteDifference"),tc=mn(te,"predictions","absoluteDifference"),tl=null;return null!=tr&&(tl=mn(tr,"weights","absoluteDifference")),E(tu.shape,tc.shape,"Error in absoluteDifference: "),ag(tu.sub(tc).abs(),tl,to)}}),ag=An({computeWeightedLoss_:function(g,te,tr){void 0===tr&&(tr=aF.SUM_BY_NONZERO_WEIGHTS);var to=mn(g,"losses","computeWeightedLoss"),tu=null;null!=te&&(tu=mn(te,"weights","computeWeightedLoss"));var tc=null==tu?to:to.mul(tu);if(tr===aF.NONE)return tc;if(tr===aF.SUM)return tc.sum();if(tr===aF.MEAN){if(null==tu)return tc.mean();var tl=to.size/tu.size,th=tc.sum().div(tu.sum());return tl>1?th.div(On(tl)):th}if(tr===aF.SUM_BY_NONZERO_WEIGHTS){if(null==tu)return tc.sum().div(On(to.size));var td=tu.mul(zn(to.shape)).notEqual(On(0)).sum().toFloat();return tc.sum().div(td)}throw Error("Unknown reduction: "+tr)}}),ay=An({cosineDistance_:function(g,te,tr,to,tu){void 0===tu&&(tu=aF.SUM_BY_NONZERO_WEIGHTS);var tc=mn(g,"labels","cosineDistance"),tl=mn(te,"predictions","cosineDistance"),th=null;return null!=to&&(th=mn(to,"weights","cosineDistance")),E(tc.shape,tl.shape,"Error in cosineDistance: "),ag(On(1).sub(tc.mul(tl).sum(tr,!0)),th,tu)}}),ax=An({hingeLoss_:function(g,te,tr,to){void 0===to&&(to=aF.SUM_BY_NONZERO_WEIGHTS);var tu=mn(g,"labels","hingeLoss"),tc=mn(te,"predictions","hingeLoss"),tl=null;null!=tr&&(tl=mn(tr,"weights","hingeLoss")),E(tu.shape,tc.shape,"Error in hingeLoss: ");var th=On(1);return tu=On(2).mul(tu).sub(th),ag(th.sub(tu.mul(tc)).relu(),tl,to)}}),ab=An({huberLoss_:function(g,te,tr,to,tu){void 0===to&&(to=1),void 0===tu&&(tu=aF.SUM_BY_NONZERO_WEIGHTS);var tc=mn(g,"labels","huberLoss"),tl=mn(te,"predictions","huberLoss"),th=null;null!=tr&&(th=mn(tr,"weights","huberLoss")),E(tc.shape,tl.shape,"Error in huberLoss: ");var td=On(to),tf=tl.sub(tc).abs(),tp=rL(tf,td),tv=tf.sub(tp);return ag(On(.5).mul(tp.square()).add(td.mul(tv)),th,tu)}}),aC=An({logLoss_:function(g,te,tr,to,tu){void 0===to&&(to=1e-7),void 0===tu&&(tu=aF.SUM_BY_NONZERO_WEIGHTS);var tc=mn(g,"labels","logLoss"),tl=mn(te,"predictions","logLoss"),th=null;null!=tr&&(th=mn(tr,"weights","logLoss")),E(tc.shape,tl.shape,"Error in logLoss: ");var td=On(1),tf=On(to);return ag(tc.mul(tl.add(tf).log()).neg().sub(td.sub(tc).mul(td.sub(tl).add(tf).log())),th,tu)}}),aw=An({meanSquaredError_:function(g,te,tr,to){void 0===to&&(to=aF.SUM_BY_NONZERO_WEIGHTS);var tu=mn(g,"labels","meanSquaredError"),tc=mn(te,"predictions","meanSquaredError"),tl=null;return null!=tr&&(tl=mn(tr,"weights","meanSquaredError")),E(tu.shape,tc.shape,"Error in meanSquaredError: "),ag(tu.squaredDifference(tc),tl,to)}}),aE=An({sigmoidCrossEntropy_:function(g,te,tr,to,tu){void 0===to&&(to=0),void 0===tu&&(tu=aF.SUM_BY_NONZERO_WEIGHTS);var tc,tl,th,td,tf,tp=mn(g,"multiClassLabels","sigmoidCrossEntropy"),tv=mn(te,"logits","sigmoidCrossEntropy"),tm=null;if(null!=tr&&(tm=mn(tr,"weights","sigmoidCrossEntropy")),E(tp.shape,tv.shape,"Error in sigmoidCrossEntropy: "),to>0){var tg=On(to),ty=On(1),tx=On(.5);tp=tp.mul(ty.sub(tg)).add(tx.mul(tg))}return ag((tc=mn(tp,"labels","sigmoidCrossEntropyWithLogits"),tl=mn(tv,"logits","sigmoidCrossEntropyWithLogits"),E(tc.shape,tl.shape,"Error in sigmoidCrossEntropyWithLogits: "),th=tl.relu(),td=tl.mul(tc),tf=tl.abs().neg().exp().log1p(),th.sub(td).add(tf)),tm,tu)}}),aR=An({softmaxCrossEntropy_:function(g,te,tr,to,tu){void 0===to&&(to=0),void 0===tu&&(tu=aF.SUM_BY_NONZERO_WEIGHTS);var tc=mn(g,"onehotLabels","softmaxCrossEntropy"),tl=mn(te,"logits","softmaxCrossEntropy"),th=null;if(null!=tr&&(th=mn(tr,"weights","softmaxCrossEntropy")),E(tc.shape,tl.shape,"Error in softmaxCrossEntropy: "),to>0){var td=On(to),tf=On(1),tp=On(tc.shape[1]);tc=tc.mul(tf.sub(td)).add(td.div(tp))}return ag(function(g,te,tr){if(void 0===tr&&(tr=-1),-1===tr&&(tr=te.rank-1),tr!==te.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank "+te.rank+" and dim was "+tr);return vo(function(g,te,to){var tu=te.logSumExp([tr],!0),tc=te.toFloat().sub(tu);return to([g,tc]),{value:tc.mul(g).neg().sum([tr]),gradFunc:function(g,te){var to=te[0],tu=te[1],tc=wn(g.shape,[tr]);return[g.reshape(tc).mul(to.toFloat().sub(tu.exp())),g.reshape(tc).mul(tu.exp().sub(to.toFloat()))]}}})(g,te)}(tc,tl),th,tu)}}),aI=Object.freeze({get Reduction(){return aF},absoluteDifference:am,computeWeightedLoss:ag,cosineDistance:ay,hingeLoss:ax,huberLoss:ab,logLoss:aC,meanSquaredError:aw,sigmoidCrossEntropy:aE,softmaxCrossEntropy:aR});function wh(g,te){return void 0===te&&(te=!1),tB.tidy(function(){if(2!==g.shape.length)throw Error("qr2d() requires a 2D Tensor, but got a "+g.shape.length+"D Tensor.");for(var tr=g.shape[0],to=g.shape[1],tu=nE(tr),tc=g.clone(),tl=Bn([[1]],[1,1]),th=tl.clone(),td=tr>=to?to:tr,c=function(g){var te,td=tc,tf=th,tp=tu;th=(te=tB.tidy(function(){var te=tc.slice([g,g],[tr-g,1]),td=te.norm(),tf=tc.slice([g,g],[1,1]),tp=Bn([[-1]]).where(tf.greater(0),Bn([[1]])),tv=tf.sub(tp.mul(td)),tm=te.div(tv);th=1===tm.shape[0]?tl.clone():tl.concat(tm.slice([1,0],[tm.shape[0]-1,tm.shape[1]]),0);var tg=tp.matMul(tv).div(td).neg(),ty=tc.slice([g,0],[tr-g,to]),tx=tg.mul(th);if(0===g)tc=ty.sub(tx.matMul(th.transpose().matMul(ty)));else{var tb=ty.sub(tx.matMul(th.transpose().matMul(ty)));tc=tc.slice([0,0],[g,to]).concat(tb,0)}var tC=tu.slice([0,g],[tr,tu.shape[1]-g]);if(0===g)tu=tC.sub(tC.matMul(th).matMul(tx.transpose()));else{var tw=tC.sub(tC.matMul(th).matMul(tx.transpose()));tu=tu.slice([0,0],[tr,g]).concat(tw,1)}return[th,tc,tu]}))[0],tc=te[1],tu=te[2],tn([td,tf,tp])},tf=0;tf<td;++tf)c(tf);return!te&&tr>to&&(tu=tu.slice([0,0],[tr,to]),tc=tc.slice([0,0],[to,to])),[tu,tc]})}var ak=Object.freeze({bandPart:An({bandPart_:function(g,te,tr){if(te%1!=0)throw Error("bandPart(): numLower must be an integer, got "+te+".");if(tr%1!=0)throw Error("bandPart(): numUpper must be an integer, got "+tr+".");var to=mn(g,"a","bandPart");if(to.rank<2)throw Error("bandPart(): Rank must be at least 2, got "+to.rank+".");var tu=to.shape,tc=to.shape.slice(-2),tl=tc[0],th=tc[1];if(!(te<=tl))throw Error("bandPart(): numLower ("+te+") must not be greater than the number of rows ("+tl+").");if(!(tr<=th))throw Error("bandPart(): numUpper ("+tr+") must not be greater than the number of columns ("+th+").");te<0&&(te=tl),tr<0&&(tr=th);var td=rj(Kn(0,tl,1,"int32").reshape([-1,1]),Kn(0,th,1,"int32")),tf=rE(td.lessEqual(On(+te,"int32")),td.greaterEqual(On(-tr,"int32"))),tp=Gn([tl,th],to.dtype);return nL(nU(to.reshape([-1,tl,th])).map(function(g){return rA(tf,g,tp)})).reshape(tu)}}),gramSchmidt:An({gramSchmidt_:function(g){if(Array.isArray(g)){te=!1,C(null!=g&&g.length>0,function(){return"Gram-Schmidt process: input must not be null, undefined, or empty"});for(var te,tr=g[0].shape[0],r=function(te){C(g[te].shape[0]===tr,function(){return"Gram-Schmidt: Non-unique lengths found in the input vectors: ("+g[te].shape[0]+" vs. "+tr+")"})},to=1;to<g.length;++to)r(to)}else te=!0,g=t8(g,g.shape[0],0).map(function(g){return nP(g,[0])});C(g.length<=g[0].shape[0],function(){return"Gram-Schmidt: Number of vectors ("+g.length+") exceeds number of dimensions ("+g[0].shape[0]+")."});var tu=[],tc=g,s=function(g){tu.push(tB.tidy(function(){var te=tc[g];if(g>0)for(var tr=0;tr<g;++tr){var to=oH(tu[tr].mulStrict(te)).mul(tu[tr]);te=te.sub(to)}return te.div(oZ(te,"euclidean"))}))};for(to=0;to<g.length;++to)s(to);return te?nL(tu,0):tu}}),qr:An({qr_:function(g,te){if(void 0===te&&(te=!1),g.rank<2)throw Error("qr() requires input tensor to have a rank >= 2, but got rank "+g.rank);if(2===g.rank)return wh(g,te);var tr=g.shape.slice(0,g.shape.length-2).reduce(function(g,te){return g*te}),to=nU(g.reshape([tr,g.shape[g.shape.length-2],g.shape[g.shape.length-1]]),0),tu=[],tc=[];return to.forEach(function(g){var tr=wh(g,te),to=tr[0],tl=tr[1];tu.push(to),tc.push(tl)}),[nL(tu,0).reshape(g.shape),nL(tc,0).reshape(g.shape)]}})});function kh(g,te,tr,to,tu,tc){null==to&&(to=.5),null==tu&&(tu=Number.NEGATIVE_INFINITY),null==tc&&(tc=0);var tl=g.shape[0];return tr=Math.min(tr,tl),C(0<=to&&to<=1,function(){return"iouThreshold must be in [0, 1], but was '"+to+"'"}),C(2===g.rank,function(){return"boxes must be a 2D tensor, but was of rank '"+g.rank+"'"}),C(4===g.shape[1],function(){return"boxes must have 4 columns, but 2nd dimension was "+g.shape[1]}),C(1===te.rank,function(){return"scores must be a 1D tensor"}),C(te.shape[0]===tl,function(){return"scores has incompatible shape with boxes. Expected "+tl+", but was "+te.shape[0]}),C(0<=tc&&tc<=1,function(){return"softNmsSigma must be in [0, 1], but was '"+tc+"'"}),{maxOutputSize:tr,iouThreshold:to,scoreThreshold:tu,softNmsSigma:tc}}var aA=Object.freeze({resizeBilinear:An({resizeBilinear_:function(g,te,tr){void 0===tr&&(tr=!1);var to=mn(g,"images","resizeBilinear");C(3===to.rank||4===to.rank,function(){return"Error in resizeBilinear: x must be rank 3 or 4, but got rank "+to.rank+"."}),C(2===te.length,function(){return"Error in resizeBilinear: new shape must 2D, but got shape "+te+"."});var tu=to,tc=!1;3===to.rank&&(tc=!0,tu=to.as4D(1,to.shape[0],to.shape[1],to.shape[2]));var tl=te[0],th=te[1],td=tB.runKernelFunc(function(g,te){return te([tu]),g.resizeBilinear(tu,tl,th,tr)},{x:tu},function(g,te){return{x:function(){return tB.runKernelFunc(function(to){return to.resizeBilinearBackprop(g,te[0],tr)},{})}}},"ResizeBilinear",{alignCorners:tr,newHeight:tl,newWidth:th});return tc?td.as3D(td.shape[1],td.shape[2],td.shape[3]):td}}),resizeNearestNeighbor:An({resizeNearestNeighbor_:function(g,te,tr){void 0===tr&&(tr=!1);var to=mn(g,"images","resizeNearestNeighbor");C(3===to.rank||4===to.rank,function(){return"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank "+to.rank+"."}),C(2===te.length,function(){return"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+te+"."}),C("float32"===to.dtype||"int32"===to.dtype,function(){return"`images` must have `int32` or `float32` as dtype"});var tu=to,tc=!1;3===to.rank&&(tc=!0,tu=to.as4D(1,to.shape[0],to.shape[1],to.shape[2]));var tl=te[0],th=te[1],td=tB.runKernelFunc(function(g,te){return te([tu]),g.resizeNearestNeighbor(tu,tl,th,tr)},{batchImages:tu},function(g,te){return{batchImages:function(){return tB.runKernelFunc(function(to){return to.resizeNearestNeighborBackprop(g,te[0],tr)},{})}}});return tc?td.as3D(td.shape[1],td.shape[2],td.shape[3]):td}}),nonMaxSuppression:An({nonMaxSuppression_:function(g,te,tr,to,tu){void 0===to&&(to=.5),void 0===tu&&(tu=Number.NEGATIVE_INFINITY);var tc=mn(g,"boxes","nonMaxSuppression"),tl=mn(te,"scores","nonMaxSuppression"),th=kh(tc,tl,tr,to,tu);tr=th.maxOutputSize,to=th.iouThreshold,tu=th.scoreThreshold;var td={maxOutputSize:tr,iouThreshold:to,scoreThreshold:tu};return tB.runKernelFunc(function(g){return g.nonMaxSuppression(tc,tl,tr,to,tu)},{boxes:tc,scores:tl},null,"NonMaxSuppressionV3",td)}}),nonMaxSuppressionAsync:function(g,te,tr,to,tu){return void 0===to&&(to=.5),void 0===tu&&(tu=Number.NEGATIVE_INFINITY),n(this,void 0,void 0,function(){var tc,tl,th,td,tf;return r(this,function(tp){switch(tp.label){case 0:return tc=mn(g,"boxes","nonMaxSuppressionAsync"),tl=mn(te,"scores","nonMaxSuppressionAsync"),tr=(th=kh(tc,tl,tr,to,tu)).maxOutputSize,to=th.iouThreshold,tu=th.scoreThreshold,[4,Promise.all([tc.data(),tl.data()])];case 1:return tf=jo((td=tp.sent())[0],td[1],tr,to,tu),tc!==g&&tc.dispose(),tl!==te&&tl.dispose(),[2,tf]}})})},nonMaxSuppressionWithScore:An({nonMaxSuppressionWithScore_:function(g,te,tr,to,tu,tc){void 0===to&&(to=.5),void 0===tu&&(tu=Number.NEGATIVE_INFINITY),void 0===tc&&(tc=0);var tl=mn(g,"boxes","nonMaxSuppression"),th=mn(te,"scores","nonMaxSuppression"),td=kh(tl,th,tr,to,tu,tc),tf={maxOutputSize:tr=td.maxOutputSize,iouThreshold:to=td.iouThreshold,scoreThreshold:tu=td.scoreThreshold,softNmsSigma:tc=td.softNmsSigma},tp=tB.runKernel("NonMaxSuppressionV5",{boxes:tl,scores:th},tf);return{selectedIndices:tp[0],selectedScores:tp[1]}}}),nonMaxSuppressionWithScoreAsync:function(g,te,tr,to,tu,tc){return void 0===to&&(to=.5),void 0===tu&&(tu=Number.NEGATIVE_INFINITY),void 0===tc&&(tc=0),n(this,void 0,void 0,function(){var tl,th,td,tf,tp;return r(this,function(tv){switch(tv.label){case 0:return tl=mn(g,"boxes","nonMaxSuppressionAsync"),th=mn(te,"scores","nonMaxSuppressionAsync"),tr=(td=kh(tl,th,tr,to,tu,tc)).maxOutputSize,to=td.iouThreshold,tu=td.scoreThreshold,tc=td.softNmsSigma,[4,Promise.all([tl.data(),th.data()])];case 1:return tp=Xo((tf=tv.sent())[0],tf[1],tr,to,tu,tc),tl!==g&&tl.dispose(),th!==te&&th.dispose(),[2,tp]}})})},cropAndResize:An({cropAndResize_:function(g,te,tr,to,tu,tc){var tl=mn(g,"image","cropAndResize"),th=mn(te,"boxes","cropAndResize","float32"),td=mn(tr,"boxInd","cropAndResize","int32");tu=tu||"bilinear",tc=tc||0;var tf=th.shape[0];return C(4===tl.rank,function(){return"Error in cropAndResize: image must be rank 4,but got rank "+tl.rank+"."}),C(2===th.rank&&4===th.shape[1],function(){return"Error in cropAndResize: boxes must be have size ["+tf+",4] but had shape "+th.shape+"."}),C(1===td.rank&&td.shape[0]===tf,function(){return"Error in cropAndResize: boxInd must be have size ["+tf+"] but had shape "+th.shape+"."}),C(2===to.length,function(){return"Error in cropAndResize: cropSize must be of length 2, but got length "+to.length+"."}),C(to[0]>=1&&to[1]>=1,function(){return"cropSize must be atleast [1,1], but was "+to}),C("bilinear"===tu||"nearest"===tu,function(){return"method must be bilinear or nearest, but was "+tu}),tB.runKernelFunc(function(g,te){return g.cropAndResize(tl,th,td,to,tu,tc)},{images:tl,boxes:th,boxInd:td},null,"CropAndResize",{method:tu,extrapolationValue:tc,cropSize:to})}})}),Mh=function(g,te){return!(g>0)||"linear"===te},Bh=function(g,te,tr){if(null==tr||"linear"===tr)return g;if("relu"===tr)return g.mul(te.step());throw Error("Gradient for activation "+tr+" has not been implemented yet.")},Ph=function(g,te){var tr=te,to=Eo(g.shape,te.shape);return to.length>0&&(tr=tr.sum(to)),tr.reshape(g.shape)},Lh=function(g,te,tr){if("linear"===te)return g;if("relu"===te)return oX(g);if("elu"===te)return oq(g);if("relu6"===te)return o$(g);if("prelu"===te)return oj(g,tr);throw Error("Unknown fused activation "+te+".")},aS=Object.freeze({image:aA,linalg:ak,losses:aI,spectral:an,fused:Object.freeze({matMul:An({fusedMatMul_:function(g){var te,tr=g.a,to=g.b,tu=g.transposeA,tc=void 0!==tu&&tu,tl=g.transposeB,th=void 0!==tl&&tl,td=g.bias,tf=g.activation,tp=void 0===tf?"linear":tf,tv=g.preluActivationWeights;if(!1===Mh(tB.state.gradientDepth,tp)){var tm=om(tr,to,tc,th);return null!=td&&(tm=rS(tm,td)),Lh(tm,tp,tv)}var tg=mn(tr,"a","fused matMul"),ty=mn(to,"b","fused matMul");tg=(te=Nt(tg,ty))[0],ty=te[1];var tx=tc?tg.shape[tg.rank-2]:tg.shape[tg.rank-1],tb=th?ty.shape[ty.rank-1]:ty.shape[ty.rank-2],tC=tc?tg.shape[tg.rank-1]:tg.shape[tg.rank-2],tw=th?ty.shape[ty.rank-2]:ty.shape[ty.rank-1],tE=tg.shape.slice(0,-2),tR=ty.shape.slice(0,-2),tI=k(tE),tk=k(tR);C(tg.rank>=2&&ty.rank>=2&&tg.rank===ty.rank,function(){return"Error in fused matMul: inputs must have the same rank of at least 2, got ranks "+tg.rank+" and "+ty.rank+"."}),C(S(tE,tR),function(){return"Error in fused matMul: outer dimensions ("+tE+") and ("+tR+") of Tensors with shapes "+tg.shape+" and "+ty.shape+" must match."}),C(tx===tb,function(){return"Error in fused matMul: inner shapes ("+tx+") and ("+tb+") of Tensors with shapes "+tg.shape+" and "+ty.shape+" and transposeA="+tc+" and transposeB="+th+" must match."});var tA,tS,tD=tg.shape.slice(0,-2).concat([tC,tw]),tN=tc?tg.as3D(tI,tx,tC):tg.as3D(tI,tC,tx),tT=th?ty.as3D(tk,tw,tb):ty.as3D(tk,tb,tw);null!=td&&Ro(tD,(tA=Nt(tA=mn(td,"bias","fused matMul"),tg)[0]).shape),null!=tv&&(tS=mn(tv,"prelu weights","fused matMul"));var tF={a:tN,b:tT};null!=td&&(tF.bias=tA),null!=tv&&(tF.preluActivationWeights=tS);var tO=[tN,tT];return tB.runKernelFunc(function(g,te){var tr=g.fusedBatchMatMul({a:tN,b:tT,transposeA:tc,transposeB:th,bias:tA,activation:tp,preluActivationWeights:tS});return te([tN,tT,tr]),tr},tF,function(g,te){var tr=te[0],to=te[1],tu=Bh(g,te[2],tp),tl={};return null!=td&&(tl={bias:function(){return Ph(tA,tu)}}),tc||th?!tc&&th?Object.assign({a:function(){return tu.matMul(to,!1,!1)},b:function(){return tu.matMul(tr,!0,!1)}},tl):tc&&!th?Object.assign({a:function(){return to.matMul(tu,!1,!0)},b:function(){return tr.matMul(tu,!1,!1)}},tl):Object.assign({a:function(){return to.matMul(tu,!0,!0)},b:function(){return tu.matMul(tr,!0,!0)}},tl):Object.assign({a:function(){return tu.matMul(to,!1,!0)},b:function(){return tr.matMul(tu,!0,!1)}},tl)},"_FusedMatMul",{transposeA:tc,transposeB:th,activation:tp},tO,[!0]).reshape(tD)}}),conv2d:An({fusedConv2d_:function(g){var te=g.x,tr=g.filter,to=g.strides,tu=g.pad,tc=g.dataFormat,tl=void 0===tc?"NHWC":tc,th=g.dilations,td=void 0===th?[1,1]:th,tf=g.dimRoundingMode,tp=g.bias,tv=g.activation,tm=void 0===tv?"linear":tv,tg=g.preluActivationWeights;if(tm=tm||"linear",!1===Mh(tB.state.gradientDepth,tm)){var ty=on(te,tr,to,tu,tl,td,tf);return null!=tp&&(ty=rS(ty,tp)),Lh(ty,tm,tg)}var tx=mn(te,"x","conv2d"),tb=mn(tr,"filter","conv2d"),tC=tx,tw=!1;3===tx.rank&&(tw=!0,tC=tx.as4D(1,tx.shape[0],tx.shape[1],tx.shape[2])),C(4===tC.rank,function(){return"Error in fused conv2d: input must be rank 4, but got rank "+tC.rank+"."}),C(4===tb.rank,function(){return"Error in fused conv2d: filter must be rank 4, but got rank "+tb.rank+"."}),null!=tf&&C(A(tu),function(){return"Error in fused conv2d: pad must be an integer when using, dimRoundingMode "+tf+" but got pad "+tu+"."}),C(tC.shape[3]===tb.shape[2],function(){return"Error in conv2d: depth of input ("+tC.shape[3]+") must match input depth for filter "+tb.shape[2]+"."}),C(Mo(to,td),function(){return"Error in conv2D: Either strides or dilations must be 1. Got strides "+to+" and dilations '"+td+"'"}),C("NHWC"===tl,function(){return"Error in conv2d: got dataFormat of "+tl+" but only NHWC is currently supported."});var tE,tR,tI=So(tC.shape,tb.shape,to,td,tu,tf);null!=tp&&(tE=Nt(tE=mn(tp,"bias","fused conv2d"),tx)[0],Ro(tI.outShape,tE.shape)),null!=tg&&(tR=mn(tg,"prelu weights","fused conv2d"));var tk={x:tC,filter:tb};null!=tp&&(tk.bias=tE),null!=tg&&(tk.preluActivationWeights=tR);var tA=[tb,tC],tS=tB.runKernelFunc(function(g,te){var tr=g.fusedConv2d({input:tC,filter:tb,convInfo:tI,bias:tE,activation:tm,preluActivationWeights:tR});return te([tb,tC,tr]),tr},tk,function(g,te){var tr=te[0],tc=te[1],tl=Bh(g,te[2],tm);C(Oo(td),function(){return"Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+td+"'"});var th={};return null!=tp&&(th={bias:function(){return Ph(tE,tl)}}),Object.assign({x:function(){return oc(tc.shape,tl,tr,to,tu)},filter:function(){return ou(tc,tl,tr.shape,to,tu)}},th)},"FusedConv2D",{convInfo:tI,activation:tm},tA,[!0]);return tw?tS.as3D(tS.shape[1],tS.shape[2],tS.shape[3]):tS}}),depthwiseConv2d:An({fusedDepthwiseConv2d_:function(g){var te=g.x,tr=g.filter,to=g.strides,tu=g.pad,tc=g.dataFormat,tl=g.dilations,th=void 0===tl?[1,1]:tl,td=g.dimRoundingMode,tf=g.bias,tp=g.activation,tv=void 0===tp?"linear":tp,tm=g.preluActivationWeights;if(!1===Mh(tB.state.gradientDepth,tv)){var tg=ol(te,tr,to,tu,void 0===tc?"NHWC":tc,th,td);return null!=tf&&(tg=rS(tg,tf)),Lh(tg,tv,tm)}var ty=mn(te,"x","depthwiseConv2d"),tx=mn(tr,"filter","depthwiseConv2d"),tb=ty,tC=!1;3===ty.rank&&(tC=!0,tb=ty.as4D(1,ty.shape[0],ty.shape[1],ty.shape[2])),C(4===tb.rank,function(){return"Error in fused depthwiseConv2d: input must be rank 4, but got rank "+tb.rank+"."}),C(4===tx.rank,function(){return"Error in fused depthwiseConv2d: filter must be rank 4, but got rank "+tx.rank+"."}),C(tb.shape[3]===tx.shape[2],function(){return"Error in fused depthwiseConv2d: number of input channels ("+tb.shape[3]+") must match the inChannels dimension in filter "+tx.shape[2]+"."}),null==th&&(th=[1,1]),C(Mo(to,th),function(){return"Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides "+to+" and dilations '"+th+"'"}),null!=td&&C(A(tu),function(){return"Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode "+td+" but got pad "+tu+"."});var tw,tE,tR=So(tb.shape,tx.shape,to,th,tu,td,!0);null!=tf&&(tw=Nt(tw=mn(tf,"bias","fused conv2d"),ty)[0],Ro(tR.outShape,tw.shape)),null!=tm&&(tE=mn(tm,"prelu weights","fused depthwiseConv2d"));var tI={x:tb,filter:tx};null!=tf&&(tI.bias=tw),null!=tm&&(tI.preluActivationWeights=tE);var tk=[tx,tb],tA=tB.runKernelFunc(function(g,te){var tr=g.fusedDepthwiseConv2D({input:tb,filter:tx,convInfo:tR,bias:tw,activation:tv,preluActivationWeights:tE});return te([tx,tb,tr]),tr},tI,function(g,te){C(Oo(th),function(){return"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+th+"'"});var tr=te[0],to=te[1],tu=Bh(g,te[2],tv),tc={};return null!=tf&&(tc={bias:function(){return Ph(tw,tu)}}),Object.assign({x:function(){return oh(to.shape,tu,tr,tR)},filter:function(){return od(to,tu,tr.shape,tR)}},tc)},"FusedDepthwiseConv2D",{convInfo:tR,activation:tv},tk,[!0]);return tC?tA.as3D(tA.shape[1],tA.shape[2],tA.shape[3]):tA}})}),signal:av,square:eM,squaredDifference:eP,conv1d:r9,conv2d:on,conv3d:or,depthwiseConv2d:ol,separableConv2d:of,conv2dTranspose:op,conv3dTranspose:ov,op:An,batchNormalization2d:rv,batchNormalization3d:rm,batchNormalization4d:rg,batchNormalization:ry,batchNorm:rx,batchNorm2d:rb,batchNorm3d:rC,batchNorm4d:rw,booleanMaskAsync:function(g,te,tr){return n(this,void 0,void 0,function(){var to,tu,tc,tl,th,td,tf,tp,tv,tm,tg,ty,tx;return r(this,function(tb){switch(tb.label){case 0:for(to=mn(g,"tensor","boolMask"),tu=mn(te,"mask","boolMask","bool"),tc=null==tr?0:tr,tl=tu.rank,th=to.shape,C(tl>0,function(){return"mask cannot be scalar"}),E(th.slice(tc,tc+tl),tu.shape,"mask's shape must match the first K dimensions of tensor's shape,"),td=1,tf=tc;tf<tc+tl;tf++)td*=th[tf];return tp=th.slice(0,tc).concat([td],th.slice(tc+tl)),tv=to.reshape(tp),[4,nc(tm=tu.reshape([-1]))];case 1:return ty=(tg=tb.sent()).squeeze([1]),tx=r8(tv,ty,tc),g!==to&&to.dispose(),te!==tu&&tu.dispose(),ty.dispose(),tv.dispose(),tm.dispose(),tg.dispose(),[2,tx]}})})},complex:tJ,real:tQ,imag:tZ,concat:t2,concat1d:t3,concat2d:t4,concat3d:t5,concat4d:t6,split:t8,matMul:om,dot:og,outerProduct:oy,reverse:ox,reverse1d:ob,reverse2d:oC,reverse3d:ow,reverse4d:oE,maxPool:oR,avgPool:oI,pool:ok,maxPool3d:oA,avgPool3d:oS,slice:oD,slice1d:oN,slice2d:oT,slice3d:oF,slice4d:oO,abs:eL,acos:eW,acosh:eV,asin:eU,asinh:ez,atan:eH,atanh:eG,ceil:eq,clipByValue:eK,cos:ej,cosh:eX,erf:e$,exp:eY,expm1:eJ,floor:eQ,log:eZ,log1p:e0,logSigmoid:e1,neg:e2,reciprocal:e3,round:e4,rsqrt:e5,sigmoid:e6,sign:e8,isNaN:e7,isInf:e9,isFinite:rn,sin:rr,sinh:ru,softplus:rc,sqrt:rl,step:rd,tan:rf,tanh:rp,all:o_,any:oM,argMax:oB,argMin:oP,logSumExp:oL,max:oW,mean:oV,min:oU,moments:oz,sum:oH,prod:oG,equal:r$,equalStrict:rY,greater:rJ,greaterEqual:rQ,greaterEqualStrict:rZ,greaterStrict:r0,less:r1,lessEqual:r2,lessEqualStrict:r3,lessStrict:r4,notEqual:r5,notEqualStrict:r6,add:rS,addN:rD,addStrict:rN,atan2:rT,div:rF,divNoNan:rO,divStrict:r_,floorDiv:rM,maximum:rB,maximumStrict:rP,minimum:rL,minimumStrict:rW,mod:rV,modStrict:rU,mul:rz,mulStrict:rH,pow:rG,powStrict:rq,squaredDifferenceStrict:rK,sub:rj,subStrict:rX,elu:oq,leakyRelu:oK,prelu:oj,relu:oX,relu6:o$,selu:oY,logicalAnd:rE,logicalNot:rR,logicalOr:rI,logicalXor:rk,where:rA,whereAsync:nc,buffer:dr,print:pr,batchToSpaceND:nm,broadcastTo:ng,cast:ny,clone:nx,cumsum:nb,depthToSpace:nC,expandDims:nw,eye:nE,multinomial:nR,oneHot:nI,pad:nk,pad1d:nA,pad2d:nS,pad3d:nD,pad4d:nN,rand:nT,randomNormal:nF,randomGamma:nO,randomUniform:n_,reshape:nM,spaceToBatchND:nB,squeeze:nP,stack:nL,tile:nW,truncatedNormal:nV,unstack:nU,setdiff1dAsync:function(g,te){return n(this,void 0,void 0,function(){var tr,to,tu,tc,tl,th,td,tf,tp,tv;return r(this,function(tg){switch(tg.label){case 0:return tr=mn(g,"x","setdiff1d"),to=mn(te,"y","setdiff1d"),C(tr.dtype===to.dtype,function(){return"x and y should have the same dtype, but got x ("+tr.dtype+") and y ("+to.dtype+")."}),C(1===tr.rank,function(){return"x should be 1D tensor, but got x ("+tr.shape+")."}),C(1===to.rank,function(){return"y should be 1D tensor, but got y ("+to.shape+")."}),[4,tr.data()];case 1:return tu=tg.sent(),[4,to.data()];case 2:for(tc=tg.sent(),tl=new Set(tc),th=0,tp=0;tp<tu.length;tp++)tl.has(tu[tp])||th++;for(td=new tm([th],tr.dtype),tf=new tm([th],"int32"),tp=0,tv=0;tp<tu.length;tp++)tl.has(tu[tp])||(td.values[tv]=tu[tp],tf.values[tv]=tp,tv++);return[2,[td.toTensor(),tf.toTensor()]]}})})},fill:Hn,linspace:qn,ones:zn,range:Kn,scalar:On,tensor:Fn,tensor1d:Mn,tensor2d:Bn,tensor3d:Pn,tensor4d:Ln,tensor5d:Wn,tensor6d:Un,variable:Vn,zeros:Gn,onesLike:t0,zerosLike:t1,transpose:oJ,softmax:nz,logSoftmax:nH,localResponseNormalization:oQ,norm:oZ,gather:r8,unsortedSegmentSum:r7,basicLSTMCell:o0,multiRNNCell:o1,movingAverage:o2,stridedSlice:o3,topk:o4,scatterND:o5,fft:o6,ifft:o8,rfft:o7,irfft:o9,sparseToDense:ar,gatherND:au,diag:ac,dropout:al,hannWindow:ah,hammingWindow:ad,frame:af,stft:ap,inTopKAsync:function(g,te,tr){return void 0===tr&&(tr=1),n(this,void 0,void 0,function(){var to,tu,tc,tl,th,td,tf,tp,tv,tm,tg,ty,tx,tb;return r(this,function(tC){switch(tC.label){case 0:return to=mn(g,"predictions","inTopK"),tu=mn(te,"targets","inTopK"),C(to.rank>1,function(){return"inTopK() expects the predictions to be of rank 2 or higher, but got "+to.rank}),C(to.rank-1===tu.rank,function(){return"predictions rank should be 1 larger than targets rank, but got predictions rank "+to.rank+" and targets rank "+tu.rank}),E(to.shape.slice(0,to.shape.length-1),tu.shape,"predictions's shape should be align with the targets' shape, except the last dimension."),tc=to.shape[to.shape.length-1],C(tr>0&&tr<=tc,function(){return"'k' passed to inTopK() must be > 0 && <= the predictions last dimension ("+tc+"), but got "+tr}),[4,to.data()];case 1:return tl=tC.sent(),[4,tu.data()];case 2:for(th=tC.sent(),tp=(td=[tl.length/tc,tc])[1],tv=B("bool",tf=td[0]),tm=0;tm<tf;tm++){for(tg=tm*tp,ty=tl.subarray(tg,tg+tp),tx=[],tb=0;tb<ty.length;tb++)tx.push({value:ty[tb],index:tb});for(tx.sort(function(g,te){return te.value-g.value}),tv[tm]=0,tb=0;tb<tr;tb++)if(tx[tb].index===th[tm]){tv[tm]=1;break}}return g!==to&&to.dispose(),te!==tu&&tu.dispose(),[2,Fn(tv,tu.shape,"bool")]}})})}});function Hh(g,te){Array.isArray(g)||(g=[g]),g.forEach(function(g){null!=g&&C("complex64"!==g.dtype,function(){return te+" does not support complex64 tensors."})})}function qh(g,te,tr,to){if("linear"===tr)return g.linear(te);if("relu"===tr)return g.relu(te);if("elu"===tr)return g.elu(te);if("relu6"===tr)return g.relu6(te);if("prelu"===tr)return g.prelu(te,to);throw Error("Activation "+tr+" has not been implemented for the CPU backend.")}var aD=function(g){function o(){var te=g.call(this)||this;return te.blockSize=48,te.firstUse=!0,te.data=new nG(te,tB),te}return e(o,g),o.prototype.write=function(g,te,tr){this.firstUse&&(this.firstUse=!1,th.get("IS_NODE")&&dn("\n============================\nHi there \uD83D\uDC4B. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));var to={};return this.data.set(to,{values:g,dtype:tr}),to},o.prototype.move=function(g,te,tr,to){this.data.set(g,{values:te,dtype:to})},o.prototype.numDataIds=function(){return this.data.numDataIds()},o.prototype.read=function(g){return n(this,void 0,void 0,function(){return r(this,function(te){return[2,this.readSync(g)]})})},o.prototype.readSync=function(g){var te=this.data.get(g),tr=te.dtype,to=te.complexTensors;return"complex64"===tr?Vo(this.readSync(to.real.dataId),this.readSync(to.imag.dataId)):this.data.get(g).values},o.prototype.bufferSync=function(g){var te=this.readSync(g.dataId),tr=te;if("string"===g.dtype)try{tr=te.map(function(g){return ot(g)})}catch(g){throw Error("Failed to decode encoded string bytes into utf-8")}return dr(g.shape,g.dtype,tr)},o.prototype.makeOutput=function(g,te,tr){var to=this.write(g,te,tr);return tB.makeTensorFromDataId(to,te,tr,this)},o.prototype.disposeData=function(g){if(this.data.has(g)){var te=this.data.get(g).complexTensors;null!=te&&(te.real.dispose(),te.imag.dispose()),this.data.delete(g)}},o.prototype.time=function(g){return n(this,void 0,void 0,function(){var te;return r(this,function(tr){return te=et(),g(),[2,{kernelMs:et()-te}]})})},o.prototype.memory=function(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}},o.prototype.complex=function(g,te){var tr=this.makeOutput(null,g.shape,"complex64");return this.data.get(tr.dataId).complexTensors={real:tB.keep(g.clone()),imag:tB.keep(te.clone())},tr},o.prototype.real=function(g){return this.data.get(g.dataId).complexTensors.real.clone()},o.prototype.imag=function(g){return this.data.get(g.dataId).complexTensors.imag.clone()},o.prototype.slice=function(g,te,tr){if(Hh(g,"slice"),io(g.shape,te,tr)){var to=so(te,g.strides),tu=k(tr);return Fn(this.readSync(g.dataId).subarray(to,to+tu),tr,g.dtype)}for(var tc=dr(tr,g.dtype),tl=this.bufferSync(g),th=0;th<tc.size;++th){var td=tc.indexToLoc(th).map(function(g,tr){return g+te[tr]});tc.values[th]=tl.get.apply(tl,td)}return tc.toTensor()},o.prototype.stridedSlice=function(g,te,tr,to){Hh(g,"stridedSlice");var tu=ro(te,tr,to);if(tu.some(function(g){return 0===g}))return Fn([],tu);for(var tc=dr(tu,g.dtype),tl=this.bufferSync(g),th=0;th<tc.size;th++){for(var td=tc.indexToLoc(th),tf=Array(td.length),tp=0;tp<tf.length;tp++)tf[tp]=td[tp]*to[tp]+te[tp];tc.set.apply(tc,[tl.get.apply(tl,tf)].concat(td))}return tc.toTensor()},o.prototype.diag=function(g){for(var te=this.readSync(g.dataId),tr=dr([g.size,g.size],g.dtype),to=tr.values,tu=0;tu<te.length;tu++)to[tu*g.size+tu]=te[tu];return tr.toTensor()},o.prototype.unstack=function(g,te){for(var tr=g.shape[te],to=Array(g.rank-1),tu=0,tc=0;tc<g.rank;tc++)tc!==te&&(to[tu++]=g.shape[tc]);var tl=Array(g.rank).fill(0),th=g.shape.slice();th[te]=1;var td=Array(tr);for(tc=0;tc<td.length;tc++)tl[te]=tc,td[tc]=this.slice(g,tl,th).reshape(to);return td},o.prototype.reverse=function(g,te){Hh(g,"reverse");for(var tr=dr(g.shape,g.dtype),to=this.bufferSync(g),tu=0;tu<tr.size;tu++)(function(tu){var tc=tr.indexToLoc(tu),tl=tc.slice();te.forEach(function(te){return tl[te]=g.shape[te]-1-tl[te]}),tr.set.apply(tr,[to.get.apply(to,tl)].concat(tc))})(tu);return tr.toTensor()},o.prototype.concat=function(g,te){var tr=this;if("complex64"===g[0].dtype){var to=g.map(function(g){return tQ(g)}),tu=g.map(function(g){return tZ(g)});return tJ(this.concat(to,te),this.concat(tu,te))}var tc=g.map(function(g){var tr=k(g.shape.slice(te));return g.as2D(-1,tr)}),tl=Sn(tc.map(function(g){return g.shape}),1),th=dr(tl,g[0].dtype).values;if(1===tc[0].shape[0]){var td=0;tc.forEach(function(g){th.set(tr.readSync(g.dataId),td),td+=g.size})}else{var tf=0;tc.forEach(function(g){for(var te=tr.readSync(g.dataId),to=0,tu=0;tu<g.shape[0];++tu)for(var tc=tu*tl[1]+tf,td=0;td<g.shape[1];++td)th[tc+td]=te[to++];tf+=g.shape[1]})}return Fn(th,Sn(g.map(function(g){return g.shape}),te),g[0].dtype)},o.prototype.neg=function(g){return Hh(g,"neg"),this.multiply(On(-1),g)},o.prototype.add=function(g,te){return"complex64"===g.dtype||"complex64"===te.dtype?this.broadcastedBinaryComplexOp(g.cast("complex64"),te.cast("complex64"),function(g,te,tr,to){return{real:g+tr,imag:te+to}}):this.broadcastedBinaryOp(g,te,Dt(g.dtype,te.dtype),function(g,te){return g+te})},o.prototype.addN=function(g){var te=this;Hh(g,"addN");for(var tr=g.map(function(g){return te.readSync(g.dataId)}),to=dr(g[0].shape,g[0].dtype),tu=to.values,tc=0;tc<g.length;tc++)for(var tl=tr[tc],th=0;th<tu.length;th++)tu[th]+=tl[th];return to.toTensor()},o.prototype.softmax=function(g,te){var tr=O([te],g.shape),to=this.max(g,tr),tu=wn(to.shape,tr),tc=this.subtract(g,to.reshape(tu)),tl=this.exp(tc),th=this.sum(tl,tr).reshape(tu);return this.realDivide(tl,th)},o.prototype.subtract=function(g,te){return"complex64"===g.dtype||"complex64"===te.dtype?this.broadcastedBinaryComplexOp(g.cast("complex64"),te.cast("complex64"),function(g,te,tr,to){return{real:g-tr,imag:te-to}}):this.broadcastedBinaryOp(g,te,Dt(g.dtype,te.dtype),function(g,te){return g-te})},o.prototype.pow=function(g,te){return Hh([g,te],"pow"),this.broadcastedBinaryOp(g,te,g.dtype,function(g,te){return Math.pow(g,te)})},o.prototype.batchMatMul=function(g,te,tr,to){Hh([g,te],"matMul");for(var tu=tr?g.shape[1]:g.shape[2],tc=tr?g.shape[2]:g.shape[1],tl=to?te.shape[1]:te.shape[2],th=g.shape[0],td=this.readSync(g.dataId),tf=this.readSync(te.dataId),tp=tr?[g.strides[0],1,g.strides[1]]:[g.strides[0],g.strides[1],1],tv=tp[0],tm=tp[1],tg=tp[2],ty=to?[1,te.strides[1],te.strides[0]]:[te.strides[1],1,te.strides[0]],tx=ty[0],tb=ty[1],tC=ty[2],tw=tc*tl,tE=dr([th,tc,tl],g.dtype),tR=tE.values,tI=this.blockSize,tk=0;tk<th;tk++)for(var tA=0;tA<tc;tA+=tI)for(var tS=0;tS<tl;tS+=tI)for(var tD=0;tD<tu;tD+=tI)for(var tN=Math.min(tA+tI,tc),tT=Math.min(tS+tI,tl),tF=Math.min(tD+tI,tu),tO=tA;tO<tN;tO++)for(var t_=tS;t_<tT;t_++){for(var tM=0,tB=tD;tB<tF;tB++)tM+=td[tk*tv+tO*tm+tB*tg]*tf[tB*tx+t_*tb+tk*tC];tR[tk*tw+(tO*tl+t_)]+=tM}return tE.toTensor()},o.prototype.fusedBatchMatMul=function(g){var te=g.a,tr=g.b,to=g.transposeA,tu=g.transposeB,tc=g.bias,tl=g.activation,th=g.preluActivationWeights,td=this.batchMatMul(te,tr,to,tu);return tc&&(td=this.add(td,tc)),tl&&(td=qh(this,td,tl,th)),td},o.prototype.multiply=function(g,te){return"complex64"===g.dtype||"complex64"===te.dtype?this.broadcastedBinaryComplexOp(g.cast("complex64"),te.cast("complex64"),function(g,te,tr,to){return{real:g*tr-te*to,imag:g*to+te*tr}}):this.broadcastedBinaryOp(g,te,Dt(g.dtype,te.dtype),function(g,te){return g*te})},o.prototype.realDivide=function(g,te){return Hh([g,te],"realDivide"),this.broadcastedBinaryOp(g,te,"float32",function(g,te){return g/te})},o.prototype.floorDiv=function(g,te){return Hh([g,te],"floorDiv"),this.broadcastedBinaryOp(g,te,"int32",function(g,te){return Math.floor(g/te)})},o.prototype.sum=function(g,te){Hh(g,"sum"),Cn("sum",te,g.rank);for(var tr=bn(g.shape,te),to=tr[0],tu=tr[1],tc=Gn(to,Dt(g.dtype,"int32")),tl=k(tu),th=this.readSync(tc.dataId),td=this.readSync(g.dataId),tf=0;tf<th.length;++tf){for(var tp=tf*tl,tv=0,tm=0;tm<tl;++tm)tv+=td[tp+tm];th[tf]=tv}return tc},o.prototype.prod=function(g,te){Hh(g,"sum");for(var tr=bn(g.shape,te),to=tr[0],tu=tr[1],tc=Gn(to,Dt(g.dtype,"int32")),tl=k(tu),th=this.readSync(tc.dataId),td=this.readSync(g.dataId),tf=0;tf<th.length;++tf){for(var tp=tf*tl,tv=1,tm=0;tm<tl;++tm)tv*=td[tp+tm];th[tf]=tv}return tc},o.prototype.unsortedSegmentSum=function(g,te,tr){Hh(g,"unsortedSegmentSum");for(var to=[],tu=g.rank-te.rank,tc=0;tc<tu;++tc)te=te.expandDims(tc+1);for(tc=0;tc<tr;++tc){var tl=r$(On(tc,"int32"),te).asType("float32").mul(g).sum(0);to.push(tl)}return nL(to)},o.prototype.argMin=function(g,te){Hh(g,"argMin");var tr=[te];Cn("argMin",tr,g.rank);for(var to=bn(g.shape,tr),tu=to[0],tc=to[1],tl=Gn(tu,"int32"),th=k(tc),td=this.readSync(tl.dataId),tf=this.readSync(g.dataId),tp=0;tp<td.length;++tp){for(var tv=tp*th,tm=tf[tv],tg=0,ty=0;ty<th;++ty){var tx=tf[tv+ty];tx<tm&&(tm=tx,tg=ty)}td[tp]=tg}return tl},o.prototype.argMax=function(g,te){Hh(g,"argMax");var tr=[te];Cn("argMax",tr,g.rank);for(var to=bn(g.shape,tr),tu=to[0],tc=to[1],tl=Gn(tu,"int32"),th=k(tc),td=this.readSync(tl.dataId),tf=this.readSync(g.dataId),tp=0;tp<td.length;++tp){for(var tv=tp*th,tm=tf[tv],tg=0,ty=0;ty<th;++ty){var tx=tf[tv+ty];tx>tm&&(tm=tx,tg=ty)}td[tp]=tg}return tl},o.prototype.cumsum=function(g,te,tr,to){if(Hh(g,"cumsum"),te!==g.rank-1)throw Error("backend.cumsum in CPU expects an inner-most axis="+(g.rank-1)+" but got axis="+te);for(var tu=Dt(g.dtype,"int32"),tc=Gn(g.shape,tu),tl=this.readSync(tc.dataId),th=this.readSync(g.dataId),td=g.shape[g.rank-1],tf=to?function(g,te){return g+td-te-1}:function(g,te){return g+te},tp=0;tp<th.length;tp+=td)for(var tv=0;tv<td;tv++){var tm=tf(tp,tv);if(0===tv)tl[tm]=tr?0:th[tm];else{var tg=tf(tp,tv-1);tl[tm]=tr?th[tg]+tl[tg]:th[tm]+tl[tg]}}return tc},o.prototype.equal=function(g,te){return Hh([g,te],"equal"),this.broadcastedBinaryOp(g,te,"bool",function(g,te){return g===te?1:0})},o.prototype.notEqual=function(g,te){return Hh([g,te],"notEqual"),this.broadcastedBinaryOp(g,te,"bool",function(g,te){return g!==te?1:0})},o.prototype.less=function(g,te){return Hh([g,te],"less"),this.broadcastedBinaryOp(g,te,"bool",function(g,te){return g<te?1:0})},o.prototype.lessEqual=function(g,te){return Hh([g,te],"lessEqual"),this.broadcastedBinaryOp(g,te,"bool",function(g,te){return g<=te?1:0})},o.prototype.greater=function(g,te){return Hh([g,te],"greater"),this.broadcastedBinaryOp(g,te,"bool",function(g,te){return g>te?1:0})},o.prototype.greaterEqual=function(g,te){return Hh([g,te],"greaterEqual"),this.broadcastedBinaryOp(g,te,"bool",function(g,te){return g>=te?1:0})},o.prototype.logicalNot=function(g){Hh(g,"logicalNot");for(var te=this.readSync(g.dataId),tr=new Uint8Array(te.length),to=0;to<te.length;++to)tr[to]=te[to]?0:1;return this.makeOutput(tr,g.shape,"bool")},o.prototype.logicalAnd=function(g,te){return Hh([g,te],"logicalAnd"),this.broadcastedBinaryOp(g,te,"bool",function(g,te){return g&&te})},o.prototype.logicalOr=function(g,te){return Hh([g,te],"logicalOr"),this.broadcastedBinaryOp(g,te,"bool",function(g,te){return g||te})},o.prototype.select=function(g,te,tr){Hh([g,te,tr],"select");for(var to=this.readSync(g.dataId),tu=this.readSync(te.dataId),tc=this.readSync(tr.dataId),tl=Gn(te.shape,Dt(te.dtype,tr.dtype)),th=this.readSync(tl.dataId),td=0,tf=0===g.rank||g.rank>1||1===te.rank?1:k(te.shape.slice(1)),tp=0;tp<to.length;tp++)for(var tv=0;tv<tf;tv++)1===to[tp]?th[td++]=tu[tp]:th[td++]=tc[tp];return tl},o.prototype.where=function(g){Hh([g],"where");var te=this.readSync(g.dataId);return na(g.shape,te)},o.prototype.topk=function(g,te,tr){return Hh(g,"topk"),ea(this.readSync(g.dataId),g.shape,g.dtype,te)},o.prototype.min=function(g,te){Hh(g,"min"),Cn("min",te,g.rank);for(var tr=bn(g.shape,te),to=tr[0],tu=tr[1],tc=Gn(to,g.dtype),tl=k(tu),th=this.readSync(tc.dataId),td=this.readSync(g.dataId),tf=0;tf<th.length;++tf){for(var tp=tf*tl,tv=td[tp],tm=0;tm<tl;++tm){var tg=td[tp+tm];tg<tv&&(tv=tg)}th[tf]=tv}return tc},o.prototype.minimum=function(g,te){return Hh([g,te],"minimum"),this.broadcastedBinaryOp(g,te,g.dtype,function(g,te){return Math.min(g,te)})},o.prototype.mod=function(g,te){return Hh([g,te],"mod"),this.broadcastedBinaryOp(g,te,g.dtype,function(g,te){var tr=g%te;return g<0&&te<0||g>=0&&te>=0?tr:(tr+te)%te})},o.prototype.max=function(g,te){Hh(g,"max"),Cn("max",te,g.rank);for(var tr=bn(g.shape,te),to=tr[0],tu=tr[1],tc=Gn(to,g.dtype),tl=k(tu),th=this.readSync(tc.dataId),td=this.readSync(g.dataId),tf=0;tf<th.length;++tf){for(var tp=tf*tl,tv=td[tp],tm=0;tm<tl;++tm){var tg=td[tp+tm];tg>tv&&(tv=tg)}th[tf]=tv}return tc},o.prototype.maximum=function(g,te){return Hh([g,te],"maximum"),this.broadcastedBinaryOp(g,te,g.dtype,function(g,te){return Math.max(g,te)})},o.prototype.all=function(g,te){Hh(g,"all"),Cn("all",te,g.rank);for(var tr=bn(g.shape,te),to=tr[0],tu=tr[1],tc=Gn(to,g.dtype),tl=k(tu),th=this.readSync(tc.dataId),td=this.readSync(g.dataId),tf=0;tf<th.length;++tf){for(var tp=tf*tl,tv=td[tp],tm=0;tm<tl;++tm){var tg=td[tp+tm];tv=tv&&tg}th[tf]=tv}return tc},o.prototype.any=function(g,te){Hh(g,"any"),Cn("any",te,g.rank);for(var tr=bn(g.shape,te),to=tr[0],tu=tr[1],tc=Gn(to,g.dtype),tl=k(tu),th=this.readSync(tc.dataId),td=this.readSync(g.dataId),tf=0;tf<th.length;++tf){for(var tp=tf*tl,tv=td[tp],tm=0;tm<tl;++tm){var tg=td[tp+tm];tv=tv||tg}th[tf]=tv}return tc},o.prototype.squaredDifference=function(g,te){return Hh([g,te],"squaredDifference"),this.broadcastedBinaryOp(g,te,g.dtype,function(g,te){var tr=g-te;return tr*tr})},o.prototype.ceil=function(g){Hh(g,"ceil");for(var te=this.readSync(g.dataId),tr=new Float32Array(te.length),to=0;to<te.length;++to)tr[to]=Math.ceil(te[to]);return this.makeOutput(tr,g.shape,"float32")},o.prototype.floor=function(g){Hh(g,"floor");for(var te=this.readSync(g.dataId),tr=new Float32Array(te.length),to=0;to<te.length;++to)tr[to]=Math.floor(te[to]);return this.makeOutput(tr,g.shape,"float32")},o.prototype.sign=function(g){Hh(g,"x");for(var te=this.readSync(g.dataId),tr=new Float32Array(te.length),to=0;to<te.length;++to)te[to]<0?tr[to]=-1:te[to]>0?tr[to]=1:tr[to]=0;return this.makeOutput(tr,g.shape,"float32")},o.prototype.isNaN=function(g){Hh(g,"x");for(var te=this.readSync(g.dataId),tr=new Uint8Array(te.length),to=0;to<te.length;++to)Number.isNaN(te[to])&&(tr[to]=1);return this.makeOutput(tr,g.shape,"bool")},o.prototype.isInf=function(g){Hh(g,"x");for(var te=this.readSync(g.dataId),tr=new Uint8Array(te.length),to=0;to<te.length;++to)Math.abs(te[to])===1/0&&(tr[to]=1);return this.makeOutput(tr,g.shape,"bool")},o.prototype.isFinite=function(g){Hh(g,"x");for(var te=this.readSync(g.dataId),tr=new Uint8Array(te.length),to=0;to<te.length;++to)Number.isFinite(te[to])&&(tr[to]=1);return this.makeOutput(tr,g.shape,"bool")},o.prototype.round=function(g){Hh(g,"round");for(var te=this.readSync(g.dataId),tr=new Float32Array(te.length),to=0;to<te.length;++to){var tu=Math.floor(te[to]);te[to]-tu<.5?tr[to]=Math.floor(te[to]):te[to]-tu>.5?tr[to]=Math.ceil(te[to]):tr[to]=tu%2==0?tu:tu+1}return this.makeOutput(tr,g.shape,"float32")},o.prototype.exp=function(g){Hh(g,"exp");for(var te=this.readSync(g.dataId),tr=new Float32Array(te.length),to=0;to<te.length;++to)tr[to]=Math.exp(te[to]);return this.makeOutput(tr,g.shape,"float32")},o.prototype.expm1=function(g){Hh(g,"expm1");for(var te=this.readSync(g.dataId),tr=new Float32Array(te.length),to=0;to<te.length;++to)tr[to]=Math.expm1(te[to]);return this.makeOutput(tr,g.shape,"float32")},o.prototype.log=function(g){Hh(g,"log");for(var te=this.readSync(g.dataId),tr=new Float32Array(te.length),to=0;to<te.length;++to){var tu=te[to];tr[to]=Math.log(tu)}return this.makeOutput(tr,g.shape,"float32")},o.prototype.log1p=function(g){Hh(g,"log1p");for(var te=this.readSync(g.dataId),tr=new Float32Array(te.length),to=0;to<te.length;++to){var tu=te[to];tr[to]=Math.log1p(tu)}return this.makeOutput(tr,g.shape,"float32")},o.prototype.sqrt=function(g){Hh(g,"sqrt");for(var te=this.readSync(g.dataId),tr=new Float32Array(te.length),to=0;to<te.length;++to){var tu=te[to];tr[to]=Math.sqrt(tu)}return this.makeOutput(tr,g.shape,"float32")},o.prototype.rsqrt=function(g){Hh(g,"rsqrt");for(var te=this.readSync(g.dataId),tr=new Float32Array(te.length),to=0;to<te.length;++to){var tu=te[to];tr[to]=1/Math.sqrt(tu)}return this.makeOutput(tr,g.shape,"float32")},o.prototype.reciprocal=function(g){Hh(g,"reciprocal");for(var te=this.readSync(g.dataId),tr=new Float32Array(te.length),to=0;to<te.length;++to)tr[to]=1/te[to];return this.makeOutput(tr,g.shape,"float32")},o.prototype.linear=function(g){return g},o.prototype.relu=function(g){Hh(g,"relu");for(var te=Gn(g.shape,g.dtype),tr=this.readSync(te.dataId),to=this.readSync(g.dataId),tu=0;tu<to.length;++tu)tr[tu]=Math.max(0,to[tu]);return te},o.prototype.relu6=function(g){Hh(g,"relu");for(var te=Gn(g.shape,g.dtype),tr=this.readSync(te.dataId),to=this.readSync(g.dataId),tu=0;tu<to.length;++tu)tr[tu]=Math.min(Math.max(0,to[tu]),6);return te},o.prototype.prelu=function(g,te){return Hh([g,te],"prelu"),this.broadcastedBinaryOp(g,te,g.dtype,function(g,te){return g<0?te*g:g})},o.prototype.elu=function(g){Hh(g,"elu");for(var te=new Float32Array(g.size),tr=this.readSync(g.dataId),to=0;to<tr.length;++to){var tu=tr[to];te[to]=tu>=0?tu:Math.exp(tu)-1}return this.makeOutput(te,g.shape,"float32")},o.prototype.eluDer=function(g,te){Hh([g,te],"eluDer");for(var tr=new Float32Array(te.size),to=this.readSync(te.dataId),tu=this.readSync(g.dataId),tc=0;tc<to.length;++tc){var tl=to[tc];tr[tc]=tl>=1?tu[tc]:tu[tc]*(tl+1)}return this.makeOutput(tr,te.shape,"float32")},o.prototype.selu=function(g){Hh(g,"selu");for(var te=new Float32Array(g.size),tr=this.readSync(g.dataId),to=0;to<tr.length;++to){var tu=tr[to];te[to]=tu>=0?1.0507009873554805*tu:1.7580993408473768*(Math.exp(tu)-1)}return this.makeOutput(te,g.shape,"float32")},o.prototype.clip=function(g,te,tr){Hh(g,"clip");for(var to=new Float32Array(g.size),tu=this.readSync(g.dataId),tc=0;tc<tu.length;++tc){var tl=tu[tc];to[tc]=tl>tr?tr:tl<te?te:tl}return this.makeOutput(to,g.shape,"float32")},o.prototype.abs=function(g){for(var te=new Float32Array(g.size),tr=this.readSync(g.dataId),to=0;to<tr.length;++to)te[to]=Math.abs(tr[to]);return this.makeOutput(te,g.shape,"float32")},o.prototype.complexAbs=function(g){for(var te=new Float32Array(g.size),tr=this.readSync(g.dataId),to=0;to<g.size;++to){var tu=tr[2*to],tc=tr[2*to+1];te[to]=Math.hypot(tu,tc)}return this.makeOutput(te,g.shape,"float32")},o.prototype.int=function(g){Hh(g,"int");for(var te=new Int32Array(g.size),tr=this.readSync(g.dataId),to=0;to<tr.length;++to)te[to]=tr[to];return this.makeOutput(te,g.shape,"int32")},o.prototype.sigmoid=function(g){Hh(g,"sigmoid");for(var te=new Float32Array(g.size),tr=this.readSync(g.dataId),to=0;to<tr.length;++to)te[to]=1/(1+Math.exp(-tr[to]));return this.makeOutput(te,g.shape,"float32")},o.prototype.softplus=function(g){Hh(g,"softplus");for(var te=Math.log(11920928955078125e-23)+2,tr=new Float32Array(g.size),to=this.readSync(g.dataId),tu=0;tu<to.length;++tu){var tc=to[tu]>-te,tl=to[tu]<te,th=Math.exp(to[tu]),td=void 0;td=tl?th:tc?to[tu]:Math.log(1+th),tr[tu]=td}return this.makeOutput(tr,g.shape,"float32")},o.prototype.sin=function(g){Hh(g,"sin");for(var te=new Float32Array(g.size),tr=this.readSync(g.dataId),to=0;to<tr.length;++to)te[to]=Math.sin(tr[to]);return this.makeOutput(te,g.shape,"float32")},o.prototype.cos=function(g){Hh(g,"cos");for(var te=new Float32Array(g.size),tr=this.readSync(g.dataId),to=0;to<tr.length;++to)te[to]=Math.cos(tr[to]);return this.makeOutput(te,g.shape,"float32")},o.prototype.tan=function(g){Hh(g,"tan");for(var te=new Float32Array(g.size),tr=this.readSync(g.dataId),to=0;to<tr.length;++to)te[to]=Math.tan(tr[to]);return this.makeOutput(te,g.shape,"float32")},o.prototype.asin=function(g){Hh(g,"asin");for(var te=new Float32Array(g.size),tr=this.readSync(g.dataId),to=0;to<tr.length;++to)te[to]=Math.asin(tr[to]);return this.makeOutput(te,g.shape,"float32")},o.prototype.acos=function(g){Hh(g,"acos");for(var te=new Float32Array(g.size),tr=this.readSync(g.dataId),to=0;to<tr.length;++to)te[to]=Math.acos(tr[to]);return this.makeOutput(te,g.shape,"float32")},o.prototype.atan=function(g){Hh(g,"atan");for(var te=new Float32Array(g.size),tr=this.readSync(g.dataId),to=0;to<tr.length;++to)te[to]=Math.atan(tr[to]);return this.makeOutput(te,g.shape,"float32")},o.prototype.atan2=function(g,te){return Hh([g,te],"atan2"),this.broadcastedBinaryOp(g,te,g.dtype,function(g,te){return Math.atan2(g,te)})},o.prototype.sinh=function(g){Hh(g,"sinh");for(var te=new Float32Array(g.size),tr=this.readSync(g.dataId),to=0;to<tr.length;++to)te[to]=Math.sinh(tr[to]);return this.makeOutput(te,g.shape,"float32")},o.prototype.cosh=function(g){Hh(g,"cosh");for(var te=new Float32Array(g.size),tr=this.readSync(g.dataId),to=0;to<tr.length;++to)te[to]=Math.cosh(tr[to]);return this.makeOutput(te,g.shape,"float32")},o.prototype.tanh=function(g){Hh(g,"tanh");for(var te=new Float32Array(g.size),tr=this.readSync(g.dataId),to=0;to<tr.length;++to)te[to]=D(tr[to]);return this.makeOutput(te,g.shape,"float32")},o.prototype.asinh=function(g){Hh(g,"asinh");for(var te=new Float32Array(g.size),tr=this.readSync(g.dataId),to=0;to<tr.length;++to)te[to]=Math.asinh(tr[to]);return this.makeOutput(te,g.shape,"float32")},o.prototype.acosh=function(g){Hh(g,"acosh");for(var te=new Float32Array(g.size),tr=this.readSync(g.dataId),to=0;to<tr.length;++to)te[to]=Math.acosh(tr[to]);return this.makeOutput(te,g.shape,"float32")},o.prototype.atanh=function(g){Hh(g,"atanh");for(var te=new Float32Array(g.size),tr=this.readSync(g.dataId),to=0;to<tr.length;++to)te[to]=Math.atanh(tr[to]);return this.makeOutput(te,g.shape,"float32")},o.prototype.erf=function(g){Hh(g,"erf");for(var te=new Float32Array(g.size),tr=this.readSync(g.dataId),to=0;to<tr.length;++to){var tu=Math.sign(tr[to]),tc=Math.abs(tr[to]),tl=1/(1+.3275911*tc);te[to]=tu*(1-((((1.061405429*tl-1.453152027)*tl+1.421413741)*tl-.284496736)*tl+.254829592)*tl*Math.exp(-tc*tc))}return this.makeOutput(te,g.shape,"float32")},o.prototype.step=function(g,te){void 0===te&&(te=0),Hh(g,"step");for(var tr=new Float32Array(g.size),to=this.readSync(g.dataId),tu=0;tu<to.length;++tu){var tc=to[tu];isNaN(tc)?tr[tu]=NaN:tr[tu]=tc>0?1:te}return this.makeOutput(tr,g.shape,"float32")},o.prototype.fusedConv2d=function(g){var te=g.input,tr=g.filter,to=g.convInfo,tu=g.bias,tc=g.activation,tl=g.preluActivationWeights,th=this.conv2d(te,tr,to);return tu&&(th=this.add(th,tu)),tc&&(th=qh(this,th,tc,tl)),th},o.prototype.conv2d=function(g,te,tr){Hh([g,te],"conv2d");for(var to=tr.filterHeight,tu=tr.filterWidth,tc=tr.dilationHeight,tl=tr.dilationWidth,th=tr.padInfo.left,td=tr.padInfo.top,tf="channelsLast"===tr.dataFormat,tp=dr(tr.outShape,g.dtype),tv=g.strides[0],tm=tf?g.strides[1]:g.strides[2],tg=tf?g.strides[2]:1,ty=tf?1:g.strides[1],tx=tp.strides[0],tb=tf?tp.strides[1]:tp.strides[2],tC=tf?tp.strides[2]:1,tw=tf?1:tp.strides[1],tE=this.readSync(g.dataId),tR=this.readSync(te.dataId),tI=tp.values,tk=0;tk<tr.batchSize;++tk)for(var tA=tk*tv,tS=tk*tx,tD=0;tD<tr.outHeight;++tD)for(var tN=tS+tD*tb,tT=tD*tr.strideHeight-td,tF=0;tF<to;tF++){var tO=tT+tF*tc;if(!(tO<0||tO>=tr.inHeight))for(var t_=tF*te.strides[0],tM=tA+tO*tm,tB=0;tB<tr.outWidth;++tB)for(var tP=tN+tB*tC,tL=tB*tr.strideWidth-th,tW=0;tW<tu;tW++){var tV=tL+tW*tl;if(!(tV<0||tV>=tr.inWidth))for(var tU=tM+tV*tg,tz=t_+tW*te.strides[1],tH=0;tH<tr.inChannels;++tH){for(var tG=tE[tU+tH*ty],tq=0;tq<tr.outChannels;++tq)tI[tP+tq*tw]+=tG*tR[tz+tq];tz+=tr.outChannels}}}return tp.toTensor()},o.prototype.conv3d=function(g,te,tr){for(var to=tr.filterDepth,tu=tr.filterHeight,tc=tr.filterWidth,tl=tr.dilationDepth,th=tr.dilationHeight,td=tr.dilationWidth,tf=tr.padInfo.front,tp=tr.padInfo.left,tv=tr.padInfo.top,tm=dr(tr.outShape,g.dtype),tg=this.readSync(g.dataId),ty=this.readSync(te.dataId),tx=tm.values,tb=0;tb<tr.batchSize;++tb)for(var tC=tb*g.strides[0],tw=tb*tm.strides[0],tE=0;tE<tr.outDepth;++tE)for(var tR=tw+tE*tm.strides[1],tI=tE*tr.strideDepth-tf,tk=0;tk<to;tk++){var tA=tI+tk*tl;if(!(tA<0||tA>=tr.inDepth))for(var tS=tk*te.strides[0],tD=tC+tA*g.strides[1],tN=0;tN<tr.outHeight;++tN)for(var tT=tR+tN*tm.strides[2],tF=tN*tr.strideHeight-tv,tO=0;tO<tu;tO++){var t_=tF+tO*th;if(!(t_<0||t_>=tr.inHeight))for(var tM=tS+tO*te.strides[1],tB=tD+t_*g.strides[2],tP=0;tP<tr.outWidth;++tP)for(var tL=tT+tP*tr.outChannels,tW=tP*tr.strideWidth-tp,tV=0;tV<tc;tV++){var tU=tW+tV*td;if(!(tU<0||tU>=tr.inWidth))for(var tz=tM+tV*te.strides[2],tH=tB+tU*tr.inChannels,tG=tz,tq=0;tq<tr.inChannels;++tq){for(var tK=tg[tH+tq],tj=0;tj<tr.outChannels;++tj)tx[tL+tj]+=tK*ty[tG+tj];tG+=tr.outChannels}}}}return tm.toTensor()},o.prototype.conv2dDerInput=function(g,te,tr){Hh([g,te],"conv2dDerInput");for(var to=dr(tr.inShape,"float32"),tu=to.values,tc=this.readSync(g.dataId),tl=this.readSync(te.dataId),th=te.strides,td=th[0],tf=th[1],tp=th[2],tv=tr.batchSize,tm=tr.filterHeight,tg=tr.filterWidth,ty=tr.inChannels,tx=tr.inHeight,tb=tr.inWidth,tC=tr.outChannels,tw=tr.outHeight,tE=tr.outWidth,tR=tr.strideHeight,tI=tr.strideWidth,tk=tr.dataFormat,tA=tm-1-tr.padInfo.top,tS=tg-1-tr.padInfo.left,tD="channelsLast"===tk,tN=to.strides[0],tT=tD?to.strides[1]:to.strides[2],tF=tD?to.strides[2]:1,tO=tD?1:to.strides[1],t_=g.strides[0],tM=tD?g.strides[1]:g.strides[2],tB=tD?g.strides[2]:1,tP=tD?1:g.strides[1],tL=0;tL<tv;++tL)for(var tW=0;tW<ty;++tW)for(var tV=0;tV<tx;++tV)for(var tU=tV-tA,tz=Math.max(0,Math.ceil(tU/tR)),tH=Math.min(tw,(tm+tU)/tR),tG=0;tG<tb;++tG){for(var tq=tG-tS,tK=Math.max(0,Math.ceil(tq/tI)),tj=Math.min(tE,(tg+tq)/tI),tX=0,t$=tz;t$<tH;++t$)for(var tY=t$*tR-tU,tJ=tK;tJ<tj;++tJ)for(var tQ=t_*tL+tM*t$+tB*tJ,tZ=td*(tm-1-tY)+tf*(tg-1-(tJ*tI-tq))+tp*tW,t0=0;t0<tC;++t0)tX+=tc[tQ+tP*t0]*tl[tZ+t0];tu[tN*tL+tT*tV+tF*tG+tO*tW]=tX}return to.toTensor()},o.prototype.conv3dDerInput=function(g,te,tr){for(var to=dr(tr.inShape,"float32"),tu=to.values,tc=to.strides,tl=tc[0],th=tc[1],td=tc[2],tf=tc[3],tp=this.readSync(g.dataId),tv=g.strides,tm=tv[0],tg=tv[1],ty=tv[2],tx=tv[3],tb=this.readSync(te.dataId),tC=te.strides,tw=tC[0],tE=tC[1],tR=tC[2],tI=tC[3],tk=tr.batchSize,tA=tr.filterDepth,tS=tr.filterHeight,tD=tr.filterWidth,tN=tr.inChannels,tT=tr.inDepth,tF=tr.inHeight,tO=tr.inWidth,t_=tr.outChannels,tM=tr.outDepth,tB=tr.outHeight,tP=tr.outWidth,tL=tr.strideDepth,tW=tr.strideHeight,tV=tr.strideWidth,tU=tA-1-tr.padInfo.front,tz=tS-1-tr.padInfo.top,tH=tD-1-tr.padInfo.left,tG=0;tG<tk;++tG)for(var tq=0;tq<tN;++tq)for(var tK=0;tK<tT;++tK)for(var tj=tK-tU,tX=Math.max(0,Math.ceil(tj/tL)),t$=Math.min(tM,(tA+tj)/tL),tY=0;tY<tF;++tY)for(var tJ=tY-tz,tQ=Math.max(0,Math.ceil(tJ/tW)),tZ=Math.min(tB,(tS+tJ)/tW),t0=0;t0<tO;++t0){for(var t1=t0-tH,t2=Math.max(0,Math.ceil(t1/tV)),t3=Math.min(tP,(tD+t1)/tV),t4=0,t5=tX;t5<t$;++t5)for(var t6=t5*tL-tj,t8=tQ;t8<tZ;++t8)for(var t7=t8*tW-tJ,t9=t2;t9<t3;++t9)for(var nn=tm*tG+tg*t5+ty*t8+tx*t9,nr=tw*(tA-1-t6)+tE*(tS-1-t7)+tR*(tD-1-(t9*tV-t1))+tI*tq,nu=0;nu<t_;++nu)t4+=tp[nn+nu]*tb[nr+nu];tu[tl*tG+th*tK+td*tY+tf*t0+tq]=t4}return to.toTensor()},o.prototype.conv2dDerFilter=function(g,te,tr){Hh([g,te],"conv2dDerFilter");for(var to=tr.strideHeight,tu=tr.strideWidth,tc=tr.filterHeight,tl=tr.filterWidth,th="channelsLast"===tr.dataFormat,td=dr(tr.filterShape,"float32"),tf=tr.padInfo.left,tp=tr.padInfo.top,tv=this.bufferSync(g),tm=this.bufferSync(te),tg=0;tg<tc;++tg)for(var ty=Math.max(0,Math.ceil((tp-tg)/to)),tx=Math.min(tr.outHeight,(tr.inHeight+tp-tg)/to),tb=0;tb<tl;++tb)for(var tC=Math.max(0,Math.ceil((tf-tb)/tu)),tw=Math.min(tr.outWidth,(tr.inWidth+tf-tb)/tu),tE=0;tE<tr.inChannels;++tE)for(var tR=0;tR<tr.outChannels;++tR){for(var tI=0,tk=0;tk<tr.batchSize;++tk)for(var tA=ty;tA<tx;++tA)for(var tS=tg+tA*to-tp,tD=tC;tD<tw;++tD){var tN=tb+tD*tu-tf;tI+=th?tv.get(tk,tS,tN,tE)*tm.get(tk,tA,tD,tR):tv.get(tk,tE,tS,tN)*tm.get(tk,tR,tA,tD)}td.set(tI,tg,tb,tE,tR)}return td.toTensor()},o.prototype.conv3dDerFilter=function(g,te,tr){for(var to=tr.strideDepth,tu=tr.strideHeight,tc=tr.strideWidth,tl=tr.filterDepth,th=tr.filterHeight,td=tr.filterWidth,tf=dr(tr.filterShape,"float32"),tp=tf.values,tv=tf.strides,tm=tv[0],tg=tv[1],ty=tv[2],tx=tv[3],tb=this.readSync(te.dataId),tC=te.strides,tw=tC[0],tE=tC[1],tR=tC[2],tI=tC[3],tk=this.readSync(g.dataId),tA=g.strides,tS=tA[0],tD=tA[1],tN=tA[2],tT=tA[3],tF=tr.padInfo.front,tO=tr.padInfo.left,t_=tr.padInfo.top,tM=0;tM<tl;++tM)for(var tB=Math.max(0,Math.ceil((tF-tM)/to)),tP=Math.min(tr.outDepth,(tr.inDepth+tF-tM)/to),tL=tM*tm,tW=0;tW<th;++tW)for(var tV=Math.max(0,Math.ceil((t_-tW)/tu)),tU=Math.min(tr.outHeight,(tr.inHeight+t_-tW)/tu),tz=tW*tg+tL,tH=0;tH<td;++tH)for(var tG=Math.max(0,Math.ceil((tO-tH)/tc)),tq=Math.min(tr.outWidth,(tr.inWidth+tO-tH)/tc),tK=tH*ty+tz,tj=0;tj<tr.inChannels;++tj)for(var tX=tj*tx+tK,t$=0;t$<tr.outChannels;++t$){for(var tY=0,tJ=0;tJ<tr.batchSize;++tJ)for(var tQ=tJ*tS,tZ=tJ*tw,t0=tB;t0<tP;++t0)for(var t1=(tM+t0*to-tF)*tD+tQ,t2=t0*tE+tZ,t3=tV;t3<tU;++t3)for(var t4=(tW+t3*tu-t_)*tN+t1,t5=t3*tR+t2,t6=tG;t6<tq;++t6){var t8=t6*tI+t5;tY+=tk[(tH+t6*tc-tO)*tT+t4+tj]*tb[t8+t$]}tp[tX+t$]=tY}return tf.toTensor()},o.prototype.fusedDepthwiseConv2D=function(g){var te=g.input,tr=g.filter,to=g.convInfo,tu=g.bias,tc=g.activation,tl=g.preluActivationWeights,th=this.depthwiseConv2D(te,tr,to);return tu&&(th=this.add(th,tu)),tc&&(th=qh(this,th,tc,tl)),th},o.prototype.depthwiseConv2D=function(g,te,tr){Hh([g,te],"depthwiseConv2D");for(var to=tr.filterHeight,tu=tr.filterWidth,tc=tr.dilationHeight,tl=tr.dilationWidth,th=tr.padInfo.left,td=tr.padInfo.top,tf=tr.outChannels/tr.inChannels,tp=dr(tr.outShape,g.dtype),tv=this.readSync(g.dataId),tm=this.readSync(te.dataId),tg=tp.values,ty=0;ty<tr.batchSize;++ty)for(var tx=ty*g.strides[0],tb=ty*tp.strides[0],tC=0;tC<tr.outHeight;++tC)for(var tw=tb+tC*tp.strides[1],tE=tC*tr.strideHeight-th,tR=0;tR<to;++tR){var tI=tE+tR*tc;if(!(tI<0||tI>=tr.inHeight))for(var tk=tR*te.strides[0],tA=tx+tI*g.strides[1],tS=0;tS<tr.outWidth;++tS)for(var tD=tw+tS*tp.strides[2],tN=tS*tr.strideWidth-td,tT=0;tT<tu;++tT){var tF=tN+tT*tl;if(!(tF<0||tF>=tr.inWidth))for(var tO=tk+tT*te.strides[1],t_=tA+tF*tr.inChannels,tM=tD,tB=tO,tP=0;tP<tr.inChannels;++tP){for(var tL=tv[t_+tP],tW=0;tW<tf;++tW)tg[tM+tW]+=tL*tm[tB+tW];tM+=tf,tB+=tf}}}return tp.toTensor()},o.prototype.depthwiseConv2DDerInput=function(g,te,tr){Hh([g,te],"depthwiseConv2DDerInput");for(var to=dr(tr.inShape,"float32"),tu=to.values,tc=to.strides,tl=tc[0],th=tc[1],td=tc[2],tf=this.readSync(g.dataId),tp=g.strides,tv=tp[0],tm=tp[1],tg=tp[2],ty=this.readSync(te.dataId),tx=te.strides,tb=tx[0],tC=tx[1],tw=tx[2],tE=tr.batchSize,tR=tr.filterHeight,tI=tr.filterWidth,tk=tr.inChannels,tA=tr.inHeight,tS=tr.inWidth,tD=tr.outChannels,tN=tr.outHeight,tT=tr.outWidth,tF=tr.strideHeight,tO=tr.strideWidth,t_=tR-1-tr.padInfo.top,tM=tI-1-tr.padInfo.left,tB=tD/tk,tP=0;tP<tE;++tP)for(var tL=0;tL<tk;++tL)for(var tW=0;tW<tA;++tW)for(var tV=tW-t_,tU=Math.max(0,Math.ceil(tV/tF)),tz=Math.min(tN,(tR+tV)/tF),tH=0;tH<tS;++tH){for(var tG=tH-tM,tq=Math.max(0,Math.ceil(tG/tO)),tK=Math.min(tT,(tI+tG)/tO),tj=0,tX=tU;tX<tz;++tX)for(var t$=tX*tF-tV,tY=tq;tY<tK;++tY)for(var tJ=tv*tP+tm*tX+tg*tY,tQ=tb*(tR-1-t$)+tC*(tI-1-(tY*tO-tG))+tw*tL,tZ=0;tZ<tB;++tZ)tj+=tf[tJ+(tL*tB+tZ)]*ty[tQ+tZ];tu[tl*tP+th*tW+td*tH+tL]=tj}return to.toTensor()},o.prototype.depthwiseConv2DDerFilter=function(g,te,tr){Hh([g,te],"depthwiseConv2DDerFilter");for(var to=tr.strideHeight,tu=tr.strideWidth,tc=tr.filterHeight,tl=tr.filterWidth,th=dr(tr.filterShape,"float32"),td=tr.padInfo.left,tf=tr.padInfo.top,tp=tr.outChannels/tr.inChannels,tv=this.bufferSync(g),tm=this.bufferSync(te),tg=0;tg<tc;++tg)for(var ty=Math.max(0,Math.ceil((tf-tg)/to)),tx=Math.min(tr.outHeight,(tr.inHeight+tf-tg)/to),tb=0;tb<tl;++tb)for(var tC=Math.max(0,Math.ceil((td-tb)/tu)),tw=Math.min(tr.outWidth,(tr.inWidth+td-tb)/tu),tE=0;tE<tr.outChannels;++tE){for(var tR=Math.trunc(tE/tp),tI=tE%tp,tk=0,tA=0;tA<tr.batchSize;++tA)for(var tS=ty;tS<tx;++tS)for(var tD=tg+tS*to-tf,tN=tC;tN<tw;++tN){var tT=tb+tN*tu-td;tk+=tv.get(tA,tD,tT,tR)*tm.get(tA,tS,tN,tE)}th.set(tk,tg,tb,tR,tI)}return th.toTensor()},o.prototype.tile=function(g,te){return Hh(g,"tile"),ta(this.bufferSync(g),te)},o.prototype.pad=function(g,te,tr){Hh(g,"pad");var to=te.map(function(te,tr){return te[0]+g.shape[tr]+te[1]}),tu=te.map(function(g){return g[0]}),tc=this.bufferSync(g),tl=dr(to,g.dtype);0!==tr&&tl.values.fill(tr);for(var th=0;th<g.size;th++){var td=tc.indexToLoc(th),tf=td.map(function(g,te){return g+tu[te]});tl.set.apply(tl,[tc.get.apply(tc,td)].concat(tf))}return tl.toTensor()},o.prototype.transpose=function(g,te){Hh(g,"transpose");for(var tr=Array(g.rank),to=0;to<tr.length;to++)tr[to]=g.shape[te[to]];var tu=this.readSync(g.dataId),tc=dr(tr,g.dtype),tl=this.bufferSync(g);for(to=0;to<g.size;++to){for(var th=tl.indexToLoc(to),td=Array(th.length),tf=0;tf<td.length;tf++)td[tf]=th[te[tf]];var tp=tc.locToIndex(td);tc.values[tp]=tu[to]}return tc.toTensor()},o.prototype.gather=function(g,te,tr){Hh([g,te],"gather");var to=g.shape.slice(),tu=this.readSync(te.dataId);to[tr]=tu.length;for(var tc=dr(to,g.dtype),tl=this.bufferSync(g),th=0;th<tc.size;++th){var td=tc.indexToLoc(th),tf=td.slice();tf[tr]=tu[td[tr]];var tp=tl.locToIndex(tf);tc.values[th]=tl.values[tp]}return tc.toTensor()},o.prototype.batchToSpaceND=function(g,te,tr){Hh([g],"batchToSpaceND");var to=te.reduce(function(g,te){return g*te}),tu=zr(g.shape,te,to),tc=Gr(tu.length,te.length),tl=Hr(g.shape,te,to),th=qr(tr,te.length),td=Kr(tl,tr,te.length);return g.reshape(tu).transpose(tc).reshape(tl).slice(th,td)},o.prototype.spaceToBatchND=function(g,te,tr){Hh([g],"spaceToBatchND");var to=te.reduce(function(g,te){return g*te}),tu=[[0,0]];tu.push.apply(tu,tr);for(var tc=1+te.length;tc<g.shape.length;++tc)tu.push([0,0]);var tl=g.pad(tu),th=zr(tl.shape,te,to,!1),td=Gr(th.length,te.length,!1),tf=Hr(tl.shape,te,to,!1);return tl.reshape(th).transpose(td).reshape(tf)},o.prototype.pool=function(g,te,tr){Hh(g,"pool");for(var to=te.strideHeight,tu=te.strideWidth,tc=te.dilationHeight,tl=te.dilationWidth,th=te.effectiveFilterHeight,td=te.effectiveFilterWidth,tf=te.padInfo.top,tp=te.padInfo.left,tv="max"===tr?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,tm=this.readSync(g.dataId),tg=dr(te.outShape,g.dtype),ty=tg.values,tx=te.outShape[1]*te.outShape[2]*te.outShape[3],tb=te.outShape[2]*te.outShape[3],tC=te.outShape[3],tw=0;tw<te.batchSize;++tw)for(var tE=tw*tx,tR=tw*g.strides[0],tI=0;tI<te.inChannels;++tI)for(var tk=0;tk<te.outHeight;++tk)for(var tA=tk*to-tf,tS=Math.max(0,tA),tD=Math.min(te.inHeight,th+tA),tN=tE+tk*tb,tT=0;tT<te.outWidth;++tT){for(var tF=tT*tu-tp,tO=Math.max(0,tF),t_=Math.min(te.inWidth,td+tF),tM=tv,tB=0,tP=0,tL=tS;tL<tD;tL+=tc){for(var tW=tR+tL*g.strides[1],tV=tO;tV<t_;tV+=tl){var tU=tm[tW+tV*g.strides[2]+tI];"max"===tr&&tU>tM?tM=tU:"avg"===tr&&(tB+=tU,tP++)}if(isNaN(tM))break}ty[tN+tT*tC+tI]="avg"===tr?tB/tP:tM}return tg.toTensor()},o.prototype.maxPool=function(g,te){return this.pool(g,te,"max")},o.prototype.maxPoolPositions=function(g,te){for(var tr=dr(te.outShape,"int32"),to=te.strideHeight,tu=te.strideWidth,tc=te.dilationHeight,tl=te.dilationWidth,th=te.effectiveFilterHeight,td=te.effectiveFilterWidth,tf=te.padInfo.top,tp=te.padInfo.left,tv=this.bufferSync(g),tm=0;tm<te.batchSize;++tm)for(var tg=0;tg<te.inChannels;++tg)for(var ty=0;ty<te.outHeight;++ty){for(var tx=ty*to-tf,tb=tx;tb<0;)tb+=tc;for(var tC=Math.min(te.inHeight,th+tx),tw=0;tw<te.outWidth;++tw){for(var tE=tw*tu-tp,tR=tE;tR<0;)tR+=tl;for(var tI=Math.min(te.inWidth,td+tE),tk=Number.NEGATIVE_INFINITY,tA=-1,tS=tb;tS<tC;tS+=tc)for(var tD=tS-tx,tN=tR;tN<tI;tN+=tl){var tT=tN-tE,tF=tv.get(tm,tS,tN,tg);tF>tk&&(tk=tF,tA=tD*td+tT)}tr.set(tA,tm,ty,tw,tg)}}return tr.toTensor()},o.prototype.maxPoolBackprop=function(g,te,tr,to){Hh([te,tr],"maxPoolBackprop");for(var tu=this.maxPoolPositions(te,to),tc=to.strideHeight,tl=to.strideWidth,th=to.dilationHeight,td=to.dilationWidth,tf=to.effectiveFilterHeight,tp=to.effectiveFilterWidth,tv=tp-1-to.padInfo.left,tm=tf-1-to.padInfo.top,tg=dr(te.shape,"float32"),ty=this.bufferSync(tu),tx=this.bufferSync(g),tb=0;tb<to.batchSize;++tb)for(var tC=0;tC<to.inChannels;++tC)for(var tw=0;tw<to.inHeight;++tw)for(var tE=0;tE<to.inWidth;++tE){for(var tR=tw-tm,tI=tE-tv,tk=0,tA=0;tA<tf;tA+=th){var tS=(tR+tA)/tc;if(!(tS<0||tS>=to.outHeight||Math.floor(tS)!==tS))for(var tD=0;tD<tp;tD+=td){var tN=(tI+tD)/tl;if(!(tN<0||tN>=to.outWidth||Math.floor(tN)!==tN)){var tT=tf*tp-1-ty.get(tb,tS,tN,tC)===tA*tp+tD?1:0;0!==tT&&(tk+=tx.get(tb,tS,tN,tC)*tT)}}}tg.set(tk,tb,tw,tE,tC)}return tg.toTensor()},o.prototype.avgPoolBackprop=function(g,te,tr){Hh([g,te],"avgPoolBackprop");for(var to=tr.strideHeight,tu=tr.strideWidth,tc=tr.filterHeight,tl=tr.filterWidth,th=tr.dilationHeight,td=tr.dilationWidth,tf=tr.effectiveFilterHeight,tp=tr.effectiveFilterWidth,tv=tp-1-tr.padInfo.left,tm=tf-1-tr.padInfo.top,tg=dr(te.shape,"float32"),ty=1/(tc*tl),tx=this.bufferSync(g),tb=0;tb<tr.batchSize;++tb)for(var tC=0;tC<tr.inChannels;++tC)for(var tw=0;tw<tr.inHeight;++tw)for(var tE=0;tE<tr.inWidth;++tE){for(var tR=tw-tm,tI=tE-tv,tk=0,tA=0;tA<tf;tA+=th){var tS=(tR+tA)/to;if(!(tS<0||tS>=tr.outHeight||Math.floor(tS)!==tS))for(var tD=0;tD<tp;tD+=td){var tN=(tI+tD)/tu;tN<0||tN>=tr.outWidth||Math.floor(tN)!==tN||(tk+=tx.get(tb,tS,tN,tC))}}tg.set(tk*ty,tb,tw,tE,tC)}return tg.toTensor()},o.prototype.pool3d=function(g,te,tr){Hh(g,"pool3d");for(var to=te.strideDepth,tu=te.strideHeight,tc=te.strideWidth,tl=te.dilationDepth,th=te.dilationHeight,td=te.dilationWidth,tf=te.effectiveFilterDepth,tp=te.effectiveFilterHeight,tv=te.effectiveFilterWidth,tm=te.padInfo.front,tg=te.padInfo.top,ty=te.padInfo.left,tx="max"===tr?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,tb=this.readSync(g.dataId),tC=dr(te.outShape,g.dtype),tw=tC.values,tE=te.outShape[1]*te.outShape[2]*te.outShape[3]*te.outShape[4],tR=te.outShape[2]*te.outShape[3]*te.outShape[4],tI=te.outShape[3]*te.outShape[4],tk=te.outShape[4],tA=0;tA<te.batchSize;++tA)for(var tS=tA*tE,tD=tA*g.strides[0],tN=0;tN<te.inChannels;++tN)for(var tT=0;tT<te.outDepth;++tT){for(var tF=tT*to-tm,tO=tF;tO<0;)tO+=tl;for(var t_=Math.min(te.inDepth,tf+tF),tM=tS+tT*tR,tB=0;tB<te.outHeight;++tB){for(var tP=tB*tu-tg,tL=tP;tL<0;)tL+=th;for(var tW=Math.min(te.inHeight,tp+tP),tV=tM+tB*tI,tU=0;tU<te.outWidth;++tU){for(var tz=tU*tc-ty,tH=tz;tH<0;)tH+=td;for(var tG=Math.min(te.inWidth,tv+tz),tq=tV+tU*tk,tK=tx,tj=0,tX=0,t$=tO;t$<t_;t$+=tl){for(var tY=tD+t$*g.strides[1],tJ=tL;tJ<tW;tJ+=th){for(var tQ=tY+tJ*g.strides[2],tZ=tH;tZ<tG;tZ+=td){var t0=tb[tQ+tZ*g.strides[3]+tN];if("max"===tr&&t0>tK?tK=t0:"avg"===tr&&(tj+=t0,tX++),isNaN(tK))break}if(isNaN(tK))break}if(isNaN(tK))break}tw[tq+tN]="avg"===tr?tj/tX:tK}}}return tC.toTensor()},o.prototype.avgPool3d=function(g,te){return Hh(g,"avgPool3d"),this.pool3d(g,te,"avg").toFloat()},o.prototype.avgPool3dBackprop=function(g,te,tr){Hh([g,te],"avgPool3dBackprop");for(var to=tr.strideDepth,tu=tr.strideHeight,tc=tr.strideWidth,tl=tr.filterDepth,th=tr.filterHeight,td=tr.filterWidth,tf=tr.dilationDepth,tp=tr.dilationHeight,tv=tr.dilationWidth,tm=tr.effectiveFilterDepth,tg=tr.effectiveFilterHeight,ty=tr.effectiveFilterWidth,tx=tm-1-tr.padInfo.front,tb=ty-1-tr.padInfo.left,tC=tg-1-tr.padInfo.top,tw=dr(te.shape,"float32"),tE=1/(tl*th*td),tR=this.bufferSync(g),tI=0;tI<tr.batchSize;++tI)for(var tk=0;tk<tr.inChannels;++tk)for(var tA=0;tA<tr.inDepth;++tA)for(var tS=0;tS<tr.inHeight;++tS)for(var tD=0;tD<tr.inWidth;++tD){for(var tN=tA-tx,tT=tS-tC,tF=tD-tb,tO=0,t_=0;t_<tm;t_+=tf){var tM=(tN+t_)/to;if(!(tM<0||tM>=tr.outDepth||Math.floor(tM)!==tM))for(var tB=0;tB<tg;tB+=tp){var tP=(tT+tB)/tu;if(!(tP<0||tP>=tr.outHeight||Math.floor(tP)!==tP))for(var tL=0;tL<ty;tL+=tv){var tW=(tF+tL)/tc;tW<0||tW>=tr.outWidth||Math.floor(tW)!==tW||(tO+=tR.get(tI,tM,tP,tW,tk))}}}tw.set(tO*tE,tI,tA,tS,tD,tk)}return tw.toTensor()},o.prototype.maxPool3d=function(g,te){return Hh(g,"maxPool3d"),this.pool3d(g,te,"max").toFloat()},o.prototype.maxPool3dPositions=function(g,te){for(var tr=dr(te.outShape,"int32"),to=te.strideDepth,tu=te.strideHeight,tc=te.strideWidth,tl=te.dilationDepth,th=te.dilationHeight,td=te.dilationWidth,tf=te.effectiveFilterDepth,tp=te.effectiveFilterHeight,tv=te.effectiveFilterWidth,tm=te.padInfo.front,tg=te.padInfo.top,ty=te.padInfo.left,tx=this.bufferSync(g),tb=0;tb<te.batchSize;++tb)for(var tC=0;tC<te.inChannels;++tC)for(var tw=0;tw<te.outDepth;++tw){for(var tE=tw*to-tm,tR=tE;tR<0;)tR+=tl;for(var tI=Math.min(te.inDepth,tf+tE),tk=0;tk<te.outHeight;++tk){for(var tA=tk*tu-tg,tS=tA;tS<0;)tS+=th;for(var tD=Math.min(te.inHeight,tp+tA),tN=0;tN<te.outWidth;++tN){for(var tT=tN*tc-ty,tF=tT;tF<0;)tF+=td;for(var tO=Math.min(te.inWidth,tv+tT),t_=Number.NEGATIVE_INFINITY,tM=-1,tB=tR;tB<tI;tB+=tl)for(var tP=tB-tE,tL=tS;tL<tD;tL+=th)for(var tW=tL-tA,tV=tF;tV<tO;tV+=td){var tU=tV-tT,tz=tx.get(tb,tB,tL,tV,tC);tz>=t_&&(t_=tz,tM=tP*tp*tv+tW*tp+tU)}tr.set(tM,tb,tw,tk,tN,tC)}}}return tr.toTensor()},o.prototype.maxPool3dBackprop=function(g,te,tr,to){Hh([te,tr],"maxPool3dBackprop");for(var tu=this.maxPool3dPositions(te,to),tc=to.strideDepth,tl=to.strideHeight,th=to.strideWidth,td=to.dilationDepth,tf=to.dilationHeight,tp=to.dilationWidth,tv=to.effectiveFilterDepth,tm=to.effectiveFilterHeight,tg=to.effectiveFilterWidth,ty=tv-1-to.padInfo.front,tx=tg-1-to.padInfo.left,tb=tm-1-to.padInfo.top,tC=dr(te.shape,"float32"),tw=this.bufferSync(tu),tE=this.bufferSync(g),tR=0;tR<to.batchSize;++tR)for(var tI=0;tI<to.inChannels;++tI)for(var tk=0;tk<to.inDepth;++tk)for(var tA=0;tA<to.inHeight;++tA)for(var tS=0;tS<to.inWidth;++tS){for(var tD=tk-ty,tN=tA-tb,tT=tS-tx,tF=0,tO=0;tO<tv;tO+=td){var t_=(tD+tO)/tc;if(!(t_<0||t_>=to.outDepth||Math.floor(t_)!==t_))for(var tM=0;tM<tm;tM+=tf){var tB=(tN+tM)/tl;if(!(tB<0||tB>=to.outHeight||Math.floor(tB)!==tB))for(var tP=0;tP<tg;tP+=tp){var tL=(tT+tP)/th;if(!(tL<0||tL>=to.outWidth||Math.floor(tL)!==tL)){var tW=tv*tm*tg-1-tw.get(tR,t_,tB,tL,tI)===tO*tm*tg+tM*tg+tP?1:0;0!==tW&&(tF+=tE.get(tR,t_,tB,tL,tI)*tW)}}}}tC.set(tF,tR,tk,tA,tS,tI)}return tC.toTensor()},o.prototype.cast=function(g,te){return Po(g,te,this)},o.prototype.reshape=function(g,te){return Lo(g,te)},o.prototype.avgPool=function(g,te){return Hh(g,"avgPool"),this.pool(g,te,"avg").toFloat()},o.prototype.resizeBilinear=function(g,te,tr,to){Hh(g,"resizeBilinear");for(var tu=g.shape,tc=tu[0],tl=tu[1],th=tu[2],td=tu[3],tf=this.readSync(g.dataId),tp=new Float32Array(k([tc,te,tr,td])),tv=[to&&te>1?tl-1:tl,to&&tr>1?th-1:th],tm=[to&&te>1?te-1:te,to&&tr>1?tr-1:tr],tg=0,ty=tv[0]/tm[0],tx=tv[1]/tm[1],tb=0;tb<tc;tb++)for(var tC=0;tC<te;tC++)for(var tw=ty*tC,tE=Math.floor(tw),tR=tw-tE,tI=Math.min(tl-1,Math.ceil(tw)),tk=tb*g.strides[0]+tE*g.strides[1],tA=tb*g.strides[0]+tI*g.strides[1],tS=0;tS<tr;tS++)for(var tD=tx*tS,tN=Math.floor(tD),tT=tD-tN,tF=Math.min(th-1,Math.ceil(tD)),tO=tk+tN*g.strides[2],t_=tA+tN*g.strides[2],tM=tk+tF*g.strides[2],tB=tA+tF*g.strides[2],tP=0;tP<td;tP++){var tL=tf[tO+tP],tW=tf[t_+tP],tV=tL+(tf[tM+tP]-tL)*tT,tU=tV+(tW+(tf[tB+tP]-tW)*tT-tV)*tR;tp[tg++]=tU}return Fn(tp,[tc,te,tr,td])},o.prototype.resizeBilinearBackprop=function(g,te,tr){Hh([g,te],"resizeBilinearBackprop");for(var to=te.shape,tu=to[0],tc=to[1],tl=to[2],th=to[3],td=g.shape,tf=td[1],tp=td[2],tv=new Float32Array(tu*tc*tl*th),tm=[tr&&tf>1?tc-1:tc,tr&&tp>1?tl-1:tl],tg=[tr&&tf>1?tf-1:tf,tr&&tp>1?tp-1:tp],ty=tm[0]/tg[0],tx=tm[1]/tg[1],tb=this.readSync(g.dataId),tC=0,tw=0;tw<tu;tw++)for(var tE=tw*te.strides[0],tR=0;tR<tf;tR++)for(var tI=tR*ty,tk=Math.floor(tI),tA=Math.min(Math.ceil(tI),tc-1),tS=tE+tk*te.strides[1],tD=tE+tA*te.strides[1],tN=tI-tk,tT=1-tN,tF=0;tF<tp;tF++)for(var tO=tF*tx,t_=Math.floor(tO),tM=Math.min(Math.ceil(tO),tl-1),tB=tO-t_,tP=1-tB,tL=tS+t_*te.strides[2],tW=tS+tM*te.strides[2],tV=tD+t_*te.strides[2],tU=tD+tM*te.strides[2],tz=tT*tP,tH=tT*tB,tG=tN*tP,tq=tN*tB,tK=0;tK<th;tK++){var tj=tb[tC++];tv[tL+tK]+=tj*tz,tv[tW+tK]+=tj*tH,tv[tV+tK]+=tj*tG,tv[tU+tK]+=tj*tq}return Ln(tv,[tu,tl,tc,th],te.dtype)},o.prototype.resizeNearestNeighbor=function(g,te,tr,to){Hh(g,"resizeNearestNeighbor");for(var tu=g.shape,tc=tu[0],tl=tu[1],th=tu[2],td=tu[3],tf=this.readSync(g.dataId),tp=new Float32Array(tc*te*tr*td),tv=[to&&te>1?tl-1:tl,to&&tr>1?th-1:th],tm=[to&&te>1?te-1:te,to&&tr>1?tr-1:tr],tg=tv[0]/tm[0],ty=tv[1]/tm[1],tx=0,tb=0;tb<tc;tb++)for(var tC=tb*g.strides[0],tw=0;tw<te;tw++)for(var tE=tg*tw,tR=tC+Math.min(tl-1,to?Math.round(tE):Math.floor(tE))*g.strides[1],tI=0;tI<tr;tI++)for(var tk=ty*tI,tA=tR+Math.min(th-1,to?Math.round(tk):Math.floor(tk))*g.strides[2],tS=0;tS<td;tS++){var tD=tf[tA+tS];tp[tx++]=tD}return Fn(tp,[tc,te,tr,td],g.dtype)},o.prototype.resizeNearestNeighborBackprop=function(g,te,tr){Hh([g,te],"resizeNearestNeighborBackprop");for(var to=te.shape,tu=to[0],tc=to[1],tl=to[2],th=to[3],td=g.shape,tf=td[1],tp=td[2],tv=new Float32Array(tu*tc*tl*th),tm=this.readSync(g.dataId),tg=[tr&&tf>1?tc-1:tc,tr&&tp>1?tl-1:tl],ty=[tr&&tf>1?tf-1:tf,tr&&tp>1?tp-1:tp],tx=tg[0]/ty[0],tb=tg[1]/ty[1],tC=1/tx,tw=1/tb,tE=2*Math.ceil(tC)+2,tR=2*Math.ceil(tw)+2,tI=0;tI<tu;tI++)for(var tk=tI*te.strides[0],tA=0;tA<tc;tA++)for(var tS=tk+tA*te.strides[1],tD=Math.floor(tA*tC),tN=Math.floor(tD-tE/2),tT=0;tT<tl;tT++)for(var tF=tS+tT*te.strides[2],tO=Math.floor(tT*tw),t_=Math.floor(tO-tR/2),tM=0;tM<th;tM++){for(var tB=0,tP=0;tP<tE;tP++){var tL=tP+tN;if(!(tL<0||tL>=tf)){var tW=tk+tL*g.strides[1],tV=tL*tx;if(tA===Math.min(tc-1,tr?Math.round(tV):Math.floor(tV)))for(var tU=0;tU<tR;tU++){var tz=tU+t_;if(!(tz<0||tz>=tp)){var tH=tW+tz*g.strides[2],tG=tz*tb;tT===Math.min(tl-1,tr?Math.round(tG):Math.floor(tG))&&(tB+=tm[tH+tM])}}}}tv[tF+tM]=tB}return Ln(tv,te.shape,te.dtype)},o.prototype.batchNormalization=function(g,te,tr,to,tu,tc){Hh([g,te,tr,tu,tc],"batchNorm");for(var tl=this.readSync(g.dataId),th=this.readSync(te.dataId),td=this.readSync(tr.dataId),tf=tu?this.readSync(tu.dataId):new Float32Array([1]),tp=tc?this.readSync(tc.dataId):new Float32Array([0]),tv=new Float32Array(tl.length),tm=tp.length,tg=tf.length,ty=td.length,tx=th.length,tb=0,tC=0,tw=0,tE=0,tR=0;tR<tl.length;++tR)tv[tR]=tp[tb++]+(tl[tR]-th[tC++])*tf[tw++]/Math.sqrt(td[tE++]+to),tb>=tm&&(tb=0),tC>=tx&&(tC=0),tw>=tg&&(tw=0),tE>=ty&&(tE=0);return Ln(tv,g.shape)},o.prototype.localResponseNormalization4D=function(g,te,tr,to,tu){Hh(g,"localResponseNormalization4D");var tc=g.shape[3],tl=tc-1,th=this.readSync(g.dataId),td=g.size,tf=new Float32Array(td);function l(g){for(var tr=g%tc,to=g-tr+Math.max(0,tr-te),tu=g-tr+Math.min(tr+te,tl),td=0;to<=tu;to++){var tf=th[to];td+=tf*tf}return td}for(var tp=0;tp<td;tp++){var tv=l(tp),tm=th[tp]*Math.pow(tr+to*tv,-tu);tf[tp]=tm}return Ln(tf,g.shape)},o.prototype.LRNGrad=function(g,te,tr,to,tu,tc,tl){Hh(g,"LRNGrad");for(var th=g.shape[3],td=this.readSync(g.dataId),tf=this.readSync(te.dataId),tp=this.readSync(tr.dataId),tv=new Float32Array(g.size),tm=g.size,tg=0;tg<tm;tg++){for(var ty=tg%th,tx=tg-ty+Math.max(0,ty-to),tb=tg-ty+Math.min(th,ty+to+1),tC=0,tw=tx;tw<tb;tw++)tC+=Math.pow(tf[tw],2);for(tC=tc*tC+tu,tw=tx;tw<tb;tw++){var tE=-2*tc*tl*tf[tw]*tp[tg]/tC;tg===tw&&(tE+=Math.pow(tC,-tl)),tE*=td[tg],tv[tw]+=tE}}return Ln(tv,g.shape)},o.prototype.multinomial=function(g,te,tr,to){Hh(g,"multinomial");for(var tu=te?g:nz(g),tc=tu.shape[0],tl=tu.shape[1],th=Gn([tc,tr],"int32"),td=this.readSync(th.dataId),tf=this.readSync(tu.dataId),tp=0;tp<tc;++tp){var tv=tp*tl,tm=new Float32Array(tl-1);tm[0]=tf[tv];for(var tg=1;tg<tm.length;++tg)tm[tg]=tm[tg-1]+tf[tv+tg];for(var ty=nd(to.toString()),tx=tp*tr,tb=0;tb<tr;++tb){var tC=ty();td[tx+tb]=tm.length;for(var tw=0;tw<tm.length;tw++)if(tC<tm[tw]){td[tx+tb]=tw;break}}}return th},o.prototype.oneHot=function(g,te,tr,to){Hh(g,"oneHot");var tu=new Float32Array(g.size*te);tu.fill(to);for(var tc=this.readSync(g.dataId),tl=0;tl<g.size;++tl)tc[tl]>=0&&tc[tl]<te&&(tu[tl*te+tc[tl]]=tr);return Bn(tu,[g.size,te],"int32")},o.prototype.nonMaxSuppression=function(g,te,tr,to,tu){return Hh(g,"nonMaxSuppression"),jo(this.readSync(g.dataId),this.readSync(te.dataId),tr,to,tu)},o.prototype.fft=function(g){return this.fftBatch(g,!1)},o.prototype.ifft=function(g){return this.fftBatch(g,!0)},o.prototype.fftBatch=function(g,te){for(var tr=g.shape[0],to=g.shape[1],tu=dr(g.shape,"float32"),tc=dr(g.shape,"float32"),tl=tQ(g).as2D(tr,to),th=tZ(g).as2D(tr,to),td=0;td<tr;td++)for(var tf=tl.slice([td,0],[1,to]),tp=th.slice([td,0],[1,to]),tv=tJ(tf,tp),tm=this.readSync(this.fftImpl(tv,te).dataId),tg=0;tg<to;tg++){var ty=zo(tm,tg);tu.values[td*to+tg]=ty.real,tc.values[td*to+tg]=ty.imag}return tJ(tu.toTensor(),tc.toTensor()).as2D(tr,to)},o.prototype.fftImpl=function(g,te){var tr=g.as1D(),to=tr.size;if(this.isExponentOf2(to)){var tu=this.fftRadix2(tr,to,te).as2D(g.shape[0],g.shape[1]);return te&&(tu=tJ(tQ(tu).div(On(to)),tZ(tu).div(On(to)))),tu}var tc=this.readSync(g.dataId),tl=function(g){for(var te=new Float32Array(g.length/2),tr=new Float32Array(g.length/2),to=0;to<g.length;to+=2)te[to/2]=g[to],tr[to/2]=g[to+1];return{real:te,imag:tr}}(this.fourierTransformByMatmul(tc,to,te));return tJ(tl.real,tl.imag).as2D(g.shape[0],g.shape[1])},o.prototype.isExponentOf2=function(g){return 0==(g&g-1)},o.prototype.fftRadix2=function(g,te,tr){if(1===te)return g;var to=this.readSync(g.dataId),tu=te/2,tc=function(g){for(var te=Math.ceil(g.length/4),tr=new Float32Array(te),to=new Float32Array(te),tu=0;tu<g.length;tu+=4)tr[Math.floor(tu/4)]=g[tu],to[Math.floor(tu/4)]=g[tu+1];return{real:tr,imag:to}}(to),tl=tJ(tc.real,tc.imag).as1D(),th=function(g){for(var te=Math.floor(g.length/4),tr=new Float32Array(te),to=new Float32Array(te),tu=2;tu<g.length;tu+=4)tr[Math.floor(tu/4)]=g[tu],to[Math.floor(tu/4)]=g[tu+1];return{real:tr,imag:to}}(to),td=tJ(th.real,th.imag).as1D();tl=this.fftRadix2(tl,tu,tr),td=this.fftRadix2(td,tu,tr);var tf=function(g,te){for(var tr=new Float32Array(g/2),to=new Float32Array(g/2),tu=0;tu<Math.ceil(g/2);tu++){var tc=(te?2:-2)*Math.PI*(tu/g);tr[tu]=Math.cos(tc),to[tu]=Math.sin(tc)}return{real:tr,imag:to}}(te,tr),tp=tJ(tf.real,tf.imag).mul(td),tv=tl.add(tp),tm=tl.sub(tp);return tJ(tQ(tv).concat(tQ(tm)),tZ(tv).concat(tZ(tm))).as1D()},o.prototype.fourierTransformByMatmul=function(g,te,tr){for(var to=new Float32Array(2*te),tu=0;tu<te;tu++){for(var tc=0,tl=0,th=0;th<te;th++){var td=Ho(tu*th,te,tr),tf=zo(g,th);tc+=tf.real*td.real-tf.imag*td.imag,tl+=tf.real*td.imag+tf.imag*td.real}tr&&(tc/=te,tl/=te),Go(to,tc,tl,tu)}return to},o.prototype.depthToSpace=function(g,te,tr){C("NHWC"===tr,function(){return"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+tr}),C(te>1,function(){return"blockSize should be > 1 for depthToSpace, but was: "+te});for(var to=g.shape[0],tu=g.shape[1],tc=g.shape[2],tl=g.shape[3],th=tu*te,td=tc*te,tf=tl/(te*te),tp=this.readSync(g.dataId),tv=new Float32Array(to*th*td*tf),tm=0,tg=0;tg<to;++tg)for(var ty=0;ty<th;++ty)for(var tx=Math.floor(ty/te),tb=ty%te,tC=0;tC<td;++tC)for(var tw=Math.floor(tC/te),tE=(tb*te+tC%te)*tf,tR=0;tR<tf;++tR){var tI=tR+tE+tl*(tw+tc*(tx+tu*tg));tv[tm++]=tp[tI]}return Ln(tv,[to,th,td,tf])},o.prototype.broadcastedBinaryOp=function(g,te,tr,to){var tu=Ro(g.shape,te.shape),tc=dr(tu,tr),tl=this.readSync(g.dataId),th=this.readSync(te.dataId),td=Co(g.shape,tu),tf=Co(te.shape,tu),tp=tc.values;if(td.length+tf.length===0)for(var tv=0;tv<tp.length;++tv)tp[tv]=to(tl[tv%tl.length],th[tv%th.length]);else{var tm=this.bufferSync(g),tg=this.bufferSync(te);for(tv=0;tv<tp.length;++tv)(function(tr){var tu=tc.indexToLoc(tr),tv=tu.slice(-g.rank);td.forEach(function(g){return tv[g]=0});var ty=tm.locToIndex(tv),tx=tu.slice(-te.rank);tf.forEach(function(g){return tx[g]=0});var tb=tg.locToIndex(tx);tp[tr]=to(tl[ty],th[tb])})(tv)}return tc.toTensor()},o.prototype.broadcastedBinaryComplexOp=function(g,te,tr){var to=Ro(g.shape,te.shape),tu=dr(to,"float32"),tc=dr(to,"float32"),tl=this.readSync(g.dataId),th=this.readSync(te.dataId),td=Co(g.shape,to),tf=Co(te.shape,to),tp=tu.values,tv=tc.values;if(td.length+tf.length===0)for(var tm=0;tm<tp.length;tm++){var tg=tm%tl.length,ty=tm%th.length,tx=tr(tl[2*tg],tl[2*tg+1],th[2*ty],th[2*ty+1]);tp[tm]=tx.real,tv[tm]=tx.imag}else{var tb=this.bufferSync(this.data.get(g.dataId).complexTensors.real),tC=this.bufferSync(this.data.get(te.dataId).complexTensors.real);for(tm=0;tm<tp.length;tm++)(function(to){var tc=tu.indexToLoc(to),tm=tc.slice(-g.rank);td.forEach(function(g){return tm[g]=0});var tg=tb.locToIndex(tm),ty=tc.slice(-te.rank);tf.forEach(function(g){return ty[g]=0});var tx=tC.locToIndex(ty),tw=tr(tl[2*tg],tl[2*tg+1],th[2*tx],th[2*tx+1]);tp[to]=tw.real,tv[to]=tw.imag})(tm)}return this.complex(tu.toTensor(),tc.toTensor())},o.prototype.split=function(g,te,tr){return Zo(g,te,tr)},o.prototype.dispose=function(){},o.prototype.floatPrecision=function(){return 32},o.prototype.epsilon=function(){return 1e-7},o.prototype.cropAndResize=function(g,te,tr,to,tu,tc){for(var tl=g.shape,th=tl[0],td=tl[1],tf=tl[2],tp=tl[3],tv=te.shape[0],tm=to[0],tg=to[1],ty=dr([tv,tm,tg,tp],"float32"),tx=this.readSync(te.dataId),tb=this.readSync(tr.dataId),tC=this.readSync(g.dataId),tw=g.strides,tE=ty.strides,tR=0;tR<tv;tR++){var tI=4*tR,tk=tx[tI],tA=tx[tI+1],tS=tx[tI+2],tD=tx[tI+3],tN=tb[tR];if(!(tN>=th))for(var tT=tm>1?(tS-tk)*(td-1)/(tm-1):0,tF=tg>1?(tD-tA)*(tf-1)/(tg-1):0,tO=0;tO<tm;tO++){var t_,tM=tm>1?tk*(td-1)+tO*tT:.5*(tk+tS)*(td-1);if(tM<0||tM>td-1)for(var tB=0;tB<tg;tB++)for(var tP=0;tP<tp;tP++){var tL=tP+tB*tE[2]+tO*tE[1]+tR*tE[0];ty.values[tL]=tc}else if("bilinear"===tu){var tW=Math.floor(tM),tV=Math.ceil(tM),tU=tM-tW;for(tB=0;tB<tg;tB++)if((t_=tg>1?tA*(tf-1)+tB*tF:.5*(tA+tD)*(tf-1))<0||t_>tf-1)for(tP=0;tP<tp;tP++)tL=tP+tB*tE[2]+tO*tE[1]+tR*tE[0],ty.values[tL]=tc;else{var tz=Math.floor(t_),tH=Math.ceil(t_),tG=t_-tz;for(tP=0;tP<tp;tP++){var tq=tC[tL=tP+tz*tw[2]+tW*tw[1]+tN*tw[0]],tK=tC[tL=tP+tH*tw[2]+tW*tw[1]+tN*tw[0]],tj=tC[tL=tP+tz*tw[2]+tV*tw[1]+tN*tw[0]],tX=tq+(tK-tq)*tG,t$=tj+(tC[tL=tP+tH*tw[2]+tV*tw[1]+tN*tw[0]]-tj)*tG;tL=tP+tB*tE[2]+tO*tE[1]+tR*tE[0],ty.values[tL]=tX+(t$-tX)*tU}}}else for(tB=0;tB<tg;++tB)if((t_=tg>1?tA*(tf-1)+tB*tF:.5*(tA+tD)*(tf-1))<0||t_>tf-1)for(tP=0;tP<tp;tP++)tL=tP+tB*tE[2]+tO*tE[1]+tR*tE[0],ty.values[tL]=tc;else{var tY=Math.round(t_),tJ=Math.round(tM);for(tP=0;tP<tp;tP++){var tQ=tP+tY*tw[2]+tJ*tw[1]+tN*tw[0],tZ=tP+tB*tE[2]+tO*tE[1]+tR*tE[0];ty.values[tZ]=tC[tQ]}}}}return ty.toTensor()},o.prototype.sparseToDense=function(g,te,tr,to){var tu=Zr(0,g,tr),tc=tu.sliceRank,tl=tu.numUpdates,th=tu.sliceSize,td=tu.strides,tf=tu.outputSize;return this.scatter(g,te,tr,tf,th,tl,tc,td,to,!1)},o.prototype.gatherND=function(g,te){var tr=te.shape,to=tr[tr.length-1],tu=jr(g,te),tc=tu[0],tl=tu[1],th=tu[2],td=tu[3];if(0===tl)return Fn([],tc,g.dtype);for(var tf=new tm([tl,th],g.dtype),tp=this.readSync(te.dataId),tv=this.readSync(g.dataId),tg=0;tg<tl;tg++){for(var ty=[],tx=0,tb=0;tb<to;tb++){var tC=tp[tg*to+tb];tx+=tC*td[tb],ty.push(tC)}if(tx<0||tx>=g.size/th)throw Error("Invalid indices: "+ty+" does not index into "+g.shape);for(var tw=0;tw<th;tw++)tf.values[tg*th+tw]=tv[tx*th+tw]}return tf.toTensor().reshape(tc)},o.prototype.scatterND=function(g,te,tr){var to=Zr(0,g,tr),tu=to.sliceRank,tc=to.numUpdates,tl=to.sliceSize,th=to.strides,td=to.outputSize,tf=On(0);return this.scatter(g,te,tr,td,tl,tc,tu,th,tf,!0)},o.prototype.fill=function(g,te,tr){var to=P(tr=tr||j(te),k(g));return to.fill(te),tB.makeTensor(to,g,tr,this)},o.prototype.onesLike=function(g){if("string"===g.dtype)throw Error("onesLike is not supported for string tensors");return this.fill(g.shape,1,g.dtype)},o.prototype.zerosLike=function(g){var te=P(g.dtype,k(g.shape));return this.makeOutput(te,g.shape,g.dtype)},o.prototype.linspace=function(g,te,tr){return Wo(g,te,tr)},o.prototype.scatter=function(g,te,tr,to,tu,tc,tl,th,td,tf){var tp=[to/tu,tu],tv=this.readSync(g.dataId),tg=this.readSync(te.dataId);if(0===to)return Fn([],tr,te.dtype);var ty=new tm(tp,te.dtype);ty.values.fill(this.readSync(td.dataId)[0]);for(var tx=0;tx<tc;tx++){for(var tb=[],tC=0,tw=0;tw<tl;tw++){var tE=tv[tx*tl+tw];tb.push(tE),tC+=tE*th[tw]}if(tC<0||tC>=to/tu)throw Error("Invalid indices: "+tb+" does not index into "+tr);for(var tR=0;tR<tu;tR++)tf?ty.values[tC*tu+tR]+=tg[tx*tu+tR]:ty.values[tC*tu+tR]=0===te.rank?tg[0]:tg[tx*tu+tR]}return ty.toTensor().reshape(tr)},o}(nq);tB.registerBackend("cpu",function(){return new aD},1);for(var aN=0,aT=[{kernelName:"NonMaxSuppressionV5",backendName:"cpu",kernelFunc:function(g){var te=g.inputs,tr=g.backend,to=g.attrs,tu=te.boxes,tc=te.scores,tl=to.maxOutputSize,th=to.iouThreshold,td=to.scoreThreshold,tf=to.softNmsSigma;Hh(tu,"NonMaxSuppressionWithScore");var tp=Xo(tr.data.get(tu.dataId).values,tr.data.get(tc.dataId).values,tl,th,td,tf);return[tp.selectedIndices,tp.selectedScores]}},{kernelName:"Square",backendName:"cpu",kernelFunc:function(g){var te=g.inputs,tr=g.backend,to=te.x;Hh(to,"square");for(var tu=tr.data.get(to.dataId).values,tc=new Float32Array(tu.length),tl=0;tl<tu.length;++tl){var th=tu[tl];tc[tl]=th*th}return{dataId:tr.write(tc,to.shape,to.dtype),shape:to.shape,dtype:to.dtype}}},{kernelName:eB,backendName:"cpu",kernelFunc:function(g){var te=g.inputs,tr=g.backend,to=te.a,tu=te.b;Hh([to,tu],eB);var tc=tr.data.get(to.dataId).values,tl=tr.data.get(tu.dataId).values,th=function(g,te,tr,to,tu,tc){var tl=Ro(g,te),th=tl.length,td=$(tl),tf=B(tu,k(tl)),tp=g.length,tv=te.length,tm=$(g),tg=$(te),ty=Co(g,tl),tx=Co(te,tl);if(ty.length+tx.length===0)for(var tb=0;tb<tf.length;++tb)tf[tb]=tc(tr[tb%tr.length],to[tb%to.length]);else for(tb=0;tb<tf.length;++tb)!function(g){var te=it(g,th,td),tu=te.slice(-tp);ty.forEach(function(g){return tu[g]=0});var tl=at(tu,tp,tm),tb=te.slice(-tv);tx.forEach(function(g){return tb[g]=0});var tC=at(tb,tv,tg);tf[g]=tc(tr[tl],to[tC])}(tb);return[tf,tl]}(to.shape,tu.shape,tc,tl,to.dtype,function(g,te){var tr=g-te;return tr*tr}),td=th[0],tf=th[1];return{dataId:tr.write(td,tf,to.dtype),shape:tf,dtype:to.dtype}}}];aN<aT.length;aN++)d(aT[aN]);for(var aF,aO,a_,$h=function(g){this.variableNames=["A"];var te=ua(),tr=g[0],to=g[1];this.outputShape=g,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+to+".0, "+tr+".0);\n\n        vec4 values = "+te.texture2D+"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    "},Qh=function(g){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;var te=ua(),tr=g[0],to=g[1];this.outputShape=g,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2("+to+".0, "+tr+".0);\n            vec4 values = "+te.texture2D+"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        "+te.output+" = result;\n      }\n    "},aM=0,aB=[{kernelName:"FromPixels",backendName:"webgl",kernelFunc:function(g){var te=g.inputs,tr=g.backend,to=g.attrs,tu=te.pixels,tc=to.numChannels,tl="undefined"!=typeof HTMLVideoElement&&tu instanceof HTMLVideoElement,td="undefined"!=typeof HTMLImageElement&&tu instanceof HTMLImageElement,tf=tl?[tu.videoWidth,tu.videoHeight]:[tu.width,tu.height],tp=tf[0],tv=tf[1],tm=[tv,tp],tg=[tv,tp,tc];(td||tl)&&(null==a_&&(a_=document.createElement("canvas").getContext("2d")),a_.canvas.width=tp,a_.canvas.height=tv,a_.drawImage(tu,0,0,tp,tv),tu=a_.canvas);var ty=tr.makeTensorInfo(tm,"int32");tr.texData.get(ty.dataId).usage=tW.PIXELS,tr.gpgpu.uploadPixelDataToTexture(tr.getTexture(ty.dataId),tu);var tx=th.getBool("WEBGL_PACK")?new Qh(tg):new $h(tg),tb=tr.runWebGLProgram(tx,[ty],"int32");return tr.disposeData(ty.dataId),tb}},{kernelName:"NonMaxSuppressionV5",backendName:"webgl",kernelFunc:function(g){var te=g.inputs,tr=g.backend,to=g.attrs;dn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var tu=te.boxes,tc=te.scores,tl=to.maxOutputSize,th=to.iouThreshold,td=to.scoreThreshold,tf=to.softNmsSigma,tp=Xo(tr.readSync(tu.dataId),tr.readSync(tc.dataId),tl,th,td,tf);return[tp.selectedIndices,tp.selectedScores]}},{kernelName:"Square",backendName:"webgl",kernelFunc:function(g){var te=g.inputs,tr=g.backend,to=te.x,tu=new Cs(to.shape,"return x * x;");return tr.runWebGLProgram(tu,[to],to.dtype)}},{kernelName:eB,backendName:"webgl",kernelFunc:function(g){var te=g.inputs,tr=g.backend,to=te.a,tu=te.b,tc=th.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("return (a - b) * (a - b);",to.shape,tu.shape):new Ba("return (a - b) * (a - b);",to.shape,tu.shape);return tr.compileAndRun(tc,[to,tu])}}];aM<aB.length;aM++)d(aB[aM]);for(var aP=0,aL=[{kernelName:"Square",gradFunc:function(g,te){var tr=te[0];return{x:function(){return g.mul(tr.toFloat().mul(2))}}}},{kernelName:eB,gradFunc:function(g,te){var tr=te[0],to=te[1],tu=On(2);return{a:function(){return rz(g,rz(tu,rj(tr,to)))},b:function(){return rz(g,rz(tu,rj(to,tr)))}}}}];aP<aL.length;aP++)p(aL[aP]);var aW=function(){function t(){}return t.prototype.fetch=function(g,te){return fetch(g,te)},t.prototype.now=function(){return performance.now()},t.prototype.encode=function(g,te){if("utf-8"!==te&&"utf8"!==te)throw Error("Browser's encoder only supports utf-8, but got "+te);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(g)},t.prototype.decode=function(g,te){return new TextDecoder(te).decode(g)},t}();th.get("IS_BROWSER")&&th.setPlatform("browser",new aW);var aV,aU=function(){function t(){this.util=tr(753),this.textEncoder=new this.util.TextEncoder}return t.prototype.fetch=function(g,te){return null!=th.global.fetch?th.global.fetch(g,te):(null==aV&&(aV=tr(522)),aV(g,te))},t.prototype.now=function(){var g=tu.hrtime();return 1e3*g[0]+g[1]/1e6},t.prototype.encode=function(g,te){if("utf-8"!==te&&"utf8"!==te)throw Error("Node built-in encoder only supports utf-8, but got "+te);return this.textEncoder.encode(g)},t.prototype.decode=function(g,te){return 0===g.length?"":new this.util.TextDecoder(te).decode(g)},t}();th.get("IS_NODE")&&th.setPlatform("node",new aU);var az={float32:4,int32:4,uint16:2,uint8:1,bool:1};function cf(g,te){for(var tr={},to=0,tu=0;tu<te.length;tu++)!function(te){var tu=te.name,tc=te.dtype,tl=te.shape,th=k(tl),td=void 0;if("quantization"in te){var tf=te.quantization;if("uint8"!==tf.dtype&&"uint16"!==tf.dtype)throw Error("Weight "+te.name+" has unknown quantization dtype "+tf.dtype+". Supported quantization dtypes are: 'uint8' and 'uint16'.");var tp=az[tf.dtype],tv=g.slice(to,to+th*tp),tm="uint8"===tf.dtype?new Uint8Array(tv):new Uint16Array(tv);if("float32"===tc)td=Float32Array.from(tm,function(g){return g*tf.scale+tf.min});else{if("int32"!==tc)throw Error("Unsupported dtype in weight '"+tu+"': "+tc);td=Int32Array.from(tm,function(g){return Math.round(g*tf.scale+tf.min)})}to+=th*tp}else if("string"===tc){var tg=k(te.shape);td=[];for(var ty=0;ty<tg;ty++){var tx=new Uint32Array(g.slice(to,to+4))[0];to+=4;var tb=new Uint8Array(g.slice(to,to+tx));td.push(tb),to+=tx}}else{var tC=az[tc];if(tv=g.slice(to,to+th*tC),"float32"===tc)td=new Float32Array(tv);else if("int32"===tc)td=new Int32Array(tv);else{if("bool"!==tc)throw Error("Unsupported dtype in weight '"+tu+"': "+tc);td=new Uint8Array(tv)}to+=th*tC}tr[tu]=Fn(td,tl,tc)}(te[tu]);return tr}function lf(g){if(null===g)throw Error("Invalid input value: "+JSON.stringify(g));var te=0,tr=[];g.forEach(function(g){if(te+=g.byteLength,tr.push(g.byteLength===g.buffer.byteLength?g:new g.constructor(g)),!(g instanceof Float32Array||g instanceof Int32Array||g instanceof Uint8Array))throw Error("Unsupported TypedArray subtype: "+g.constructor.name)});var to=new Uint8Array(te),tu=0;return tr.forEach(function(g){to.set(new Uint8Array(g.buffer),tu),tu+=g.byteLength}),to.buffer}var aH=void 0!==tc&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function ff(g){return aH?tc.byteLength(g):new Blob([g]).size}function df(g){var te=0;g.forEach(function(g){te+=g.byteLength});var tr=new Uint8Array(te),to=0;return g.forEach(function(g){tr.set(new Uint8Array(g),to),to+=g.byteLength}),tr.buffer}function pf(g){for(g=g.trim();g.endsWith("/");)g=g.slice(0,g.length-1);var te=g.split("/");return te[te.length-1]}function vf(g){if(g.modelTopology instanceof ArrayBuffer)throw Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==g.modelTopology?0:ff(JSON.stringify(g.modelTopology)),weightSpecsBytes:null==g.weightSpecs?0:ff(JSON.stringify(g.weightSpecs)),weightDataBytes:null==g.weightData?0:g.weightData.byteLength}}var aG=function(){function t(){this.saveRouters=[],this.loadRouters=[]}return t.getInstance=function(){return null==t.instance&&(t.instance=new t),t.instance},t.registerSaveRouter=function(g){t.getInstance().saveRouters.push(g)},t.registerLoadRouter=function(g){t.getInstance().loadRouters.push(g)},t.getSaveHandlers=function(g){return t.getHandlers(g,"save")},t.getLoadHandlers=function(g,te){return t.getHandlers(g,"load",te)},t.getHandlers=function(g,te,tr){var to=[];return("load"===te?t.getInstance().loadRouters:t.getInstance().saveRouters).forEach(function(te){var tu=te(g,tr);null!==tu&&to.push(tu)}),to},t}(),aq=function(){function t(){this.managers={}}return t.getInstance=function(){return null==t.instance&&(t.instance=new t),t.instance},t.registerManager=function(g,te){C(null!=g,function(){return"scheme must not be undefined or null."}),g.endsWith("://")&&(g=g.slice(0,g.indexOf("://"))),C(g.length>0,function(){return"scheme must not be an empty string."});var tr=t.getInstance();C(null==tr.managers[g],function(){return"A model store manager is already registered for scheme '"+g+"'."}),tr.managers[g]=te},t.getManager=function(g){var te=this.getInstance().managers[g];if(null==te)throw Error("Cannot find model manager for scheme '"+g+"'");return te},t.getSchemes=function(){return Object.keys(this.getInstance().managers)},t}();function xf(g){if(-1===g.indexOf("://"))throw Error("The url string provided does not contain a scheme. Supported schemes are: "+aq.getSchemes().join(","));return{scheme:g.split("://")[0],path:g.split("://")[1]}}function bf(g,te,tr){return void 0===tr&&(tr=!1),n(this,void 0,void 0,function(){var to,tu,tc,tl,th,td,tf,tp,tv;return r(this,function(tm){switch(tm.label){case 0:return C(g!==te,function(){return"Old path and new path are the same: '"+g+"'"}),C((to=aG.getLoadHandlers(g)).length>0,function(){return"Copying failed because no load handler is found for source URL "+g+"."}),C(to.length<2,function(){return"Copying failed because more than one ("+to.length+") load handlers for source URL "+g+"."}),tu=to[0],C((tc=aG.getSaveHandlers(te)).length>0,function(){return"Copying failed because no save handler is found for destination URL "+te+"."}),C(tc.length<2,function(){return"Copying failed because more than one ("+to.length+") save handlers for destination URL "+te+"."}),tl=tc[0],th=xf(g).scheme,td=xf(g).path,tf=th===xf(g).scheme,[4,tu.load()];case 1:return tp=tm.sent(),tr&&tf?[4,aq.getManager(th).removeModel(td)]:[3,3];case 2:tm.sent(),tm.label=3;case 3:return[4,tl.save(tp)];case 4:return tv=tm.sent(),!tr||tf?[3,6]:[4,aq.getManager(th).removeModel(td)];case 5:tm.sent(),tm.label=6;case 6:return[2,tv.modelArtifactsInfo]}})})}var aK="models_store",aj="model_info_store";function Ef(){if(!th.getBool("IS_BROWSER"))throw Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");var g=window||self,te=g.indexedDB||g.mozIndexedDB||g.webkitIndexedDB||g.msIndexedDB||g.shimIndexedDB;if(null==te)throw Error("The current browser does not appear to support IndexedDB.");return te}function Rf(g){var te=g.result;te.createObjectStore(aK,{keyPath:"modelPath"}),te.createObjectStore(aj,{keyPath:"modelPath"})}var aX=function(){function t(g){if(this.indexedDB=Ef(),null==g||!g)throw Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=g}return t.prototype.save=function(g){return n(this,void 0,void 0,function(){return r(this,function(te){if(g.modelTopology instanceof ArrayBuffer)throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return[2,this.databaseAction(this.modelPath,g)]})})},t.prototype.load=function(){return n(this,void 0,void 0,function(){return r(this,function(g){return[2,this.databaseAction(this.modelPath)]})})},t.prototype.databaseAction=function(g,te){var tr=this;return new Promise(function(g,to){var tu=tr.indexedDB.open("tensorflowjs",1);tu.onupgradeneeded=function(){return Rf(tu)},tu.onsuccess=function(){var tc=tu.result;if(null==te){var tl=tc.transaction(aK,"readonly"),th=tl.objectStore(aK).get(tr.modelPath);th.onsuccess=function(){if(null==th.result)return tc.close(),to(Error("Cannot find model with path '"+tr.modelPath+"' in IndexedDB."));g(th.result.modelArtifacts)},th.onerror=function(g){return tc.close(),to(th.error)},tl.oncomplete=function(){return tc.close()}}else{var td,tf=vf(te),tp=tc.transaction(aj,"readwrite"),tv=tp.objectStore(aj),tm=tv.put({modelPath:tr.modelPath,modelArtifactsInfo:tf});tm.onsuccess=function(){var tu=(td=tc.transaction(aK,"readwrite")).objectStore(aK).put({modelPath:tr.modelPath,modelArtifacts:te,modelArtifactsInfo:tf});tu.onsuccess=function(){return g({modelArtifactsInfo:tf})},tu.onerror=function(g){var te=(tv=tp.objectStore(aj)).delete(tr.modelPath);te.onsuccess=function(){return tc.close(),to(tu.error)},te.onerror=function(g){return tc.close(),to(tu.error)}}},tm.onerror=function(g){return tc.close(),to(tm.error)},tp.oncomplete=function(){null==td?tc.close():td.oncomplete=function(){return tc.close()}}}},tu.onerror=function(g){return to(tu.error)}})},t.URL_SCHEME="indexeddb://",t}(),kf=function(g){var te;return th.getBool("IS_BROWSER")&&!Array.isArray(g)&&g.startsWith(aX.URL_SCHEME)?(te=g.slice(aX.URL_SCHEME.length),new aX(te)):null};aG.registerSaveRouter(kf),aG.registerLoadRouter(kf);var a$=function(){function t(){this.indexedDB=Ef()}return t.prototype.listModels=function(){return n(this,void 0,void 0,function(){var g=this;return r(this,function(te){return[2,new Promise(function(te,tr){var to=g.indexedDB.open("tensorflowjs",1);to.onupgradeneeded=function(){return Rf(to)},to.onsuccess=function(){var g=to.result,tu=g.transaction(aj,"readonly"),tc=tu.objectStore(aj).getAll();tc.onsuccess=function(){for(var g={},tr=0,to=tc.result;tr<to.length;tr++){var tu=to[tr];g[tu.modelPath]=tu.modelArtifactsInfo}te(g)},tc.onerror=function(te){return g.close(),tr(tc.error)},tu.oncomplete=function(){return g.close()}},to.onerror=function(g){return tr(to.error)}})]})})},t.prototype.removeModel=function(g){return n(this,void 0,void 0,function(){var te=this;return r(this,function(tr){var to;return g=(to=g).startsWith(aX.URL_SCHEME)?to.slice(aX.URL_SCHEME.length):to,[2,new Promise(function(tr,to){var tu=te.indexedDB.open("tensorflowjs",1);tu.onupgradeneeded=function(){return Rf(tu)},tu.onsuccess=function(){var te,tc=tu.result,tl=tc.transaction(aj,"readwrite"),th=tl.objectStore(aj),td=th.get(g);td.onsuccess=function(){if(null==td.result)return tc.close(),to(Error("Cannot find model with path '"+g+"' in IndexedDB."));var tu=th.delete(g),i=function(){var tu=(te=tc.transaction(aK,"readwrite")).objectStore(aK).delete(g);tu.onsuccess=function(){return tr(td.result.modelArtifactsInfo)},tu.onerror=function(g){return to(td.error)}};tu.onsuccess=i,tu.onerror=function(g){return i(),tc.close(),to(td.error)}},td.onerror=function(g){return tc.close(),to(td.error)},tl.oncomplete=function(){null==te?tc.close():te.oncomplete=function(){return tc.close()}}},tu.onerror=function(g){return to(tu.error)}})]})})},t}();if(th.getBool("IS_BROWSER"))try{aq.registerManager(aX.URL_SCHEME,new a$)}catch(g){}var aY="tensorflowjs_models",aJ="info";function Mf(g){return{info:[aY,g,aJ].join("/"),topology:[aY,g,"model_topology"].join("/"),weightSpecs:[aY,g,"weight_specs"].join("/"),weightData:[aY,g,"weight_data"].join("/"),modelMetadata:[aY,g,"model_metadata"].join("/")}}function Bf(g){var te=g.split("/");if(te.length<3)throw Error("Invalid key format: "+g);return te.slice(1,te.length-1).join("/")}var aQ=function(){function t(g){if(!th.getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==g||!g)throw Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=g,this.keys=Mf(this.modelPath)}return t.prototype.save=function(g){return n(this,void 0,void 0,function(){var te,tr,to;return r(this,function(tu){if(g.modelTopology instanceof ArrayBuffer)throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");te=JSON.stringify(g.modelTopology),tr=JSON.stringify(g.weightSpecs),to=vf(g);try{return this.LS.setItem(this.keys.info,JSON.stringify(to)),this.LS.setItem(this.keys.topology,te),this.LS.setItem(this.keys.weightSpecs,tr),this.LS.setItem(this.keys.weightData,function(g){if(aH)return tc.from(g).toString("base64");for(var te=new Uint8Array(g),tr="",to=0,tu=te.length;to<tu;to++)tr+=String.fromCharCode(te[to]);return btoa(tr)}(g.weightData)),this.LS.setItem(this.keys.modelMetadata,JSON.stringify({format:g.format,generatedBy:g.generatedBy,convertedBy:g.convertedBy,userDefinedMetadata:g.userDefinedMetadata})),[2,{modelArtifactsInfo:to}]}catch(g){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),Error("Failed to save model '"+this.modelPath+"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes="+to.modelTopologyBytes+", weightSpecsBytes="+to.weightSpecsBytes+", weightDataBytes="+to.weightDataBytes+".")}return[2]})})},t.prototype.load=function(){return n(this,void 0,void 0,function(){var g,te,tr,to,tu,tl,th;return r(this,function(td){if(null==(g=JSON.parse(this.LS.getItem(this.keys.info))))throw Error("In local storage, there is no model with name '"+this.modelPath+"'");if("JSON"!==g.modelTopologyType)throw Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");if(te={},null==(tr=JSON.parse(this.LS.getItem(this.keys.topology))))throw Error("In local storage, the topology of model '"+this.modelPath+"' is missing.");if(te.modelTopology=tr,null==(to=JSON.parse(this.LS.getItem(this.keys.weightSpecs))))throw Error("In local storage, the weight specs of model '"+this.modelPath+"' are missing.");if(te.weightSpecs=to,null!=(tu=this.LS.getItem(this.keys.modelMetadata))&&(tl=JSON.parse(tu),te.format=tl.format,te.generatedBy=tl.generatedBy,te.convertedBy=tl.convertedBy,te.userDefinedMetadata=tl.userDefinedMetadata),null==(th=this.LS.getItem(this.keys.weightData)))throw Error("In local storage, the binary weight values of model '"+this.modelPath+"' are missing.");return te.weightData=function(g){if(aH){var te=tc.from(g,"base64");return te.buffer.slice(te.byteOffset,te.byteOffset+te.byteLength)}for(var tr=atob(g),to=new Uint8Array(tr.length),tu=0;tu<tr.length;++tu)to.set([tr.charCodeAt(tu)],tu);return to.buffer}(th),[2,te]})})},t.URL_SCHEME="localstorage://",t}(),Lf=function(g){var te;return th.getBool("IS_BROWSER")&&!Array.isArray(g)&&g.startsWith(aQ.URL_SCHEME)?(te=g.slice(aQ.URL_SCHEME.length),new aQ(te)):null};aG.registerSaveRouter(Lf),aG.registerLoadRouter(Lf);var aZ=function(){function t(){C(th.getBool("IS_BROWSER"),function(){return"Current environment is not a web browser"}),C("undefined"==typeof window||void 0!==window.localStorage,function(){return"Current browser does not appear to support localStorage"}),this.LS=window.localStorage}return t.prototype.listModels=function(){return n(this,void 0,void 0,function(){var g,te,tr,to,tu;return r(this,function(tc){for(g={},te=aY+"/",tr="/"+aJ,to=0;to<this.LS.length;++to)(tu=this.LS.key(to)).startsWith(te)&&tu.endsWith(tr)&&(g[Bf(tu)]=JSON.parse(this.LS.getItem(tu)));return[2,g]})})},t.prototype.removeModel=function(g){return n(this,void 0,void 0,function(){var te,tr;return r(this,function(to){var tu;if(te=Mf(g=(tu=g).startsWith(aQ.URL_SCHEME)?tu.slice(aQ.URL_SCHEME.length):tu),null==this.LS.getItem(te.info))throw Error("Cannot find model at path '"+g+"'");return tr=JSON.parse(this.LS.getItem(te.info)),this.LS.removeItem(te.info),this.LS.removeItem(te.topology),this.LS.removeItem(te.weightSpecs),this.LS.removeItem(te.weightData),[2,tr]})})},t}();if(th.getBool("IS_BROWSER"))try{aq.registerManager(aQ.URL_SCHEME,new aZ)}catch(g){}function Gf(g){return new Promise(function(g){return setTimeout(g)}).then(g)}var a0=function(){function t(g){if(!th.getBool("IS_BROWSER"))throw Error("browserDownloads() cannot proceed because the current environment is not a browser.");g.startsWith(t.URL_SCHEME)&&(g=g.slice(t.URL_SCHEME.length)),null!=g&&0!==g.length||(g="model"),this.modelTopologyFileName=g+".json",this.weightDataFileName=g+".weights.bin"}return t.prototype.save=function(g){return n(this,void 0,void 0,function(){var te,tr,to,tu,tc,tl;return r(this,function(th){switch(th.label){case 0:if("undefined"==typeof document)throw Error("Browser downloads are not supported in this environment since `document` is not present");if(te=window.URL.createObjectURL(new Blob([g.weightData],{type:"application/octet-stream"})),!(g.modelTopology instanceof ArrayBuffer))return[3,1];throw Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");case 1:return tr=[{paths:["./"+this.weightDataFileName],weights:g.weightSpecs}],to={modelTopology:g.modelTopology,format:g.format,generatedBy:g.generatedBy,convertedBy:g.convertedBy,weightsManifest:tr},tu=window.URL.createObjectURL(new Blob([JSON.stringify(to)],{type:"application/json"})),(tc=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor).download=this.modelTopologyFileName,tc.href=tu,[4,Gf(function(){return tc.dispatchEvent(new MouseEvent("click"))})];case 2:return th.sent(),null==g.weightData?[3,4]:((tl=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor).download=this.weightDataFileName,tl.href=te,[4,Gf(function(){return tl.dispatchEvent(new MouseEvent("click"))})]);case 3:th.sent(),th.label=4;case 4:return[2,{modelArtifactsInfo:vf(g)}]}})})},t.URL_SCHEME="downloads://",t}(),a1=function(){function t(g){if(null==g||g.length<1)throw Error("When calling browserFiles, at least 1 file is required, but received "+g);this.files=g}return t.prototype.load=function(){return n(this,void 0,void 0,function(){var g,te,tr=this;return r(this,function(to){return g=this.files[0],te=this.files.slice(1),[2,new Promise(function(to,tu){var tc=new FileReader;tc.onload=function(tc){var tl=JSON.parse(tc.target.result),th=tl.modelTopology;if(null!=th){0===te.length&&to({modelTopology:th});var td=tl.weightsManifest;if(null!=td){try{tf=tr.checkManifestAndWeightFiles(td,te)}catch(g){return void tu(g)}var tf,tp=[],tv=[],tm=[];td.forEach(function(g){g.paths.forEach(function(g){tv.push(g),tm.push(null)}),tp.push.apply(tp,g.weights)}),td.forEach(function(g){g.paths.forEach(function(g){var te=new FileReader;te.onload=function(te){var tr=te.target.result;tm[tv.indexOf(g)]=tr,-1===tm.indexOf(null)&&to({modelTopology:th,weightSpecs:tp,weightData:df(tm),format:tl.format,generatedBy:tl.generatedBy,convertedBy:tl.convertedBy,userDefinedMetadata:tl.userDefinedMetadata})},te.onerror=function(te){return tu("Failed to weights data from file of path '"+g+"'.")},te.readAsArrayBuffer(tf[g])})})}else tu(Error("weightManifest field is missing from file "+g.name))}else tu(Error("modelTopology field is missing from file "+g.name))},tc.onerror=function(te){return tu("Failed to read model topology and weights manifest JSON from file '"+g.name+"'. BrowserFiles supports loading Keras-style tf.Model artifacts only.")},tc.readAsText(g)})]})})},t.prototype.checkManifestAndWeightFiles=function(g,te){for(var tr=[],to=te.map(function(g){return pf(g.name)}),tu={},tc=0;tc<g.length;tc++)g[tc].paths.forEach(function(g){var tc=pf(g);if(-1!==tr.indexOf(tc))throw Error("Duplicate file basename found in weights manifest: '"+tc+"'");if(tr.push(tc),-1===to.indexOf(tc))throw Error("Weight file with basename '"+tc+"' is not provided.");tu[g]=te[to.indexOf(tc)]});if(tr.length!==te.length)throw Error("Mismatch in the number of files in weights manifest ("+tr.length+") and the number of weight files provided ("+te.length+").");return tu},t}();function Kf(g,te,tr,to){C(null!=g&&Array.isArray(g)&&g.length>0,function(){return"promises must be a none empty array"}),tu=tr=null==tr?0:tr,tc=to=null==to?1:to,C(tu>=0&&tu<=1,function(){return"Progress fraction must be in range [0, 1], but got startFraction "+tu}),C(tc>=0&&tc<=1,function(){return"Progress fraction must be in range [0, 1], but got endFraction "+tc}),C(tc>=tu,function(){return"startFraction must be no more than endFraction, but got startFraction "+tu+" and endFraction "+tc});var tu,tc,tl=0;return Promise.all(g.map(function(tu){return tu.then(function(tu){return te(tr+ ++tl/g.length*(to-tr)),tu}),tu}))}function jf(g,te){return n(this,void 0,void 0,function(){var tr,to,tu,tc,tl,td,tf,tp,tv;return r(this,function(tm){switch(tm.label){case 0:return null==te&&(te={}),tr=null==te.fetchFunc?th.platform.fetch:te.fetchFunc,to=g.map(function(g){return tr(g,te.requestInit,{isBinary:!0})}),tu=0,tc=.5,null!=te.onProgress?[3,2]:[4,Promise.all(to)];case 1:return tl=tm.sent(),[3,4];case 2:return[4,Kf(to,te.onProgress,tu,tc)];case 3:tl=tm.sent(),tm.label=4;case 4:return td=tl.map(function(g){return g.arrayBuffer()}),tf=.5,tp=1,null!=te.onProgress?[3,6]:[4,Promise.all(td)];case 5:return tv=tm.sent(),[3,8];case 6:return[4,Kf(td,te.onProgress,tf,tp)];case 7:tv=tm.sent(),tm.label=8;case 8:return[2,tv]}})})}function Xf(g){var te=this;return function(tr,to,tu){return void 0===to&&(to=""),n(te,void 0,void 0,function(){var te,tc,tl,th,td,tf,tp,tv,tm;return r(this,function(tg){switch(tg.label){case 0:if(te=tr.map(function(){return!1}),tc={},tl=null!=tu?tu.map(function(){return!1}):[],th=[],tr.forEach(function(g,tr){var to=0;g.weights.forEach(function(g){var td=az["quantization"in g?g.quantization.dtype:g.dtype]*k(g.shape),l=function(){te[tr]=!0,null==tc[tr]&&(tc[tr]=[]),tc[tr].push({manifestEntry:g,groupOffset:to,sizeBytes:td})};null!=tu?tu.forEach(function(te,tr){te===g.name&&(l(),tl[tr]=!0)}):l(),th.push(g.name),to+=td})}),!tl.every(function(g){return g}))throw Error("Could not find weights in manifest with names: "+tu.filter(function(g,te){return!tl[te]}).join(", ")+". \nManifest JSON has weights with names: "+th.join(", ")+".");return td=te.reduce(function(g,te,tr){return te&&g.push(tr),g},[]),tf=[],td.forEach(function(g){tr[g].paths.forEach(function(g){var te=to+(to.endsWith("/")?"":"/")+g;tf.push(te)})}),[4,g(tf)];case 1:return tp=tg.sent(),tv={},tm=0,td.forEach(function(g){for(var te=tr[g].paths.length,to=0,tu=0;tu<te;tu++)to+=tp[tm+tu].byteLength;for(var tl=new ArrayBuffer(to),th=new Uint8Array(tl),td=0,tf=0;tf<te;tf++){var tg=new Uint8Array(tp[tm+tf]);th.set(tg,td),td+=tg.byteLength}tc[g].forEach(function(g){var te=cf(tl.slice(g.groupOffset,g.groupOffset+g.sizeBytes),[g.manifestEntry]);for(var tr in te)tv[tr]=te[tr]}),tm+=te}),[2,tv]}})})}}aG.registerSaveRouter(function(g){var te;return th.getBool("IS_BROWSER")&&!Array.isArray(g)&&g.startsWith(a0.URL_SCHEME)?(void 0===(te=g.slice(a0.URL_SCHEME.length))&&(te="model"),new a0(te)):null});var a2=function(){function t(g,te){if(this.DEFAULT_METHOD="POST",null==te&&(te={}),this.weightPathPrefix=te.weightPathPrefix,this.onProgress=te.onProgress,null!=te.fetchFunc?(C("function"==typeof te.fetchFunc,function(){return"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"}),this.fetch=te.fetchFunc):this.fetch=th.platform.fetch,C(null!=g&&g.length>0,function(){return"URL path for http must not be null, undefined or empty."}),Array.isArray(g)&&C(2===g.length,function(){return"URL paths for http must have a length of 2, (actual length is "+g.length+")."}),this.path=g,null!=te.requestInit&&null!=te.requestInit.body)throw Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=te.requestInit||{}}return t.prototype.save=function(g){return n(this,void 0,void 0,function(){var te,tr,to,tu;return r(this,function(tc){switch(tc.label){case 0:if(g.modelTopology instanceof ArrayBuffer)throw Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");return(te=Object.assign({method:this.DEFAULT_METHOD},this.requestInit)).body=new FormData,tr=[{paths:["./model.weights.bin"],weights:g.weightSpecs}],to={modelTopology:g.modelTopology,format:g.format,generatedBy:g.generatedBy,convertedBy:g.convertedBy,userDefinedMetadata:g.userDefinedMetadata,weightsManifest:tr},te.body.append("model.json",new Blob([JSON.stringify(to)],{type:"application/json"}),"model.json"),null!=g.weightData&&te.body.append("model.weights.bin",new Blob([g.weightData],{type:"application/octet-stream"}),"model.weights.bin"),[4,this.fetch(this.path,te)];case 1:if((tu=tc.sent()).ok)return[2,{modelArtifactsInfo:vf(g),responses:[tu]}];throw Error("BrowserHTTPRequest.save() failed due to HTTP response status "+tu.status+".")}})})},t.prototype.load=function(){return n(this,void 0,void 0,function(){var g,te,tr,to,tu,tc,tl,th,td,tf,tp,tv;return r(this,function(tm){switch(tm.label){case 0:return[4,this.fetch(this.path,this.requestInit)];case 1:if(!(g=tm.sent()).ok)throw Error("Request to "+this.path+" failed with status code "+g.status+". Please verify this URL points to the model JSON of the model to load.");tm.label=2;case 2:return tm.trys.push([2,4,,5]),[4,g.json()];case 3:return te=tm.sent(),[3,5];case 4:throw tm.sent(),tr="Failed to parse model JSON of response from "+this.path+".",this.path.endsWith(".pb")?tr+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":tr+=" Please make sure the server is serving valid JSON for this request.",Error(tr);case 5:if(to=te.modelTopology,tu=te.weightsManifest,tc=te.generatedBy,tl=te.convertedBy,th=te.format,td=te.userDefinedMetadata,null==to&&null==tu)throw Error("The JSON from HTTP path "+this.path+" contains neither model topology or manifest for weights.");return null==tu?[3,7]:[4,this.loadWeights(tu)];case 6:tf=(tv=tm.sent())[0],tp=tv[1],tm.label=7;case 7:return[2,{modelTopology:to,weightSpecs:tf,weightData:tp,userDefinedMetadata:td,generatedBy:tc,convertedBy:tl,format:th}]}})})},t.prototype.loadWeights=function(g){return n(this,void 0,void 0,function(){var te,tr,to,tu,tc,tl,th,td,tf,tp;return r(this,function(tv){switch(tv.label){case 0:var tm,tg,ty;for(tg=(tm=Array.isArray(this.path)?this.path[1]:this.path).lastIndexOf("/"),ty=tm.lastIndexOf("?"),tr=(te=[tm.substring(0,tg)+"/",ty>tg?tm.substring(ty):""])[0],to=te[1],tu=this.weightPathPrefix||tr,tc=[],tl=0,th=g;tl<th.length;tl++)td=th[tl],tc.push.apply(tc,td.weights);return tf=[],g.forEach(function(g){g.paths.forEach(function(g){tf.push(tu+g+to)})}),[4,jf(tf,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress})];case 1:return tp=tv.sent(),[2,[tc,df(tp)]]}})})},t.URL_SCHEME_REGEX=/^https?:\/\//,t}();function $f(g){return null!=g.match(a2.URL_SCHEME_REGEX)}var Qf=function(g,te){return"undefined"==typeof fetch?null:(Array.isArray(g)?g.every(function(g){return $f(g)}):$f(g))?Jf(g,{onProgress:te}):null};function Jf(g,te){return new a2(g,te)}aG.registerSaveRouter(Qf),aG.registerLoadRouter(Qf);var a3=function(){function t(g){this.modelArtifacts=g}return t.prototype.load=function(){return n(this,void 0,void 0,function(){return r(this,function(g){return[2,this.modelArtifacts]})})},t}(),a4=function(){function t(g){this.saveHandler=g}return t.prototype.save=function(g){return n(this,void 0,void 0,function(){return r(this,function(te){return[2,this.saveHandler(g)]})})},t}(),a5=Object.freeze({browserFiles:function(g){return new a1(g)},browserHTTPRequest:function(g,te){return Jf(g,te)},concatenateArrayBuffers:df,decodeWeights:cf,encodeWeights:function(g,te){return n(this,void 0,void 0,function(){var tr,to,tu,tc,tl,th=this;return r(this,function(td){switch(td.label){case 0:for(tr=[],to=[],tu=Array.isArray(g)?g.map(function(g){return g.name}):Object.keys(g),tc=function(tc){var tl=tu[tc],td=Array.isArray(g)?g[tc].tensor:g[tl];if("float32"!==td.dtype&&"int32"!==td.dtype&&"bool"!==td.dtype&&"string"!==td.dtype)throw Error("Unsupported dtype in weight '"+tl+"': "+td.dtype);var tf={name:tl,shape:td.shape,dtype:td.dtype};if("string"===td.dtype){var tp=new Promise(function(g){return n(th,void 0,void 0,function(){var te,tr,to,tu,tc,tl,th;return r(this,function(tf){switch(tf.label){case 0:return[4,td.bytes()];case 1:for(tr=(te=tf.sent()).reduce(function(g,te){return g+te.length},0)+4*te.length,to=new Uint8Array(tr),tu=0,tc=0;tc<te.length;tc++)tl=te[tc],th=new Uint8Array(new Uint32Array([tl.length]).buffer),to.set(th,tu),tu+=4,to.set(tl,tu),tu+=tl.length;return g(to),[2]}})})});to.push(tp)}else to.push(td.data());null!=te&&(tf.group=te),tr.push(tf)},tl=0;tl<tu.length;++tl)tc(tl);return[4,Promise.all(to)];case 1:return[2,{data:lf(td.sent()),specs:tr}]}})})},fromMemory:function(g,te,tr,to){return 1==arguments.length?null!=g.modelTopology||null!=g.weightSpecs?new a3(g):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new a3({modelTopology:g})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new a3({modelTopology:g,weightSpecs:te,weightData:tr,trainingConfig:to}))},getLoadHandlers:function(g,te){return aG.getLoadHandlers(g,te)},getModelArtifactsInfoForJSON:vf,getSaveHandlers:function(g){return aG.getSaveHandlers(g)},http:Jf,isHTTPScheme:$f,loadWeights:function(g,te,tr,to){return void 0===te&&(te=""),n(this,void 0,void 0,function(){return r(this,function(tu){return[2,Xf(function(g){return jf(g,{requestInit:to})})(g,te,tr)]})})},registerLoadRouter:function(g){return aG.registerLoadRouter(g)},registerSaveRouter:function(g){return aG.registerSaveRouter(g)},weightsLoaderFactory:Xf,withSaveHandler:function(g){return new a4(g)},copyModel:function(g,te){return n(this,void 0,void 0,function(){return r(this,function(tr){return[2,bf(g,te,!1)]})})},listModels:function(){return n(this,void 0,void 0,function(){var g,te,tr,to,tu,tc,tl;return r(this,function(th){switch(th.label){case 0:g=aq.getSchemes(),te={},tr=0,to=g,th.label=1;case 1:return tr<to.length?(tu=to[tr],[4,aq.getManager(tu).listModels()]):[3,4];case 2:for(tl in tc=th.sent())te[tu+"://"+tl]=tc[tl];th.label=3;case 3:return tr++,[3,1];case 4:return[2,te]}})})},moveModel:function(g,te){return n(this,void 0,void 0,function(){return r(this,function(tr){return[2,bf(g,te,!0)]})})},removeModel:function(g){return n(this,void 0,void 0,function(){var te;return r(this,function(tr){return te=xf(g),[2,aq.getManager(te.scheme).removeModel(te.path)]})})}});Object.freeze({confusionMatrix:An({confusionMatrix_:function(g,te,tr){var to=mn(g,"labels","confusionMatrix"),tu=mn(te,"predictions","confusionMatrix");C(null==tr||tr>0&&Number.isInteger(tr),function(){return"If provided, numClasses must be a positive integer, but got "+tr}),C(1===to.rank,function(){return"Expected the rank of labels to be 1, but got "+to.rank}),C(1===tu.rank,function(){return"Expected the rank of predictions to be 1, but got "+tu.rank}),C(to.shape[0]===tu.shape[0],function(){return"Mismatch in the number of examples: "+to.shape[0]+" vs. "+tu.shape[0]+". Labels and predictions should have the same number of elements."}),C(tr>0&&Number.isInteger(tr),function(){return"numClasses is required to be a positive integer, but got "+tr});var tc=nI(to.asType("int32"),tr),tl=nI(tu.asType("int32"),tr);return tc.transpose().matMul(tl).asType("int32")}})});var a6=Object.freeze({toPixels:function(g,te){return n(this,void 0,void 0,function(){var tr,to,tu,tc,tl,th,td,tf,tp,tv,tm,tg,ty,tx,tC,tw,tE,tR,tI,tk,tA,tS,tD;return r(this,function(tN){switch(tN.label){case 0:if(tr=mn(g,"img","toPixels"),g instanceof tb||(tr=tr.toInt()),2!==tr.rank&&3!==tr.rank)throw Error("toPixels only supports rank 2 or 3 tensors, got rank "+tr.rank+".");if(tu=(to=tr.shape.slice(0,2))[0],tc=to[1],(tl=2===tr.rank?1:tr.shape[2])>4||2===tl)throw Error("toPixels only supports depth of size 1, 3 or 4 but got "+tl);return[4,tr.data()];case 1:return th=tN.sent(),td=tr.min(),tf=tr.max(),[4,Promise.all([td.data(),tf.data()])];case 2:if(tv=(tp=tN.sent())[0],tm=tp[1],tg=tv[0],ty=tm[0],td.dispose(),tf.dispose(),"float32"===tr.dtype){if(tg<0||ty>1)throw Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range ["+tg+" - "+ty+"].")}else{if("int32"!==tr.dtype)throw Error("Unsupported type for toPixels: "+tr.dtype+". Please use float32 or int32 tensors.");if(tg<0||ty>255)throw Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range ["+tg+" - "+ty+"].")}for(tx="float32"===tr.dtype?255:1,tC=new Uint8ClampedArray(tc*tu*4),tw=0;tw<tu*tc;++tw)tE=void 0,tR=void 0,tI=void 0,tk=void 0,1===tl?(tE=th[tw]*tx,tR=th[tw]*tx,tI=th[tw]*tx,tk=255):3===tl?(tE=th[3*tw]*tx,tR=th[3*tw+1]*tx,tI=th[3*tw+2]*tx,tk=255):4===tl&&(tE=th[4*tw]*tx,tR=th[4*tw+1]*tx,tI=th[4*tw+2]*tx,tk=th[4*tw+3]*tx),tC[(tA=4*tw)+0]=Math.round(tE),tC[tA+1]=Math.round(tR),tC[tA+2]=Math.round(tI),tC[tA+3]=Math.round(tk);return null!=te&&(te.width=tc,te.height=tu,tS=te.getContext("2d"),tD=new ImageData(tC,tc,tu),tS.putImageData(tD,0,0)),tr!==g&&tr.dispose(),[2,tC]}})})},fromPixels:An({fromPixels_:function(g,te){if(void 0===te&&(te=3),te>4)throw Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==g)throw Error("pixels passed to tf.browser.fromPixels() can not be null");var tr=!1,tu=!1,tc=!1,tl=!1,th=!1;if(g.data instanceof Uint8Array)tr=!0;else if("undefined"!=typeof ImageData&&g instanceof ImageData)tu=!0;else if("undefined"!=typeof HTMLVideoElement&&g instanceof HTMLVideoElement)tc=!0;else if("undefined"!=typeof HTMLImageElement&&g instanceof HTMLImageElement)tl=!0;else{if(null==g.getContext)throw Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was "+g.constructor.name);th=!0}if(tc&&tc&&g.readyState<2)throw Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(null!=l("FromPixels",tB.backendName))return tB.runKernel("FromPixels",{pixels:g},{numChannels:te});var td,tf,tp=tc?[g.videoWidth,g.videoHeight]:[g.width,g.height],tv=tp[0],tm=tp[1];if(th?td=g.getContext("2d").getImageData(0,0,tv,tm).data:tu||tr?td=g.data:(tl||tc)&&(null==to&&(to=document.createElement("canvas").getContext("2d")),to.canvas.width=tv,to.canvas.height=tm,to.drawImage(g,0,0,tv,tm),td=to.getImageData(0,0,tv,tm).data),4===te)tf=new Int32Array(td);else{var tg=tv*tm;tf=new Int32Array(tg*te);for(var ty=0;ty<tg;ty++)for(var tx=0;tx<te;++tx)tf[ty*te+tx]=td[4*ty+tx]}return Pn(tf,[tm,tv,te],"int32")}})}),a8=function(){function t(){}return t.prototype.getClassName=function(){return this.constructor.className},t.fromConfig=function(g,te){return new g(te)},t}(),a7=function(){function t(){this.classNameMap={}}return t.getMap=function(){return null==t.instance&&(t.instance=new t),t.instance},t.register=function(g){t.getMap().classNameMap[g.className]=[g,g.fromConfig]},t}();function cd(g){C(null!=g.className,function(){return"Class being registered does not have the static className property defined."}),C("string"==typeof g.className,function(){return"className is required to be a string, but got type "+typeof g.className}),C(g.className.length>0,function(){return"Class being registered has an empty-string as its className, which is disallowed."}),a7.register(g)}function dd(){return 32===tB.backend.floatPrecision()?.001:.1}function pd(g,te,tr){var to=!0;if((V(g)||V(te))&&(to=!1),V(g)&&V(te)&&(to=!0),to){var tu=g.constructor.name,tc=te.constructor.name;if(tu!==tc)throw Error("Arrays are of different type. Actual: "+tu+". Expected: "+tc)}if(Array.isArray(g)&&Array.isArray(te)){var tl=pn(g),th=pn(te);if(!S(tl,th))throw Error("Arrays have different shapes. Actual: ["+tl+"]. Expected: ["+th+"]")}var td=V(g)?g:I(g),tf=V(te)?te:I(te);if(td.length!==tf.length)throw Error("Arrays have different lengths actual: "+td.length+" vs expected: "+tf.length+".\nActual:   "+td+".\nExpected: "+tf+".");for(var tp=0;tp<tf.length;++tp){var tv=td[tp],tm=tf[tp];if(!tr(tv,tm))throw Error("Arrays differ: actual["+tp+"] = "+tv+", expected["+tp+"] = "+tm+".\nActual:   "+td+".\nExpected: "+tf+".")}}function vd(g,te,tr){return!isFinite(g)&&!isFinite(te)||!(isNaN(g)||isNaN(te)||Math.abs(g-te)>tr)}Object.freeze({Serializable:a8,SerializationMap:a7,registerClass:cd}),Object.freeze({TEST_EPSILON_FLOAT16:.1,expectArraysClose:function(g,te,tr){return null==tr&&(tr=dd()),pd(g,te,function(g,te){return vd(g,te,tr)})},testEpsilon:dd,expectPromiseToFail:function(g,te){g().then(function(){return te.fail()},function(){return te()})},expectArraysEqual:function(g,te){var tr="string"==typeof te||"number"==typeof te||"boolean"==typeof te?[te]:te;return H(g)||H(g[0])||H(te)||H(te[0])?pd(g,tr,function(g,te){return g==te}):pd(g,te,function(g,te){return vd(g,te,0)})},expectNumbersClose:function(g,te,tr){if(null==tr&&(tr=dd()),!vd(g,te,tr))throw Error("Numbers differ: actual === "+g+", expected === "+te)},expectValuesInRange:function(g,te,tr){for(var to=0;to<g.length;to++)if(g[to]<te||g[to]>tr)throw Error("Value out of range:"+g[to]+" low: "+te+", high: "+tr)},expectArrayBuffersEqual:function(g,te){expect(new Float32Array(g)).toEqual(new Float32Array(te))}}),Object.freeze({gpgpu_util:n6,webgl_util:t$,forceHalfFloat:function(){th.set("WEBGL_FORCE_F16_TEXTURES",!0)},MathBackendWebGL:e_,setWebGLContext:Kt,GPGPUContext:n8});var a9=function(g){function o(){return null!==g&&g.apply(this,arguments)||this}return e(o,g),o.prototype.minimize=function(g,te,tr){void 0===te&&(te=!1);var to=this.computeGradients(g,tr),tu=to.value,tc=to.grads;if(null!=tr){var tl=tr.map(function(g){return{name:g.name,tensor:tc[g.name]}});this.applyGradients(tl)}else this.applyGradients(tc);return tn(tc),te?tu:(tu.dispose(),null)},Object.defineProperty(o.prototype,"iterations",{get:function(){return null==this.iterations_&&(this.iterations_=0),this.iterations_},enumerable:!0,configurable:!0}),o.prototype.incrementIterations=function(){this.iterations_=this.iterations+1},o.prototype.computeGradients=function(g,te){return po(g,te)},o.prototype.dispose=function(){null!=this.iterations_&&tn(this.iterations_)},o.prototype.saveIterations=function(){return n(this,void 0,void 0,function(){return r(this,function(g){return null==this.iterations_&&(this.iterations_=0),[2,{name:"iter",tensor:On(this.iterations_,"int32")}]})})},o.prototype.getWeights=function(){return n(this,void 0,void 0,function(){return r(this,function(g){throw Error("getWeights() is not implemented for this optimizer yet.")})})},o.prototype.setWeights=function(g){return n(this,void 0,void 0,function(){return r(this,function(g){throw Error("setWeights() is not implemented for this optimizer class "+this.getClassName())})})},o.prototype.extractIterations=function(g){return n(this,void 0,void 0,function(){var te;return r(this,function(tr){switch(tr.label){case 0:return te=this,[4,g[0].tensor.data()];case 1:return te.iterations_=tr.sent()[0],[2,g.slice(1)]}})})},o}(a8);Object.defineProperty(a9,Symbol.hasInstance,{value:function(g){return null!=g.minimize&&null!=g.computeGradients&&null!=g.applyGradients}});var ie=function(g){function o(te,tr,to){void 0===to&&(to=null);var tu=g.call(this)||this;return tu.learningRate=te,tu.rho=tr,tu.epsilon=to,tu.accumulatedGrads=[],tu.accumulatedUpdates=[],null==to&&(tu.epsilon=tB.backend.epsilon()),tu}return e(o,g),o.prototype.applyGradients=function(g){var te=this;(Array.isArray(g)?g.map(function(g){return g.name}):Object.keys(g)).forEach(function(tr,to){var tu=tB.registeredVariables[tr];null==te.accumulatedGrads[to]&&(te.accumulatedGrads[to]={originalName:tr+"/accum_grad",variable:Ze(function(){return t1(tu).variable(!1)})}),null==te.accumulatedUpdates[to]&&(te.accumulatedUpdates[to]={originalName:tr+"/accum_var",variable:Ze(function(){return t1(tu).variable(!1)})});var tc=Array.isArray(g)?g[to].tensor:g[tr];if(null!=tc){var tl=te.accumulatedGrads[to].variable,th=te.accumulatedUpdates[to].variable;Ze(function(){var g=tl.mul(te.rho).add(tc.square().mul(1-te.rho)),tr=th.add(te.epsilon).sqrt().div(tl.add(te.epsilon).sqrt()).mul(tc),to=th.mul(te.rho).add(tr.square().mul(1-te.rho));tl.assign(g),th.assign(to);var td=tr.mul(-te.learningRate).add(tu);tu.assign(td)})}}),this.incrementIterations()},o.prototype.dispose=function(){null!=this.accumulatedUpdates&&(tn(this.accumulatedGrads.map(function(g){return g.variable})),tn(this.accumulatedUpdates.map(function(g){return g.variable})))},o.prototype.getWeights=function(){return n(this,void 0,void 0,function(){var g;return r(this,function(te){switch(te.label){case 0:return g=this.accumulatedGrads.concat(this.accumulatedUpdates),[4,this.saveIterations()];case 1:return[2,[te.sent()].concat(g.map(function(g){return{name:g.originalName,tensor:g.variable}}))]}})})},o.prototype.setWeights=function(g){return n(this,void 0,void 0,function(){var te;return r(this,function(tr){switch(tr.label){case 0:return[4,this.extractIterations(g)];case 1:return te=(g=tr.sent()).length/2,this.accumulatedGrads=g.slice(0,te).map(function(g){return{originalName:g.name,variable:g.tensor.variable(!1)}}),this.accumulatedUpdates=g.slice(te,2*te).map(function(g){return{originalName:g.name,variable:g.tensor.variable(!1)}}),[2]}})})},o.prototype.getConfig=function(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}},o.fromConfig=function(g,te){return new g(te.learningRate,te.rho,te.epsilon)},o.className="Adadelta",o}(a9);cd(ie);var ir=function(g){function o(te,tr){void 0===tr&&(tr=.1);var to=g.call(this)||this;return to.learningRate=te,to.initialAccumulatorValue=tr,to.accumulatedGrads=[],to}return e(o,g),o.prototype.applyGradients=function(g){var te=this;(Array.isArray(g)?g.map(function(g){return g.name}):Object.keys(g)).forEach(function(tr,to){var tu=tB.registeredVariables[tr];null==te.accumulatedGrads[to]&&(te.accumulatedGrads[to]={originalName:tr+"/accumulator",variable:Ze(function(){return Hn(tu.shape,te.initialAccumulatorValue).variable(!1)})});var tc=Array.isArray(g)?g[to].tensor:g[tr];if(null!=tc){var tl=te.accumulatedGrads[to].variable;Ze(function(){var g=tl.add(tc.square());tl.assign(g);var tr=tc.div(g.add(tB.backend.epsilon()).sqrt()).mul(-te.learningRate).add(tu);tu.assign(tr)})}}),this.incrementIterations()},o.prototype.dispose=function(){null!=this.accumulatedGrads&&tn(this.accumulatedGrads.map(function(g){return g.variable}))},o.prototype.getWeights=function(){return n(this,void 0,void 0,function(){return r(this,function(g){switch(g.label){case 0:return[4,this.saveIterations()];case 1:return[2,[g.sent()].concat(this.accumulatedGrads.map(function(g){return{name:g.originalName,tensor:g.variable}}))]}})})},o.prototype.setWeights=function(g){return n(this,void 0,void 0,function(){return r(this,function(te){switch(te.label){case 0:return[4,this.extractIterations(g)];case 1:return g=te.sent(),this.accumulatedGrads=g.map(function(g){return{originalName:g.name,variable:g.tensor.variable(!1)}}),[2]}})})},o.prototype.getConfig=function(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}},o.fromConfig=function(g,te){return new g(te.learningRate,te.initialAccumulatorValue)},o.className="Adagrad",o}(a9);cd(ir);var ii=function(g){function o(te,tr,to,tu){void 0===tu&&(tu=null);var tc=g.call(this)||this;return tc.learningRate=te,tc.beta1=tr,tc.beta2=to,tc.epsilon=tu,tc.accumulatedFirstMoment=[],tc.accumulatedSecondMoment=[],Ze(function(){tc.accBeta1=On(tr).variable(),tc.accBeta2=On(to).variable()}),null==tu&&(tc.epsilon=tB.backend.epsilon()),tc}return e(o,g),o.prototype.applyGradients=function(g){var te=this,tr=Array.isArray(g)?g.map(function(g){return g.name}):Object.keys(g);Ze(function(){var to=rj(1,te.accBeta1),tu=rj(1,te.accBeta2);tr.forEach(function(tr,tc){var tl=tB.registeredVariables[tr];null==te.accumulatedFirstMoment[tc]&&(te.accumulatedFirstMoment[tc]={originalName:tr+"/m",variable:Ze(function(){return t1(tl).variable(!1)})}),null==te.accumulatedSecondMoment[tc]&&(te.accumulatedSecondMoment[tc]={originalName:tr+"/v",variable:Ze(function(){return t1(tl).variable(!1)})});var th=Array.isArray(g)?g[tc].tensor:g[tr];if(null!=th){var td=te.accumulatedFirstMoment[tc].variable,tf=te.accumulatedSecondMoment[tc].variable,tp=td.mul(te.beta1).add(th.mul(1-te.beta1)),tv=tf.mul(te.beta2).add(th.square().mul(1-te.beta2)),tm=tp.div(to),tg=tv.div(tu);td.assign(tp),tf.assign(tv);var ty=tm.div(tg.sqrt().add(te.epsilon)).mul(-te.learningRate).add(tl);tl.assign(ty)}}),te.accBeta1.assign(te.accBeta1.mul(te.beta1)),te.accBeta2.assign(te.accBeta2.mul(te.beta2))}),this.incrementIterations()},o.prototype.dispose=function(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&tn(this.accumulatedFirstMoment.map(function(g){return g.variable})),null!=this.accumulatedSecondMoment&&tn(this.accumulatedSecondMoment.map(function(g){return g.variable}))},o.prototype.getWeights=function(){return n(this,void 0,void 0,function(){var g;return r(this,function(te){switch(te.label){case 0:return g=this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment),[4,this.saveIterations()];case 1:return[2,[te.sent()].concat(g.map(function(g){return{name:g.originalName,tensor:g.variable}}))]}})})},o.prototype.setWeights=function(g){return n(this,void 0,void 0,function(){var te,tr=this;return r(this,function(to){switch(to.label){case 0:return[4,this.extractIterations(g)];case 1:return g=to.sent(),Ze(function(){tr.accBeta1.assign(rG(tr.beta1,tr.iterations_+1)),tr.accBeta2.assign(rG(tr.beta2,tr.iterations_+1))}),te=g.length/2,this.accumulatedFirstMoment=g.slice(0,te).map(function(g){return{originalName:g.name,variable:g.tensor.variable(!1)}}),this.accumulatedSecondMoment=g.slice(te,2*te).map(function(g){return{originalName:g.name,variable:g.tensor.variable(!1)}}),[2]}})})},o.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}},o.fromConfig=function(g,te){return new g(te.learningRate,te.beta1,te.beta2,te.epsilon)},o.className="Adam",o}(a9);cd(ii);var iu=function(g){function o(te,tr,to,tu,tc){void 0===tu&&(tu=null),void 0===tc&&(tc=0);var tl=g.call(this)||this;return tl.learningRate=te,tl.beta1=tr,tl.beta2=to,tl.epsilon=tu,tl.decay=tc,tl.accumulatedFirstMoment=[],tl.accumulatedWeightedInfNorm=[],Ze(function(){tl.iteration=On(0).variable(),tl.accBeta1=On(tr).variable()}),null==tu&&(tl.epsilon=tB.backend.epsilon()),tl}return e(o,g),o.prototype.applyGradients=function(g){var te=this,tr=Array.isArray(g)?g.map(function(g){return g.name}):Object.keys(g);Ze(function(){var to=rj(1,te.accBeta1),tu=rF(-te.learningRate,te.iteration.mul(te.decay).add(1));tr.forEach(function(tr,tc){var tl=tB.registeredVariables[tr];null==te.accumulatedFirstMoment[tc]&&(te.accumulatedFirstMoment[tc]={originalName:tr+"/m",variable:t1(tl).variable(!1)}),null==te.accumulatedWeightedInfNorm[tc]&&(te.accumulatedWeightedInfNorm[tc]={originalName:tr+"/v",variable:t1(tl).variable(!1)});var th=Array.isArray(g)?g[tc].tensor:g[tr];if(null!=th){var td=te.accumulatedFirstMoment[tc].variable,tf=te.accumulatedWeightedInfNorm[tc].variable,tp=td.mul(te.beta1).add(th.mul(1-te.beta1)),tv=tf.mul(te.beta2),tm=th.abs(),tg=tv.maximum(tm);td.assign(tp),tf.assign(tg);var ty=tu.div(to).mul(tp.div(tg.add(te.epsilon))).add(tl);tl.assign(ty)}}),te.iteration.assign(te.iteration.add(1)),te.accBeta1.assign(te.accBeta1.mul(te.beta1))}),this.incrementIterations()},o.prototype.dispose=function(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&tn(this.accumulatedFirstMoment.map(function(g){return g.variable})),null!=this.accumulatedWeightedInfNorm&&tn(this.accumulatedWeightedInfNorm.map(function(g){return g.variable}))},o.prototype.getWeights=function(){return n(this,void 0,void 0,function(){return r(this,function(g){throw Error("getWeights() is not implemented for Adamax yet.")})})},o.prototype.setWeights=function(g){return n(this,void 0,void 0,function(){return r(this,function(g){throw Error("setWeights() is not implemented for Adamax yet.")})})},o.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}},o.fromConfig=function(g,te){return new g(te.learningRate,te.beta1,te.beta2,te.epsilon,te.decay)},o.className="Adamax",o}(a9);cd(iu);var ic=function(g){function o(te){var tr=g.call(this)||this;return tr.learningRate=te,tr.setLearningRate(te),tr}return e(o,g),o.prototype.applyGradients=function(g){var te=this;(Array.isArray(g)?g.map(function(g){return g.name}):Object.keys(g)).forEach(function(tr,to){var tu=Array.isArray(g)?g[to].tensor:g[tr];if(null!=tu){var tc=tB.registeredVariables[tr];Ze(function(){var g=te.c.mul(tu).add(tc);tc.assign(g)})}}),this.incrementIterations()},o.prototype.setLearningRate=function(g){this.learningRate=g,null!=this.c&&this.c.dispose(),this.c=en(On(-g))},o.prototype.dispose=function(){this.c.dispose()},o.prototype.getWeights=function(){return n(this,void 0,void 0,function(){return r(this,function(g){switch(g.label){case 0:return[4,this.saveIterations()];case 1:return[2,[g.sent()]]}})})},o.prototype.setWeights=function(g){return n(this,void 0,void 0,function(){return r(this,function(te){switch(te.label){case 0:return[4,this.extractIterations(g)];case 1:if(0!==(g=te.sent()).length)throw Error("SGD optimizer does not have settable weights.");return[2]}})})},o.prototype.getConfig=function(){return{learningRate:this.learningRate}},o.fromConfig=function(g,te){return new g(te.learningRate)},o.className="SGD",o}(a9);cd(ic);var il=function(g){function o(te,tr,to){void 0===to&&(to=!1);var tu=g.call(this,te)||this;return tu.learningRate=te,tu.momentum=tr,tu.useNesterov=to,tu.accumulations=[],tu.m=On(tu.momentum),tu}return e(o,g),o.prototype.applyGradients=function(g){var te=this;(Array.isArray(g)?g.map(function(g){return g.name}):Object.keys(g)).forEach(function(tr,to){var tu=tB.registeredVariables[tr];null==te.accumulations[to]&&(te.accumulations[to]={originalName:tr+"/momentum",variable:Ze(function(){return t1(tu).variable(!1)})});var tc=te.accumulations[to].variable,tl=Array.isArray(g)?g[to].tensor:g[tr];null!=tl&&Ze(function(){var g,tr=te.m.mul(tc).add(tl);g=te.useNesterov?te.c.mul(tl.add(tr.mul(te.m))).add(tu):te.c.mul(tr).add(tu),tc.assign(tr),tu.assign(g)})}),this.incrementIterations()},o.prototype.dispose=function(){this.m.dispose(),null!=this.accumulations&&tn(this.accumulations.map(function(g){return g.variable}))},o.prototype.setMomentum=function(g){this.momentum=g},o.prototype.getWeights=function(){return n(this,void 0,void 0,function(){return r(this,function(g){switch(g.label){case 0:return[4,this.saveIterations()];case 1:return[2,[g.sent()].concat(this.accumulations.map(function(g){return{name:g.originalName,tensor:g.variable}}))]}})})},o.prototype.setWeights=function(g){return n(this,void 0,void 0,function(){return r(this,function(te){switch(te.label){case 0:return[4,this.extractIterations(g)];case 1:return g=te.sent(),this.accumulations=g.map(function(g){return{originalName:g.name,variable:g.tensor.variable(!1)}}),[2]}})})},o.prototype.getConfig=function(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}},o.fromConfig=function(g,te){return new g(te.learningRate,te.momentum,te.useNesterov)},o.className="Momentum",o}(ic);cd(il);var ih=function(g){function o(te,tr,to,tu,tc){void 0===tr&&(tr=.9),void 0===to&&(to=0),void 0===tu&&(tu=null),void 0===tc&&(tc=!1);var tl=g.call(this)||this;if(tl.learningRate=te,tl.decay=tr,tl.momentum=to,tl.epsilon=tu,tl.accumulatedMeanSquares=[],tl.accumulatedMoments=[],tl.accumulatedMeanGrads=[],tl.centered=tc,null==tu&&(tl.epsilon=tB.backend.epsilon()),null==te)throw Error("learningRate for RMSPropOptimizer must be defined.");return tl}return e(o,g),o.prototype.applyGradients=function(g){var te=this;(Array.isArray(g)?g.map(function(g){return g.name}):Object.keys(g)).forEach(function(tr,to){var tu=tB.registeredVariables[tr];null==te.accumulatedMeanSquares[to]&&(te.accumulatedMeanSquares[to]={originalName:tr+"/rms",variable:Ze(function(){return t1(tu).variable(!1)})}),null==te.accumulatedMoments[to]&&(te.accumulatedMoments[to]={originalName:tr+"/momentum",variable:Ze(function(){return t1(tu).variable(!1)})}),null==te.accumulatedMeanGrads[to]&&te.centered&&(te.accumulatedMeanGrads[to]={originalName:tr+"/mg",variable:Ze(function(){return t1(tu).variable(!1)})});var tc=Array.isArray(g)?g[to].tensor:g[tr];if(null!=tc){var tl=te.accumulatedMeanSquares[to].variable,th=te.accumulatedMoments[to].variable;Ze(function(){var g=tl.mul(te.decay).add(tc.square().mul(1-te.decay));if(te.centered){var tr=te.accumulatedMeanGrads[to].variable,td=tr.mul(te.decay).add(tc.mul(1-te.decay)),tf=th.mul(te.momentum).add(tc.mul(te.learningRate).div(g.sub(td.square().add(te.epsilon)).sqrt()));tl.assign(g),tr.assign(td),th.assign(tf);var tp=tu.sub(tf);tu.assign(tp)}else{var tv=tl.mul(te.decay).add(tc.square().mul(1-te.decay));tf=th.mul(te.momentum).add(tc.mul(te.learningRate).div(tv.add(te.epsilon).sqrt())),tl.assign(tv),th.assign(tf),tp=tu.sub(tf),tu.assign(tp)}})}}),this.incrementIterations()},o.prototype.dispose=function(){null!=this.accumulatedMeanSquares&&tn(this.accumulatedMeanSquares.map(function(g){return g.variable})),null!=this.accumulatedMeanGrads&&this.centered&&tn(this.accumulatedMeanGrads.map(function(g){return g.variable})),null!=this.accumulatedMoments&&tn(this.accumulatedMoments.map(function(g){return g.variable}))},o.prototype.getWeights=function(){return n(this,void 0,void 0,function(){var g;return r(this,function(te){switch(te.label){case 0:return g=this.accumulatedMeanSquares.concat(this.accumulatedMoments),this.centered&&g.push.apply(g,this.accumulatedMeanGrads),[4,this.saveIterations()];case 1:return[2,[te.sent()].concat(g.map(function(g){return{name:g.originalName,tensor:g.variable}}))]}})})},o.prototype.setWeights=function(g){return n(this,void 0,void 0,function(){var te;return r(this,function(tr){switch(tr.label){case 0:return[4,this.extractIterations(g)];case 1:return g=tr.sent(),te=this.centered?g.length/3:g.length/2,this.accumulatedMeanSquares=g.slice(0,te).map(function(g){return{originalName:g.name,variable:g.tensor.variable(!1)}}),this.accumulatedMoments=g.slice(te,2*te).map(function(g){return{originalName:g.name,variable:g.tensor.variable(!1)}}),this.centered&&(this.accumulatedMeanGrads=g.slice(2*te,3*te).map(function(g){return{originalName:g.name,variable:g.tensor.variable(!1)}})),[2]}})})},o.prototype.getConfig=function(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}},o.fromConfig=function(g,te){return new g(te.learningRate,te.decay,te.momentum,te.epsilon,te.centered)},o.className="RMSProp",o}(a9);cd(ih);var id=function(){function t(){}return t.sgd=function(g){return new ic(g)},t.momentum=function(g,te,tr){return void 0===tr&&(tr=!1),new il(g,te,tr)},t.rmsprop=function(g,te,tr,to,tu){return void 0===te&&(te=.9),void 0===tr&&(tr=0),void 0===to&&(to=null),void 0===tu&&(tu=!1),new ih(g,te,tr,to,tu)},t.adam=function(g,te,tr,to){return void 0===g&&(g=.001),void 0===te&&(te=.9),void 0===tr&&(tr=.999),void 0===to&&(to=null),new ii(g,te,tr,to)},t.adadelta=function(g,te,tr){return void 0===g&&(g=.001),void 0===te&&(te=.95),void 0===tr&&(tr=null),new ie(g,te,tr)},t.adamax=function(g,te,tr,to,tu){return void 0===g&&(g=.002),void 0===te&&(te=.9),void 0===tr&&(tr=.999),void 0===to&&(to=null),void 0===tu&&(tu=0),new iu(g,te,tr,to,tu)},t.adagrad=function(g,te){return void 0===te&&(te=.1),new ir(g,te)},t}();id.sgd,id.momentum,id.adadelta,id.adagrad,id.rmsprop,id.adamax,id.adam,"undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate&&setImmediate,tb.prototype.squaredDifference=function(g){return eP(this,g)},ty=aS}}]);